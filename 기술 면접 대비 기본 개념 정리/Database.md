# Database

📖 **Contents**

- Database
  - [데이터베이스 인덱싱 자료구조 B-Tree](#데이터베이스-인덱싱-자료구조-b-tree)
  - [결제와 취소과정 트랜잭션](#결제와-취소과정-트랜잭션)
  - [웹에서 매핑이란](#웹에서-매핑이란)
  - [인메모리 데이터베이스](#인메모리-데이터베이스)
  - [Redis](#redis)

* * *

## 데이터베이스 인덱싱 자료구조 B-Tree
- **Django ORM 관련**
- 데이터베이스에서 쿼리가 처리될 때, 우리가 django ORM을 사용해서 데이터를 조회하면 데이터베이스에 맞는 쿼리가 생성되어 전송된다. 그리고 데이터베이스는 쿼리를 받으면 내부의 Optimizer가 실행계획을 계산해서 최적화된 탐색 방식으로 인덱스를 타도록 조회를 수행한다. 쿼리가 데이터베이스에 Hit 되고나서 Optimizer가 데이터베이스 내부에서 조회를 수행한다.
  - **Optimizer는 DBMS의 핵심 엔진이다.**
- 우리가 DB에서 사용하는 pk같은 경우, 우리가 먼저 Primary Key로 선언을 하는 것이기 때문에 그것도 사실 키이다. 그래서 얘네들은 자동으로 인덱싱이 된다. 그래서 보통은 우리가 인덱싱을 사용하지 않고도 빠르게 탐색하는 방법 중 하나는, 웬만하면 get이나 filter를 사용할 때 pk를 통해서 검색하는 것이 진짜 빠르게 검색이 된다.

- [관련 블로그](https://coding-factory.tistory.com/743)


* * *

## 결제와 취소과정 트랜잭션
- **일반적인 결제 과정**
  - 처음에 먼저 우리 DB에 고객이 입력한 주문 내역 정보들을 입력하기(결제정보 입력창으로부터 정보 받기)
  - 그 다음에 고객이 결제창을 띄워서 PG사한테 결제 요청 하기
  - 결제 수단 마다 인증 단계 진행하기(카드사 또는 은행 서버 등등)
  - 우리 서버에서 PG사쪽으로 결제 승인 API를 보내고 최종 결제 승인 여부 확인하기
  - 승인이 성공으로 끝나면 우리 서버 DB에 있는 예약 내역을 성공으로 업데이트 하기
  - 마지막으로 예약이 성공되었다는 화면 보여주기

- **일반적인 취소 과정**
  - 결제 취소 요청
  - PG사에 결제 취소 API 호출
  - 성공 응답이면 트랜잭션 시작
  - 모델 레코드 상태를 CANCELED로 변경하고 취소 시각을 입력
  - 구매 수량 원 상태로 복구
  - 마지막으로 트랜잭션 종료


- **트랜잭션**이란, 우리의 단계 뿐만이 아니라 외부의 단계를 포함해서 수행되는 시간이 서로 다르지만, 한 번에 묶음 처리 되어야 하는 처리 과정을 의미한다. 또한, 컴퓨터 사이언스 분야에서 트랜잭션은 **"쪼개질 수 없는 업무처리의 단위"** 를 의미한다.
  - 트랜잭션에서 하나라도 내부에 있는 작업이 실패하게 되면, (하나의 수정작업 update가 실패하면) 트랜젝션 상의 모든 업데이트가 취소된다. 즉, 모든 업데이트가 실패 이전 상태로 복구된다. 이것을 **"롤백"** 이라고 부른다.
  - 데이터베이스 작업이나 결제 및 송금 과정과 같이 **코드를 한 단위로 수행하는 것**을 의미한다.

- **TPS**
  - TPS란 Transaction Per Second의 약자로 1초 당 처리할 수 있는 트랜잭션의 개수를 의미한다.
  - ex) 실제로 API가 호출이 되서 응답이 될 때 그 하나의 단위를 트랜잭션이라고 본다면, 1초 당 API가 호출되는 카운트를 의미하기도 한다.
  - ex) TPS를 DB에 다시 대입해서 생각해보면, DB가 동시에 처리가능한 트랜잭션의 수가 될 수도 있다.

- **트랜잭션의 4가지 특성 - ACID**
  - 1. Atomicity(원자성) : 트랙잭션의 작업이 모두 수행되거나 혹은 모두 수행이 안되거나 이다. 하나의 트랜잭션 안에 여러가지 코드가 들어가 있고 여러가지 오퍼레이션이 수행되더라도 그 중 하나라도 실패한다면 아무것도 실행이 안되는 상태가 보장이 되어야 한다.
  - 2. Consistency(일관성) : 트랜잭션이 수행되는 순간에는 여러번 읽더라도 데이터베이스의 상태가 똑같해야 한다는 것이다. 예를 들어, 내가 트랜잭션을 시작했는데 거기있는 값이 일관성없이 이리저리 바뀌게 된다면 트랜잭션이 수행되는 동안에 내가 보고있는 데이터가 변질이 계속 되는 것이다. 그러면 일관성이 없다고 볼 수 있다.
  - 3. Isolation(독립성, 고립성) : 하나의 트랜잭션이 수행되고 데이터를 갱신하는 동안에는 이 트랜잭션이 완료되기 전에 갱신중인 데이터에 다른 트랜잭션이 접근하지 못하게 해야한다는 것이다. 내가 어떤 데이터를 막 수정하고 있는데 다른 애가 와서 덮어쓰고 내가 수정하려고 하면 내껄 날려버리고 이러면 안될 것이다.
  - 4. Durability(지속성) : 트랜잭션이 끝나고 나면 커밋이 마무리가 되고 그 갱신 사항이 이후에도 계속 유지되고 적용되어야 한다는 것이다. 

- [관련 블로그](https://han.gl/nxfTO)
- [결제 흐름 예시](https://han.gl/TAvUr)


* * *

## 웹에서 매핑이란
- https://threeidiotscoding.tistory.com/26


* * *

## 인메모리 데이터베이스
- **인메모리 데이터베이스란, 데이터를 디스크에 저장하는 데이터베이스가 아니라 메모리에 데이터를 저장하는 데이터베이스이다.** 메모리에 바로 데이터를 저장하기 때문에 디스크로부터 데이터를 가져오는 시간이 절약되어 디스크 접근보다 훨씬 빠른 데이터 작업이 가능하다.
- 하지만, **RAM에 데이터를 저장**하기 때문에 전원이 갑자기 꺼지게 된다면 모든 데이터가 사라져 영속성이 보장되지 못한다. 그래서 로그인 세션과 같이 잃어버려도 문제가 되지 않는 데이터를 저장하는데 사용한다.

- 대표적인 인메모리 데이터베이스로 Redis, Memcached 등이 있다.

- [관련 블로그](https://velog.io/@gwon7210/%EC%9D%B8%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%9E%80)


* * *

## Redis
- Redis는 대표적인 인메모리 데이터베이스로 가장 기본적이고 단순한 구조인 key-value 타입으로 데이터를 저장한다. 그래서 Redis는 NoSQL로 단순한 구조를 통해 높은 성능을 보장해준다.
- 또한, 데이터 저장소로 가장 입/출력 속도가 빠른 '메모리'를 채택했기에 빠른 속도를 보장한다.
- **이렇게 Redis와 같은 메모리 캐시 기반 서비스가 많이 사용되는 이유는, 캐시 방식을 통해 DB Read 부하를 감소시킬 수 있기 때문이다.**
  - 기존에는 데이터 조회 요청이 오면 -> DB에서 데이터를 직접 조회했다면,
  - **Redis를 사용하면 데이터 조회 요청이 왔을 때 -> Cache에서 해당 데이터를 조회하고 -> Cache에서 응답하게 된다.** 
    - Cache에 데이터가 없다면 DB 데이터를 조회한다. 그리고 이 때 조회한 데이터를 Cache에 저장하고 이후에는 Cache에서 바로 응답을 해준다.
    - 따라서 Redis는 급격하게 사용자가 집중되는 환경이나 대규모의 확장이 예정된 환경에 적합하다.


- **Cache(캐시)** : Cache란, **‘어떤 데이터 요청에 대해서 굳이 원본 소스를 탐색하지 않더라도 요청하는 자원에게 더 가까운 컴퓨팅 자원이 기억해두었다가 빠르게 데이터를 돌려주는 것’** 이라고 정의할 수 있다.
  - 따라서, Redis는 Cache중에서도 데이터베이스 Cache의 일종이라고 할 수 있다. 


- **Redis 예시**
  - Redis 메모리 데이터베이스를 이용하여 로그인 시 저장해야하는 세션을 RAM 메모리에 저장할 수 있다.
  - 웹 서비스의 고정된 게시판에 Redis를 이용해서 Cache를 적용할 수 있다. 고정된 게시판에 대한 요청이 왔을 때 -> Cache를 적용하면 직접적으로 DB로 HIT 하는 게 아니라 redis 서버의 Cache에서 꺼내주는 것이다. 일단 처음에는 Cache에 데이터가 없어서 페이지를 일단 DB로 랜더링을 하고, 그리고 나서 우리가 그 다음에 이 페이지에 다시 접근할 때는 속도가 조금 더 빨라진 것을 느낄 수 있다.

- [관련 블로그](https://ojava.tistory.com/70)




