# Database

📖 **Contents**

- Database
  - [DB의 인덱스란](#db의-인덱스란)
  - [데이터베이스 인덱스 자료구조 B플러스 Tree](#데이터베이스-인덱스-자료구조-b플러스-tree)
  - [결제와 취소과정 및 트랜잭션이란](#결제와-취소과정-및-트랜잭션이란)
  - [웹에서 매핑이란](#웹에서-매핑이란)
  - [인메모리 데이터베이스](#인메모리-데이터베이스)
  - [Redis](#redis)
  - [AWS RDS란](#aws-rds란)
  - [SQL과 NoSQL](#sql과-nosql)
  - [JOIN이란](#join이란)

* * *


## DB의 인덱스란
- **인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.** 데이터베이스의 index는 책의 색인과 같다. 데이터베이스에서도 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 도와주는 것이 바로 인덱스이다.
  - 일반적으로 데이터베이스를 생성 후 데이터를 생성하면 PK가 존재할 때 기본적으로 인덱스가 잡히게 된다. PK가 아니라면 별도의 인덱스 설정이 필요하다.
  - 만약 인덱스 기준이 하나도 잡혀있지 않은 경우에는 전체 데이터에서 순차적으로 확인하기 때문에 느리다. 만약 데이터가 특정 기준으로 정렬되어 있다면 검색을 빠르게 할 수 있다.
  - DB에 이름 / 성별 / 이메일 필드가 있는데 인덱스를 이메일로 정한 경우, 데이터가 이메일을 기준으로 정렬된다. 그래서 데이터를 찾는게 빨라질 수 있다. SELECT * FROM member WHERE email = ‘ase121@gmail.com’ 이렇게 인덱스가 적용된 대상을 WHERE절을 통해 검색하면 된다. **이 때, WHERE절을 사용하지 않으면 인덱스가 사용되지 않는다.**

- **즉, 인덱스는 데이터베이스 테이블에 대한 검색 성능을 향상시키는 자료 구조이며 WHERE절을 통해 활용된다.** 

- **인덱스의 특징**
  - 인덱스는 항상 최신의 정렬상태를 유지
  - 인덱스도 하나의 데이터베이스 객체이다
  - 데이터베이스 크기의 약 10% 정도의 저장공간이 필요

- **인덱스의 장점과 단점**
  - 장점
    - 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
    - 전반적인 시스템의 부하를 줄일 수 있다.
  - 단점
    - 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다. 메모리에도 인덱스를 저장하겠지만, 디스크에도 별도의 저장 공간에 인덱스를 저장해두기 때문이다.
    - 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다. CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하된다.

- **다량의 데이터를 DB에 입력하는 경우**
  - 해당 상황에서는, 다량의 데이터에 인덱스를 부여하는 것 조차 리소스가 될 수 있기 때문에 인덱스 부여를 해제하고 csv파일이나 엑셀파일로 정리해서 DB에 import(또는 export)를 진행하는 것이 좋다.

<br>

### 인덱스 알고리즘
- 페이지란, 데이터가 저장되는 단위이다. (16 kbyte)

- **1) Full Table Scan**
  - 페이지 3개가 있고, 페이지마다 값이 있을때, Full Table Scan를 적용하면 순차적으로 처음부터 찾게된다. 마지막 값을 찾는 경우에는 예를 들어 총 3개의 페이지와 12번의 검색을 거쳐야 한다.
  - 순차적으로 접근한다는 특징이 있다.
  - 그래서 접근 비용이 감소한다.
  - **적용가능한 인덱스가 없는 경우, 인덱스가 있어도 인덱스 처리범위가 넓은 경우, 크기가 작은 테이블에 엑세스하는 경우에 사용되는 알고리즘이다.**

- **2) B-Tree**
  - **비효율적으로 이진탐색 트리를 사용하는 것을 개선해서 나온게 B-Tree 자료구조이다.**
  - **이러한 B-Tree는 트리 높이가 같고, 자식 노드를 2개 이상 가질 수 있다. 그리고 기본 데이터베이스 인덱스의 자료구조라고 볼 수 있다.**
  - ex) 인덱스에서 B-Tree를 예시로 적용해보자. 여기서 루트페이지와 브랜치 페이지는 자식 페이지의 정보를 가지고 있다. 
    - 루트 페이지는 최상단에 위치하고 브랜치 페이지는 루트 페이지와 리프 페이지 사이에 여러개가 올 수 있다. 그리고 리프 페이지는 실제 데이터 페이지(클러스터링 인덱스) 또는 실제 데이터의 주소 페이지(논-클러스터링 인덱스)가 올 수 있다.
    - **그래서 특정 데이터를 찾게 된다면 먼저 루트 페이지를 검색하고 연결된 자식 페이지로 가서 검색하기 때문에 full table SCan를 할 때 마다 성능이 향상된 것을 확인할 수 있다. 인덱스를 통해 SELECT의 성능이 향상된다.**

- **인덱스에서 INSERT, UPDATE, DELETE의 경우는 어떨까**
  - **INSERT**가 진행될 때, 비어있는 페이지를 확보해야 되고 이미 꽉찬 문제가 있는 페이지의 데이터를 공평하게 나누어저 저장한다. 이러한 **페이지 분할** 작업은 페이지에 새로운 데이터를 추가할 여유공간이 없어 페이지에 변화가 발생하고, DB가 느려지고 성능에 영향을 준다.
  - **DELETE**는 인덱스의 데이터를 실제로 지우지 않고 사용안함 표시를 한다.
  - **UPDATE**는 실제로 인덱스는 이러한 개념이 없고 먼저 DELETE를 통해 기존 값을 사용안함 표시를 하고, INSERT를 통해 변경된 값을 삽입한다.

- **결론적으로는, 인덱스를 사용하는 경우 SELECT로 진행되는 조회 성능이 향상되고 INSERT, UPDATE, DELETE는 페이지 분할과 사용안함 표시로 인덱스의 조각화가 심해져 성능이 저하된다.**

<br>

### 인덱스의 종류

- **1) 클러스터링 인덱스**
  - 만약 Member라는 테이블을 생성하고 id, name, group이라는 컬럼이 존재한다고 가정해보자. 이 상황에서 id 컬럼에 클러스터링 인덱스를 적용하려고 한다면 **id 컬럼에 primary key를 적용**하면 된다.
  - 그리고 다른 방법으로는 **한 컬럼에 NOT NULL과 Unique 제약 조건을 동시에 적용**시키면 된다.
  - **그래서 이렇게 id 컬럼을 클러스터링 인덱스로 구성하게 되면, 클러스터링 인덱스를 적용한 id 칼럼을 기준으로 데이터를 정렬한다.** 
  - 그 다음, 정렬된 데이터를 기준으로 루트 페이지가 생성되고 id값마다 데이터 페이지의 주소를 가리키게 된다.
  - 그리고 데이터 페이지는 실제 데이터가 저장되는 페이지를 의미한다. 모든 컬럼에 대한 실제 데이터를 다 담고 있는 페이지를 데이터 페이지라고 한다. 이러한 데이터 페이지는 클러스터링 인덱스를 적용한 Id컬럼을 기준으로 데이터가 정렬이 되어있고 만약 어떤 데이터가 추가되거나 삭제되도 이 정렬을 최신상태로 유지하면서 데이터가 저장되어 있다.

- **클러스터링 인덱스의 특징**
  - 클러스터링 인덱스를 기준으로 실제 데이터 자체가 정렬된다
  - 그렇기 때문에 테이블 당 1개만 존재할 수 있다
  - B-Tree의 리프 페이지가 데이터 페이지와 동일하다
  - 클러스터링 인덱스를 생성하기 위해서는 primary key를 걸던지 / 아니면 unique와 not null 제약조건을 한 컬럼에 함께 걸어주면 된다
    - 만약, 한 테이블에 primary key도 있고 unique와 not null 제약조건을 가진 컬럼이 함께 존재한다면 —> primary key가 우선순위를 가지고 인덱스를 생성하게 된다.
 
<br>

- **2) 논-클러스터링 인덱스(보조 인덱스, 세컨더리 인덱스)**
  - 이번에는 name 컬럼에 논-클러스터링 인덱스를 적용한다고 가정해보자. 
  - 논-클러스터링 인덱스를 추가하는 방법은, **한 컬럼에 unique 제약 조건을 거는 것이다.**
  - 그리고 인덱스 자체를 생성할 수도 있다. 이렇게 인덱스를 직접 생성하게 되면 클러스터링 인덱스가 아니라, 논-클러스터링 인덱스가 생성된다.
  - **논-클러스터링 인덱스 구조는, 루트 페이지 - 별도의 인덱스 페이지가 추가(리프 페이지) - 데이터 페이지(실제 데이터가 저장된 곳으로 정렬되지 않고 변경되지 않는다) 이렇게 이루어진다.**
    - **즉, 데이터 페이지가 리프 페이지였던 클러스터링 인덱스와는 다르게, 별도의 name에 대한 인덱스 페이지가 추가로 생성된다. 이 리프 페이지는 name을 기준으로 정렬되어있다.**
    - 그리고 이 생성된 인덱스 페이지는 1002 + #3 이런식으로 실제 데이터 페이지의 주소와 함께, 해당 페이지에 몇번째에 데이터가 있는지 표시해준다.

- **논-클러스터링 인덱스의 특징**
  - 실제 데이터 페이지는 어떠한 변경도 없이 그대로이다
  - 별도의 인덱스 페이지가 생성된다 -> 그래서 추가적인 공간이 필요해진다
  - 따라서 2번처럼 추가만 하면 되기 때문에 한 테이블 당 논-클러스터링 인덱스가 여러 개 존재할 수 있다
  - B-Tree의 리프 페이지에는 실제 데이터 페이지 주소를 담고 있다
  - 논-클러스터링 인덱스를 생성하기 위해서는 한 컬럼에 unique 제약조건을 적용하면 생성된다
  - 직접 인덱스를 생성 하더라도 논-클러스터링 인덱스가 생성되는 것을 알 수 있다

<br>

### 클러스터링 인덱스와 논-클러스터링 인덱스를 함께 적용하면 어떻게 될까?
- ex) id 컬럼에 클러스터링 인덱스를 적용하고, name 컬럼에 논-클러스터링 인덱스를 적용한다면 => name 컬럼을 기준으로 한 루트 페이지가 만들어지고 새롭게 생성된 name 정렬 기준의 인덱스 페이지가 있다. 그리고 해당 인덱스 페이지는 1002 + #3 이러한 값이 아닌 id값을 가지게 된다. 여기까지가 name 컬럼의 논-클러스터링 인덱스 페이지가 된다.
  - 그리고 id 컬럼의 클러스터링 인덱스 페이지는, 위에서 검색된 id값을 루트 페이지에서 받아 실제 데이터 페이지의 주소로 연결되어 특정 데이터를 검색하게 된다.
- **즉, 클러스터링 인덱스와 논-클러스터링 인덱스를 함께 사용하더라도 우리가 앞서 살펴보았던 특징들은 동일하다.** 
  - **하지만 동시에 사용될 때 단 하나, 논-클러스터링 인덱스에서 “리프 페이지에 실제 데이터 페이지 주소가 존재” 한다는 게 아니라, “리프 페이지에 클러스터링 인덱스가 적용된 컬럼의 실제 값”이 존재한다는 걸 확인할 수 있었다.**

<br>

### 인덱스 적용 기준
- **어떤 컬럼에 인덱스를 적용해야 할까? 그래서 나온 개념이 “카디널리티”이다. 즉, 카디널리티(그룹 내 요소의 개수)가 높은 것, 즉 중복 수치가 낮은 컬럼을 선택해야 한다.**
  - 따라서 우리는 카디널리티가 높은, 즉 중복도가 낮은 컬럼에 인덱스를 적용해야 한다. 예를 들어 id, 이메일, 주민번호가 될 수 있다.

- 그리고 추가로, 조건들이 없다면 인덱스가 있더라도 사용되지 않기 때문에 WHERE, JOIN, ORDER By와 같은 절에 자주 사용되는 칼럼에 적용하면 좋다.
- 그리고 INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼에 적용하면 좋다. 이러한 것들은 성능 저하에 대한 영향이 있을 수 있기 때문에 이러한 작업이 자주 발생하지 않는 칼럼에 적용하는 것이 좋다.
- 그리고 규모가 작은 테이블에는 인덱스를 생성하더라도 효과가 미비하기 때문에, 규모가 작지 않은 테이블에 인덱스를 적용하는 것이 효과가 좋다.

- [관련 영상](https://www.youtube.com/watch?v=edpYzFgHbqs)

* * *

## 데이터베이스 인덱스 자료구조 B플러스 Tree
- **인덱스를 구현하기 위해서는 다양한 자료구조를 사용할 수 있다. 가장 대표적인 해시 테이블과 B+Tree가 있다.**
  - [관련 내용](https://mangkyu.tistory.com/96)


* * *

## 결제와 취소과정 및 트랜잭션이란
- **일반적인 결제 과정**
  - 처음에 먼저 우리 DB에 고객이 입력한 주문 내역 정보들을 입력하기(결제정보 입력창으로부터 정보 받기)
  - 그 다음에 고객이 결제창을 띄워서 PG사한테 결제 요청 하기
  - 결제 수단 마다 인증 단계 진행하기(카드사 또는 은행 서버 등등)
  - 우리 서버에서 PG사쪽으로 결제 승인 API를 보내고 최종 결제 승인 여부 확인하기
  - 승인이 성공으로 끝나면 우리 서버 DB에 있는 예약 내역을 성공으로 업데이트 하기
  - 마지막으로 예약이 성공되었다는 화면 보여주기

- **일반적인 취소 과정**
  - 결제 취소 요청
  - PG사에 결제 취소 API 호출
  - 성공 응답이면 트랜잭션 시작
  - 모델 레코드 상태를 CANCELED로 변경하고 취소 시각을 입력
  - 구매 수량 원 상태로 복구
  - 마지막으로 트랜잭션 종료

<br>

### 트랜잭션
- **트랜잭션**이란, 우리의 단계 뿐만이 아니라 외부의 단계를 포함해서 수행되는 시간이 서로 다르지만, 한 번에 묶음 처리 되어야 하는 처리 과정을 의미한다. **즉, 데이터에 한번에 입력할 수 있도록 묶어주는 데이터베이스의 작업 단위를 의미한다.** 또한, 컴퓨터 사이언스 분야에서 트랜잭션은 **"쪼개질 수 없는 업무처리의 단위"** 를 의미한다.
  - 트랜잭션에서 하나라도 내부에 있는 작업이 실패하게 되면, (하나의 수정작업 update가 실패하면) 트랜젝션 상의 모든 업데이트가 취소된다. 즉, 모든 업데이트가 실패 이전 상태로 복구된다. 이것을 **"롤백"** 이라고 부른다.
  - 데이터베이스 작업이나 결제 및 송금 과정과 같이 **코드를 한 단위로 수행하는 것**을 의미한다.

- **TPS**
  - TPS란 Transaction Per Second의 약자로 1초 당 처리할 수 있는 트랜잭션의 개수를 의미한다.
  - ex) 실제로 API가 호출이 되서 응답이 될 때 그 하나의 단위를 트랜잭션이라고 본다면, 1초 당 API가 호출되는 카운트를 의미하기도 한다.
  - ex) TPS를 DB에 다시 대입해서 생각해보면, DB가 동시에 처리가능한 트랜잭션의 수가 될 수도 있다.

- **트랜잭션의 4가지 특성 - ACID**
  - 1. Atomicity(원자성) : 트랙잭션의 작업이 모두 수행되거나 혹은 모두 수행이 안되거나 이다. 하나의 트랜잭션 안에 여러가지 코드가 들어가 있고 여러가지 오퍼레이션이 수행되더라도 그 중 하나라도 실패한다면 아무것도 실행이 안되는 상태가 보장이 되어야 한다.
  - 2. Consistency(일관성) : 트랜잭션이 수행되는 순간에는 여러번 읽더라도 데이터베이스의 상태가 똑같해야 한다는 것이다. 예를 들어, 내가 트랜잭션을 시작했는데 거기있는 값이 일관성없이 이리저리 바뀌게 된다면 트랜잭션이 수행되는 동안에 내가 보고있는 데이터가 변질이 계속 되는 것이다. 그러면 일관성이 없다고 볼 수 있다.
  - 3. Isolation(독립성, 고립성) : 하나의 트랜잭션이 수행되고 데이터를 갱신하는 동안에는 이 트랜잭션이 완료되기 전에 갱신중인 데이터에 다른 트랜잭션이 접근하지 못하게 해야한다는 것이다. 내가 어떤 데이터를 막 수정하고 있는데 다른 애가 와서 덮어쓰고 내가 수정하려고 하면 내껄 날려버리고 이러면 안될 것이다.
  - 4. Durability(지속성) : 트랜잭션이 끝나고 나면 커밋이 마무리가 되고 그 갱신 사항이 이후에도 계속 유지되고 적용되어야 한다는 것이다. 

- [관련 블로그](https://han.gl/nxfTO)
- [결제 흐름 예시](https://han.gl/TAvUr)


* * *

## 웹에서 매핑이란
- 매핑이란, 해당 값이 다른 값을 가리키도록 하는 것을 의미한다.
  - ex) http://localhost:8080/action.do 라는 페이지를 만들었다고 했을 때, 이 url이 그대로 노출된다면 보안상 매우 취약 할 수 있다. 그래서 action.do가 아닌 ac.do가 action.do랑 똑같다는 식으로 설정하여 ac.do로 갔을 때 action.do로 가게 함으로서 보안성을 높일 수 있다.
  - 또한, 이렇게 매핑을 하게되면 주소가 간결해질 수 있다.

- [관련 블로그](https://threeidiotscoding.tistory.com/26)


* * *

## 인메모리 데이터베이스
- **인메모리 데이터베이스란, 데이터를 디스크에 저장하는 데이터베이스가 아니라 메모리에 데이터를 저장하는 데이터베이스이다.** 메모리에 바로 데이터를 저장하기 때문에 디스크로부터 데이터를 가져오는 시간이 절약되어 디스크 접근보다 훨씬 빠른 데이터 작업이 가능하다.
- 하지만, **RAM에 데이터를 저장**하기 때문에 전원이 갑자기 꺼지게 된다면 모든 데이터가 사라져 영속성이 보장되지 못한다. 그래서 로그인 세션과 같이 잃어버려도 문제가 되지 않는 데이터를 저장하는데 사용한다.

- 대표적인 인메모리 데이터베이스로 Redis, Memcached 등이 있다.

- [관련 블로그](https://velog.io/@gwon7210/%EC%9D%B8%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%9E%80)


* * *

## Redis
- Redis는 대표적인 인메모리 데이터베이스로 가장 기본적이고 단순한 구조인 key-value 타입으로 데이터를 저장한다. 그래서 Redis는 NoSQL로 단순한 구조를 통해 높은 성능을 보장해준다.
- 하나의 쓰레드를 가지고 있다.(redis single thread) 그래서 자료구조 중에 하나인 Queue에 요청을 쌓아놓고 하나씩 거내서 실행한다.
- 또한, 데이터 저장소로 가장 입/출력 속도가 빠른 '메모리'를 채택했기에 빠른 속도를 보장한다.
- **이렇게 Redis와 같은 메모리 캐시 기반 서비스가 많이 사용되는 이유는, 캐시 방식을 통해 DB Read 부하를 감소시킬 수 있기 때문이다.**
  - 기존에는 데이터 조회 요청이 오면 -> DB에서 데이터를 직접 조회했다면,
  - **Redis를 사용하면 데이터 조회 요청이 왔을 때 -> Cache에서 해당 데이터를 조회하고 -> Cache에서 응답하게 된다.** 
    - Cache에 데이터가 없다면 DB 데이터를 조회한다. 그리고 이 때 조회한 데이터를 Cache에 저장하고 이후에는 Cache에서 바로 응답을 해준다.
    - 따라서 Redis는 급격하게 사용자가 집중되는 환경이나 대규모의 확장이 예정된 환경에 적합하다.


- **Cache(캐시)** : Cache란, **‘어떤 데이터 요청에 대해서 굳이 원본 소스를 탐색하지 않더라도 요청하는 자원에게 더 가까운 컴퓨팅 자원이 기억해두었다가 빠르게 데이터를 돌려주는 것’** 이라고 정의할 수 있다.
  - 따라서, Redis는 Cache중에서도 데이터베이스 Cache의 일종이라고 할 수 있다. 


- **Redis 예시**
  - Redis 메모리 데이터베이스를 이용하여 로그인 시 저장해야하는 세션을 RAM 메모리에 저장할 수 있다.
  - 웹 서비스의 고정된 게시판에 Redis를 이용해서 Cache를 적용할 수 있다. 고정된 게시판에 대한 요청이 왔을 때 -> Cache를 적용하면 직접적으로 DB로 HIT 하는 게 아니라 redis 서버의 Cache에서 꺼내주는 것이다. 일단 처음에는 Cache에 데이터가 없어서 페이지를 일단 DB로 랜더링을 하고, 그리고 나서 우리가 그 다음에 이 페이지에 다시 접근할 때는 속도가 조금 더 빨라진 것을 느낄 수 있다.
    - **ex) 캐시에 저장하는 코드는 cache.set(key, value, option) 이런식으로 되어있다. 그리고 저장된 캐시 데이터를 가져오는 건 cache.get(‘...') 이렇게 할 수 있다.**
    - DB보다 레디스 캐시를 이용하는 것이 빠르고 재활용성이 좋다.
    - **원티드 프리온보딩에서는, DB에 바로 저장하는 것이 아니라 외부 데이터를 요청해서 레디스 캐시에 cache.set(key, value, option) 명령어로 저장하는 방식으로 진행되었다.**

- **Redis 명령어**
```terminal
# 레디스 설치
brew install redis

# 레디스 서버 작동시키기
redis-server

# 터미널에서 레디스 접근하기
redis-cli

# 레디스에 저장된 키 - 밸류값 보기
keys *
```

- [관련 블로그](https://ojava.tistory.com/70)
- [관련 블로그 2](https://mangkyu.tistory.com/69)
- [관련 블로그 3](https://hyuntaeknote.tistory.com/7)
- [Redis를 활용한 데이터 캐싱](https://nachwon.github.io/redis/)
- [캐싱을 이용한 django 성능 최적화](https://velog.io/@heka1024/Django-Caching-1)


* * *

## AWS RDS란
- **아마존 웹 서비스(AWS)가 서비스하는 분산 관계형 데이터베이스를 의미한다.** 애플리케이션 내에서 관계형 데이터베이스의 설정, 운영, 스케일링을 단순케 하도록 설계된 클라우드 내에서 동작하는 웹 서비스이다. 까다로운 관계형 데이터베이스의 설치, 운영 그리고 관리를 지원해준다. 이러한 RDS는 EC2 인스턴스를 기반으로 운영하는 서비스이다.

- **EC2에 DB를 직접 설치하여 사용하는 것과 RDS를 사용하는 것의 차이**
  - EC2에 DB를 직접 설치하는 것은, 내가 직접 EC2 리눅스 위에 사용하려는 DB(oracle, MySQL, maria db, postgresql 등)를 설치하고 그위에 서비스하는 형태이다.
  - RDS를 사용하는 것은, EC2와 함께 사용하며 아마존에서 DB의 설정, 운영, 백업 등의 기능을 편하게 이용할 수 있게 해주는 EC2와 분리된 DB(데이터베이스) 전용서버이다. RDS를 사용하게 되면 => OS 및 데이터베이스의 설치 및 관리 그리고 업데이트를 따로 할 필요가 없어진다. 그리고 AWS 콘솔이나 AWS API를 통해 손쉽게 백업이나 복구(recovery)가 가능해진다.
    - 따라서 기업은 RDS를 사용해서 데이터베이스 도입 및 관리하는 데 있어서 시간과 노력을 줄일 수 있다.
    - 또한, 하나의 서버에 DB를 설치하는 게 아니라 또 다른 서버로 구분하는 것이기 때문에 서버의 부담 및 과부하를 줄여줄 수 있다는 장점이 있다.

* * *

## SQL과 NoSQL
- **NoSQL이란 : Not Only SQL 혹은 Not SQL의 의미이다. 그리고 NoSQL이 한가지 종류의 DB만을 의미하지는 않는다. 즉, 거대한 DB의 그룹들이라고 할 수 있다. 카테고리라고 보면 된다.**

- **SQL이란 : SQL이란(Strucured Query Language) 관계형 데이터베이스 관리 시스템의 데이터를 관리하기 위해 설계된 특수 목적의 프로그래밍 언어이며 관계형 데이터베이스 관리 시스템에서 자료의 검색과 관리, 데이터베이스 스키마 생성과 수정, 데이터베이스 객체 접근 조정 관리를 위해 고안되었다.**
  - **SQL 관련** : SQL DB 종류에는 대표적으로 MySQL, PostgreSQL, SQLite 등이 있다. 그리고 SQL DB는 relational하기 때문에 테이블이 존재하고 row와 column이 존재한다. 반면, NoSQL DB는 relational 하지 않다.

- **NoSQL의 3가지 카테고리**
  - (1) Document DB
  - (2) Key Value DB
  - (3) Graph DB


- **Document DB**
  - 해당 DB 종류의 가장 큰 예시는 mongoDB이다.
  - 데이터를 JSON document 형태로 저장한다. 
  - **보통의 SQL처럼 테이블이 있고 행과 열인 row와 column이 존재하는 것이 아니라 우리가 원하는 어떤 종류의 어떤 모양의 데이터든 저장할 수 있다.** 
  - 즉, SQL은 데이터의 구조가 엄격한 반면, mongoDB에서는 유연하다.

- **Key Value DB**
  - 대표적으로는 Cassandra DB와 Dynamo DB가 있다.
  - Cassandra DB는 column wide database 유형이다. 그리고 읽고 쓰기가 빠르다. 그래서 애플이 카산드라 DB를 이용해서 10페타바이트의 데이터를 저장하고 있다. 또한, 넷플릭스, 인스타그램, 우버도 사용한다. 이러한 회사들은 엄청 많은 데이터들을 빠르게 저장해야 한다.
  - Dynamo DB는 서버리스, 분산된 Key Value DB로서 아마존이 만들었다. 듀오링고가 해당 DB를 사용하는데 매초 24,000개의 읽기를 지원한다.
  - **즉, Key Value DB는 엄청 빠르게 데이터를 저장하고 읽어야 할 때 사용할 수 있다.**
  - 하지만, SQL처럼 쿼리를 사용할 수는 없게된다.

- **Graph DB**
  - 해당 DB는 column이나 document가 필요없을 때, 그러나 그래프의 각 노드 사이 관계를 알아야 할 때 사용할 수 있다.
  - 만약 우리가 페이스북 같은 서비스를 만든다면 필요한 DB이다.
  - 실제로 페이스북은 Tao라는 그들만의 DB를 만들었는데, 이 Tao가 바로 Graph DB이다. 
  - 여기서는 document나 column를 저장하는 것이 아니라, 각각의 entity를 저장하고 이를 관계망으로 연결한다. 예를 들어, 유저1이 사진1을 좋아요 누르고, 유저1과 유저2는 친구이고, 유저1이 사진1을 공유한다는 정보들은 document DB나 SQL보다 Graph DB에서 더 잘 저장될 수 있다.

- **대부분의 경우, SQL DB를 많이 사용하게 된다. 반면 특별한 경우나 특별한 이슈에 더 잘 대응하기에 좋은 것은 NoSQL DB이다.**

- [관련 블로그](https://khj93.tistory.com/entry/Database-RDBMS%EC%99%80-NOSQL-%EC%B0%A8%EC%9D%B4%EC%A0%90)


* * *

## JOIN이란
- 관계형 데이터베이스의 구조적 특징으로 정규화를 수행하면 의미 있는 데이터의 집합으로 테이블이 구성되고 각 테이블끼리는 관계(Relationship)을 갖게 되는데, 그래서 서로 관계있는 데이터가 여러 테이블로 나뉘어서 저장된다. 
- **이러한 상황에서 조인은, 여러 테이블의 레코드, 컬럼을 조합해서 하나의 새로운 테이블을 만들어내는 것을 의미한다.**

- **내부 조인(INNER JOIN)**
  - 내부 조인의 경우, 가장 대표적인 조인 방식으로 2개의 테이블의 컬럼 값을 결합해서 새로운 결과 테이블을 생성한다.

<img width="806" alt="image" src="https://user-images.githubusercontent.com/95380638/178094080-28d706df-d5cb-4b47-afb7-9c36f8f6bb4e.png">
- 위와 같이 테이블이 2개가 있다면,

<img width="811" alt="image" src="https://user-images.githubusercontent.com/95380638/178094090-ba39e5fe-842b-46f3-aea1-b61a9408bafb.png">
- 다음과 같이 내부 조인을 진행할 수 있다.


<br>

- **자연 조인(NATURAL JOIN)**
  - **자연 조인의 경우, 동등 조인의 한 유형으로 동일한 컬럼명을 가진 2개의 테이블이 있을 때, 동일한 컬럼명의 각 쌍에 대한 하나의 컬럼만 각각 포함해서 새로운 테이블을 만들어낸다.**

<img width="648" alt="image" src="https://user-images.githubusercontent.com/95380638/178094178-661d3825-ef75-4a6d-b988-16bab9b22b7f.png">
- 다음과 같이 Department ID라는 컬럼을 기준으로 2개의 테이블이 결합되어 하나의 테이블이 만들어졌다.

- [관련 블로그](https://velog.io/@ragnarok_code/DataBase-%EC%A1%B0%EC%9D%B8Join%EC%9D%B4%EB%9E%80)









