# Database

📖 **Contents**

- Database
  - [DB의 인덱스란](#db의-인덱스란)
  - [데이터베이스 인덱스 자료구조 B-Tree](#데이터베이스-인덱스-자료구조-b-tree)
  - [결제와 취소과정 트랜잭션](#결제와-취소과정-트랜잭션)
  - [웹에서 매핑이란](#웹에서-매핑이란)
  - [인메모리 데이터베이스](#인메모리-데이터베이스)
  - [Redis](#redis)
  - [AWS RDS란](#aws-rds란)
  - [SQL과 NoSQL](#sql과-nosql)
  - [JOIN이란](#join이란)

* * *


## DB의 인덱스란
- **인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.** 데이터베이스의 index는 책의 색인과 같다. 데이터베이스에서도 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 도와주는 것이 바로 인덱스이다.
  - 일반적으로 데이터베이스를 생성 후 데이터를 생성하면 PK가 존재할 때 기본적으로 인덱스가 잡히게 된다. PK가 아니라면 별도의 인덱스 설정이 필요하다.

- 인덱스를 활용하면 데이터를 조회하는 SELECT 외에도 UPDATE나 DELETE의 성능이 함께 향상된다. 그러한 이유는 해당 연산을 수행하려면 해당 대상을 조회해야만 작업을 할 수 있기 때문이다.
  - 만약 index를 사용하지 않은 컬럼을 조회해야 하는 상황이라면 전체를 탐색하는 Full Scan을 수행해야 한다. Full Scan은 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어진다.

- **인덱스의 장점과 단점**
  - 장점
    - 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
    - 전반적인 시스템의 부하를 줄일 수 있다.
  - 단점
    - 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다. 메모리에도 인덱스를 저장하겠지만, 디스크에도 별도의 저장 공간에 인덱스를 저장해두기 때문이다.
    - 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다. CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하된다.

* * *

## 데이터베이스 인덱스 자료구조 B-Tree
- **인덱스를 구현하기 위해서는 다양한 자료구조를 사용할 수 있다. 가장 대표적인 해시 테이블과 B+Tree가 있다.**
  - [관련 내용](https://mangkyu.tistory.com/96)

- **Django ORM 관련**
- 데이터베이스에서 쿼리가 처리될 때, 우리가 django ORM을 사용해서 데이터를 조회하면 데이터베이스에 맞는 쿼리가 생성되어 전송된다. 그리고 데이터베이스는 쿼리를 받으면 내부의 Optimizer가 실행계획을 계산해서 최적화된 탐색 방식으로 인덱스를 타도록 조회를 수행한다. 쿼리가 데이터베이스에 Hit 되고나서 Optimizer가 데이터베이스 내부에서 조회를 수행한다.
  - **Optimizer는 DBMS의 핵심 엔진이다.**
- 우리가 DB에서 사용하는 pk같은 경우, 우리가 먼저 Primary Key로 선언을 하는 것이기 때문에 그것도 사실 키이다. 그래서 얘네들은 자동으로 인덱싱이 된다. 그래서 보통은 우리가 인덱싱을 사용하지 않고도 빠르게 탐색하는 방법 중 하나는, 웬만하면 get이나 filter를 사용할 때 pk를 통해서 검색하는 것이 진짜 빠르게 검색이 된다.

- [관련 블로그](https://coding-factory.tistory.com/743)


* * *

## 결제와 취소과정 트랜잭션
- **일반적인 결제 과정**
  - 처음에 먼저 우리 DB에 고객이 입력한 주문 내역 정보들을 입력하기(결제정보 입력창으로부터 정보 받기)
  - 그 다음에 고객이 결제창을 띄워서 PG사한테 결제 요청 하기
  - 결제 수단 마다 인증 단계 진행하기(카드사 또는 은행 서버 등등)
  - 우리 서버에서 PG사쪽으로 결제 승인 API를 보내고 최종 결제 승인 여부 확인하기
  - 승인이 성공으로 끝나면 우리 서버 DB에 있는 예약 내역을 성공으로 업데이트 하기
  - 마지막으로 예약이 성공되었다는 화면 보여주기

- **일반적인 취소 과정**
  - 결제 취소 요청
  - PG사에 결제 취소 API 호출
  - 성공 응답이면 트랜잭션 시작
  - 모델 레코드 상태를 CANCELED로 변경하고 취소 시각을 입력
  - 구매 수량 원 상태로 복구
  - 마지막으로 트랜잭션 종료


- **트랜잭션**이란, 우리의 단계 뿐만이 아니라 외부의 단계를 포함해서 수행되는 시간이 서로 다르지만, 한 번에 묶음 처리 되어야 하는 처리 과정을 의미한다. 또한, 컴퓨터 사이언스 분야에서 트랜잭션은 **"쪼개질 수 없는 업무처리의 단위"** 를 의미한다.
  - 트랜잭션에서 하나라도 내부에 있는 작업이 실패하게 되면, (하나의 수정작업 update가 실패하면) 트랜젝션 상의 모든 업데이트가 취소된다. 즉, 모든 업데이트가 실패 이전 상태로 복구된다. 이것을 **"롤백"** 이라고 부른다.
  - 데이터베이스 작업이나 결제 및 송금 과정과 같이 **코드를 한 단위로 수행하는 것**을 의미한다.

- **TPS**
  - TPS란 Transaction Per Second의 약자로 1초 당 처리할 수 있는 트랜잭션의 개수를 의미한다.
  - ex) 실제로 API가 호출이 되서 응답이 될 때 그 하나의 단위를 트랜잭션이라고 본다면, 1초 당 API가 호출되는 카운트를 의미하기도 한다.
  - ex) TPS를 DB에 다시 대입해서 생각해보면, DB가 동시에 처리가능한 트랜잭션의 수가 될 수도 있다.

- **트랜잭션의 4가지 특성 - ACID**
  - 1. Atomicity(원자성) : 트랙잭션의 작업이 모두 수행되거나 혹은 모두 수행이 안되거나 이다. 하나의 트랜잭션 안에 여러가지 코드가 들어가 있고 여러가지 오퍼레이션이 수행되더라도 그 중 하나라도 실패한다면 아무것도 실행이 안되는 상태가 보장이 되어야 한다.
  - 2. Consistency(일관성) : 트랜잭션이 수행되는 순간에는 여러번 읽더라도 데이터베이스의 상태가 똑같해야 한다는 것이다. 예를 들어, 내가 트랜잭션을 시작했는데 거기있는 값이 일관성없이 이리저리 바뀌게 된다면 트랜잭션이 수행되는 동안에 내가 보고있는 데이터가 변질이 계속 되는 것이다. 그러면 일관성이 없다고 볼 수 있다.
  - 3. Isolation(독립성, 고립성) : 하나의 트랜잭션이 수행되고 데이터를 갱신하는 동안에는 이 트랜잭션이 완료되기 전에 갱신중인 데이터에 다른 트랜잭션이 접근하지 못하게 해야한다는 것이다. 내가 어떤 데이터를 막 수정하고 있는데 다른 애가 와서 덮어쓰고 내가 수정하려고 하면 내껄 날려버리고 이러면 안될 것이다.
  - 4. Durability(지속성) : 트랜잭션이 끝나고 나면 커밋이 마무리가 되고 그 갱신 사항이 이후에도 계속 유지되고 적용되어야 한다는 것이다. 

- [관련 블로그](https://han.gl/nxfTO)
- [결제 흐름 예시](https://han.gl/TAvUr)


* * *

## 웹에서 매핑이란
- https://threeidiotscoding.tistory.com/26


* * *

## 인메모리 데이터베이스
- **인메모리 데이터베이스란, 데이터를 디스크에 저장하는 데이터베이스가 아니라 메모리에 데이터를 저장하는 데이터베이스이다.** 메모리에 바로 데이터를 저장하기 때문에 디스크로부터 데이터를 가져오는 시간이 절약되어 디스크 접근보다 훨씬 빠른 데이터 작업이 가능하다.
- 하지만, **RAM에 데이터를 저장**하기 때문에 전원이 갑자기 꺼지게 된다면 모든 데이터가 사라져 영속성이 보장되지 못한다. 그래서 로그인 세션과 같이 잃어버려도 문제가 되지 않는 데이터를 저장하는데 사용한다.

- 대표적인 인메모리 데이터베이스로 Redis, Memcached 등이 있다.

- [관련 블로그](https://velog.io/@gwon7210/%EC%9D%B8%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%9E%80)


* * *

## Redis
- Redis는 대표적인 인메모리 데이터베이스로 가장 기본적이고 단순한 구조인 key-value 타입으로 데이터를 저장한다. 그래서 Redis는 NoSQL로 단순한 구조를 통해 높은 성능을 보장해준다.
- 또한, 데이터 저장소로 가장 입/출력 속도가 빠른 '메모리'를 채택했기에 빠른 속도를 보장한다.
- **이렇게 Redis와 같은 메모리 캐시 기반 서비스가 많이 사용되는 이유는, 캐시 방식을 통해 DB Read 부하를 감소시킬 수 있기 때문이다.**
  - 기존에는 데이터 조회 요청이 오면 -> DB에서 데이터를 직접 조회했다면,
  - **Redis를 사용하면 데이터 조회 요청이 왔을 때 -> Cache에서 해당 데이터를 조회하고 -> Cache에서 응답하게 된다.** 
    - Cache에 데이터가 없다면 DB 데이터를 조회한다. 그리고 이 때 조회한 데이터를 Cache에 저장하고 이후에는 Cache에서 바로 응답을 해준다.
    - 따라서 Redis는 급격하게 사용자가 집중되는 환경이나 대규모의 확장이 예정된 환경에 적합하다.


- **Cache(캐시)** : Cache란, **‘어떤 데이터 요청에 대해서 굳이 원본 소스를 탐색하지 않더라도 요청하는 자원에게 더 가까운 컴퓨팅 자원이 기억해두었다가 빠르게 데이터를 돌려주는 것’** 이라고 정의할 수 있다.
  - 따라서, Redis는 Cache중에서도 데이터베이스 Cache의 일종이라고 할 수 있다. 


- **Redis 예시**
  - Redis 메모리 데이터베이스를 이용하여 로그인 시 저장해야하는 세션을 RAM 메모리에 저장할 수 있다.
  - 웹 서비스의 고정된 게시판에 Redis를 이용해서 Cache를 적용할 수 있다. 고정된 게시판에 대한 요청이 왔을 때 -> Cache를 적용하면 직접적으로 DB로 HIT 하는 게 아니라 redis 서버의 Cache에서 꺼내주는 것이다. 일단 처음에는 Cache에 데이터가 없어서 페이지를 일단 DB로 랜더링을 하고, 그리고 나서 우리가 그 다음에 이 페이지에 다시 접근할 때는 속도가 조금 더 빨라진 것을 느낄 수 있다.
    - **ex) 캐시에 저장하는 코드는 cache.set(key, value, option) 이런식으로 되어있다. 그리고 저장된 캐시 데이터를 가져오는 건 cached.get(‘...') 이렇게 할 수 있다.**
    - DB보다 레디스 캐시를 이용하는 것이 빠르고 재활용성이 좋다.
    - **원티드 프리온보딩에서는, DB에 바로 저장하는 것이 아니라 외부 데이터를 요청해서 레디스 캐시에 cache.set(key, value, option) 명령어로 저장하는 방식으로 진행되었다.**


- [관련 블로그](https://ojava.tistory.com/70)
- [관련 블로그 2](https://mangkyu.tistory.com/69)
- [관련 블로그 3](https://hyuntaeknote.tistory.com/7)


* * *

## AWS RDS란
- **아마존 웹 서비스(AWS)가 서비스하는 분산 관계형 데이터베이스를 의미한다.** 애플리케이션 내에서 관계형 데이터베이스의 설정, 운영, 스케일링을 단순케 하도록 설계된 클라우드 내에서 동작하는 웹 서비스이다. 까다로운 관계형 데이터베이스의 설치, 운영 그리고 관리를 지원해준다. 이러한 RDS는 EC2 인스턴스를 기반으로 운영하는 서비스이다.

- **EC2에 DB를 직접 설치하여 사용하는 것과 RDS를 사용하는 것의 차이**
  - EC2에 DB를 직접 설치하는 것은, 내가 직접 EC2 리눅스 위에 사용하려는 DB(oracle, MySQL, maria db, postgresql 등)를 설치하고 그위에 서비스하는 형태이다.
  - RDS를 사용하는 것은, EC2와 함께 사용하며 아마존에서 DB의 설정, 운영, 백업 등의 기능을 편하게 이용할 수 있게 해주는 EC2와 분리된 DB(데이터베이스) 전용서버이다. RDS를 사용하게 되면 => OS 및 데이터베이스의 설치 및 관리 그리고 업데이트를 따로 할 필요가 없어진다. 그리고 AWS 콘솔이나 AWS API를 통해 손쉽게 백업이나 복구(recovery)가 가능해진다.
    - 따라서 기업은 RDS를 사용해서 데이터베이스 도입 및 관리하는 데 있어서 시간과 노력을 줄일 수 있다.

* * *

## SQL과 NoSQL
- **NoSQL이란 : Not Only SQL 혹은 Not SQL의 의미이다. 그리고 NoSQL이 한가지 종류의 DB만을 의미하지는 않는다. 즉, 거대한 DB의 그룹들이라고 할 수 있다. 카테고리라고 보면 된다.**

- **SQL이란 : SQL이란(Strucured Query Language) 관계형 데이터베이스 관리 시스템의 데이터를 관리하기 위해 설계된 특수 목적의 프로그래밍 언어이며 관계형 데이터베이스 관리 시스템에서 자료의 검색과 관리, 데이터베이스 스키마 생성과 수정, 데이터베이스 객체 접근 조정 관리를 위해 고안되었다.**
  - **SQL 관련** : SQL DB 종류에는 대표적으로 MySQL, PostgreSQL, SQLite 등이 있다. 그리고 SQL DB는 relational하기 때문에 테이블이 존재하고 row와 column이 존재한다. 반면, NoSQL DB는 relational 하지 않다.

- **NoSQL의 3가지 카테고리**
  - (1) Document DB
  - (2) Key Value DB
  - (3) Graph DB


- **Document DB**
  - 해당 DB 종류의 가장 큰 예시는 mongoDB이다.
  - 데이터를 JSON document 형태로 저장한다. 
  - **보통의 SQL처럼 테이블이 있고 행과 열인 row와 column이 존재하는 것이 아니라 우리가 원하는 어떤 종류의 어떤 모양의 데이터든 저장할 수 있다.** 
  - 즉, SQL은 데이터의 구조가 엄격한 반면, mongoDB에서는 유연하다.

- **Key Value DB**
  - 대표적으로는 Cassandra DB와 Dynamo DB가 있다.
  - Cassandra DB는 column wide database 유형이다. 그리고 읽고 쓰기가 빠르다. 그래서 애플이 카산드라 DB를 이용해서 10페타바이트의 데이터를 저장하고 있다. 또한, 넷플릭스, 인스타그램, 우버도 사용한다. 이러한 회사들은 엄청 많은 데이터들을 빠르게 저장해야 한다.
  - Dynamo DB는 서버리스, 분산된 Key Value DB로서 아마존이 만들었다. 듀오링고가 해당 DB를 사용하는데 매초 24,000개의 읽기를 지원한다.
  - **즉, Key Value DB는 엄청 빠르게 데이터를 저장하고 읽어야 할 때 사용할 수 있다.**
  - 하지만, SQL처럼 쿼리를 사용할 수는 없게된다.

- **Graph DB**
  - 해당 DB는 column이나 document가 필요없을 때, 그러나 그래프의 각 노드 사이 관계를 알아야 할 때 사용할 수 있다.
  - 만약 우리가 페이스북 같은 서비스를 만든다면 필요한 DB이다.
  - 실제로 페이스북은 Tao라는 그들만의 DB를 만들었는데, 이 Tao가 바로 Graph DB이다. 
  - 여기서는 document나 column를 저장하는 것이 아니라, 각각의 entity를 저장하고 이를 관계망으로 연결한다. 예를 들어, 유저1이 사진1을 좋아요 누르고, 유저1과 유저2는 친구이고, 유저1이 사진1을 공유한다는 정보들은 document DB나 SQL보다 Graph DB에서 더 잘 저장될 수 있다.

- **대부분의 경우, SQL DB를 많이 사용하게 된다. 반면 특별한 경우나 특별한 이슈에 더 잘 대응하기에 좋은 것은 NoSQL DB이다.**

- [관련 블로그](https://khj93.tistory.com/entry/Database-RDBMS%EC%99%80-NOSQL-%EC%B0%A8%EC%9D%B4%EC%A0%90)


* * *

## JOIN이란
- 관계형 데이터베이스의 구조적 특징으로 정규화를 수행하면 의미 있는 데이터의 집합으로 테이블이 구성되고 각 테이블끼리는 관계(Relationship)을 갖게 되는데, 그래서 서로 관계있는 데이터가 여러 테이블로 나뉘어서 저장된다. 
- **이러한 상황에서 조인은, 여러 테이블의 레코드, 컬럼을 조합해서 하나의 새로운 테이블을 만들어내는 것을 의미한다.**

- **내부 조인(INNER JOIN)**
  - 내부 조인의 경우, 가장 대표적인 조인 방식으로 2개의 테이블의 컬럼 값을 결합해서 새로운 결과 테이블을 생성한다.

<img width="806" alt="image" src="https://user-images.githubusercontent.com/95380638/178094080-28d706df-d5cb-4b47-afb7-9c36f8f6bb4e.png">
- 위와 같이 테이블이 2개가 있다면,

<img width="811" alt="image" src="https://user-images.githubusercontent.com/95380638/178094090-ba39e5fe-842b-46f3-aea1-b61a9408bafb.png">
- 다음과 같이 내부 조인을 진행할 수 있다.


<br>

- **자연 조인(NATURAL JOIN)**
  - **자연 조인의 경우, 동등 조인의 한 유형으로 동일한 컬럼명을 가진 2개의 테이블이 있을 때, 동일한 컬럼명의 각 쌍에 대한 하나의 컬럼만 각각 포함해서 새로운 테이블을 만들어낸다.**

<img width="648" alt="image" src="https://user-images.githubusercontent.com/95380638/178094178-661d3825-ef75-4a6d-b988-16bab9b22b7f.png">
- 다음과 같이 Department ID라는 컬럼을 기준으로 2개의 테이블이 결합되어 하나의 테이블이 만들어졌다.

- [관련 블로그](https://velog.io/@ragnarok_code/DataBase-%EC%A1%B0%EC%9D%B8Join%EC%9D%B4%EB%9E%80)









