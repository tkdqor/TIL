# Data Structure
- 자료구조는 "데이터를 조직하는 방법"이라고 할 수 있다. 또는 "데이터를 표현하고 관리하고 처리하기 위한 구조"를 의미한다.

📖 **Contents**

- Data Structure
  - [Stack과 Queue의 차이](#stack과-queue의-차이)
  - [시간복잡도란](#시간복잡도란)
  - [Binary Tree의 시간 복잡도](#binary-tree의-시간-복잡도)
  - [자료구조 heap](#자료구조-heap)
  - [링크드 리스트란](#링크드-리스트란)
  - [어레이 리스트와 링크드 리스트의 차이](#어레이-리스트와-링크드-리스트의-차이)


* * *

## Stack과 Queue의 차이
- **Stack이란, 데이터를 차곡차곡 쌓아올린 형태의 자료구조이다. 데이터가 순서대로 쌓이다가 가장 마지막에 삽입된 자료가 가장 먼저 삭제되는 구조를 가지고 있다.**
  - Stack은 정해진 방향으로만 쌓을 수 있고, top으로 정한 곳을 통해서만 접근할 수 있다. 새로 삽입되는 자료는 top이 가리키는 가장 맨 위에 쌓이게 되고 자료를 삭제할 때도 top을 통해서 삭제가 가능.
  - **Stack에서 삽입 연산은 push / 삭제 연산은 pop이라고 한다. 후입선출의 구조로 LIFO(Last In First Out)이라고 부른다.**
  - ex) 웹 브라우저 방문 기록 뒤로가기, 실행 취소(undo), 역순 문자열 만들기, 후위 표기법 계산

- **큐(Queue)는 먼저 들어온 것이 먼저 나가는 선입선출로 FIFO(First In First Out)의 구조를 가지고 있다.**
  - FIFO 구조를 위해서 큐의 왼쪽 끝에는 삽입 작업이 / 오른쪽 끝에는 삭제 작업이 나뉘어서 이루어진다.
  - **삽입 연산이 이루어지는 곳을 리어(rear)라고 하고, 리어에서 이루어지는 삽입 연산을 인큐(Enqueue)라고 부른다.**
  - **삭제 연산이 이루어지는 곳을 프론트(front)라고 하고, 프론트에서 이루어지는 삭제 연산을 디큐(Dequeue)라고 부른다.**
  - ex) 은행 업무, 대기열 순서와 같은 우선순위의 작업 예약 등, 서비스 센터 대기시간, 프로세스 관리


* * *

## 시간복잡도란
- **시간 복잡도**란, 우리가 작성한 코드의 실행시간이 실행해보기 전에 정확하게 추측하는 것은 힘들겠지만 반복문을 몇 번 사용했는지, 입력값은 어떻게 되는지 등을 통해 대략적으로 추측할 수 있다. **즉, 입력값과 연산 수행 시간의 상관관계를 나타내는 척도를 시간 복잡도라고 한다.**

- **시간복잡도 예시**
  - 복잡한 곱하기와 같은 연산이 없고 넣으면 바로 결과값이 나오는 O(1)
  - for 루프 하나는 O(n)
  - for문안에 for문은 O(n^2)
  - O(n^2+n) 예시
```python
for i in range(1000000):
    for i in range(10000):
        pass
        
for i in range(100):
    ...
```

- **시간복잡도를 고려한다면, for문과 while문은 최대한 사용하지 않는 것이 좋다.**

* * *

## Binary Tree의 시간 복잡도
- Binary Tree의 시간 복잡도는 **O(log_2(N))** 이다.
  - 해설 : https://neos518.tistory.com/145
  - 이진 트리 설명 : https://ratsgo.github.io/data%20structure&algorithm/2017/10/21/tree/


* * *

## 자료구조 heap
- **힙(heap)은 무언가를 차곡차곡 쌓아 올린 더미라는 뜻으로, 완전이진트리의 형태로 만들어진 자료구조이다. 즉, 위로 갈수록 노드의 수가 줄어드는 모습이다. 힙은 최댓값 혹은 최솟값을 빠르게 찾아내기에 유리한 자료구조이다.**
  - **이진트리**는 각 노드가 최대 2개의 자식을 갖는 트리를 뜻한다. 즉, 각 노드는 자식이 없거나 한개이거나 두개만을 갖게 된다.
  - 그리고 **완전이진트리**는 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있는 트리 자료구조이다. 또한, 마지막 레벨은 꽉 차 있지 않아도 되지만, 노드가 왼쪽에서 오른쪽으로 채워져야 한다.

- **힙을 만드는 과정**
  - 값 삽입 - 힙 구조로 변경 - 값 삽입 - 힙 구조로 변경
  - 이 과정에서 힙은 항상 부모 노드가 자식 노드보다 커야 한다는 조건이 지켜져야 한다. 그래서 매번 값이 들어올 때마다 값을 비교하고 swap을 해줘야 한다. 자식 노드들 끼리는 값을 비교하지 않는다.
  - 힙 구조가 완성되면 완전 이진트리이면서 부모 노드가 자식 노드보다 큰 트리 구조이다. 이러한 과정을 통해 최댓값을 빠르게 찾을 수 있는 구조가 바로 힙이다.
  - 힙 구조는 최댓값 혹은 최솟값을 빨리 찾기 위한 구조이지 이걸 사용했다고 정렬이 되지는 않는다.

- [관련 블로그](https://todaycode.tistory.com/56)

* * *

## 링크드 리스트란
- 링크드 리스트란, 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료 구조이다. 데이터를 담고 있는 노드들이 연결되어 있는데, 노드의 포인터가 다음이나 이전의 노드와의 연결을 담당하게 된다.
- [python으로 링크드 리스트 구현하기](https://velog.io/@woga1999/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9C%BC%EB%A1%9C-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EB%A7%81%ED%81%AC%EB%93%9C-%EB%A6%AC%EC%8A%A4%ED%8A%B8)
  - 링크드 리스트를 python으로 구현하면, 헤더부터 탐색해서 뒤에 노드가 추가된다. 그래서 조회를 하면 제일 첫번째 값만 나오게 된다.
  - 하나의 노드를 클래스로 구현하면 self.data = data로 데이터가 있고, self.next = None라는 코드로 다음 데이터를 연결하기 위해 작성한다.

* * *

## 어레이 리스트와 링크드 리스트의 차이
<img width="622" alt="image" src="https://user-images.githubusercontent.com/95380638/192268712-1ef816ac-2017-4699-9fa7-ce75c3001b23.png">

- 위의 내용과 같이, ArrayList는 index가 있고, LinkedList는 각 원소마다 앞,뒤 원소의 위치값을 가지고 있다. 이러한 특징으로 조회, 삽입, 삭제 시 아래와 같은 시간복잡도 차이를 가진다.

<img width="402" alt="image" src="https://user-images.githubusercontent.com/95380638/192269112-3d36c4fb-2f69-47d3-9d09-5d3a2b73f2ce.png">

- **ArrayList**
  - ArrayList는 기본적으로 배열을 사용한다. 하지만 일반 배열과 차이점이 존재한다. 
  - 일반 배열은 처음에 메모리를 할당할 때 크기를 지정해주어야 하지만, ArrayList는 크기를 지정하지 않고 동적으로 값을 삽입하고 삭제할 수 있다.
  - ArrayList는 각 데이터의 index를 가지고 있고 무작위 접근이 가능하기 때문에, 해당 index의 데이터를 한번에 가져올 수 있다.
  - 데이터의 삽입과 삭제시 ArrayList는 그만큼 위치를 맞춰주어야 한다. 위의 사진으로 예를 들면 5개의 데이터가 있을 때 맨 앞의 2를 삭제했다면 나머지 뒤의 4개를 앞으로 한칸씩 이동해야 한다. 삽입과 삭제가 많다면 ArrayList는 비효율적이다.

- **LinkedList**
  - LinkedList는 내부적으로 양방향의 연결 리스트로 구성되어 있어 참조하려는 원소에 따라 처음부터 정방향 또는 역순으로 순회가 가능하다.
  - LinkedList는 순차적 접근이기 때문에 검색의 속도가 느리다.
  - LinkedList는 데이터를 추가·삭제시 가리키고 있는 주소값만 변경해주면 되기 때문에 ArrayList에 비해 상당히 효율적이다. 위의 사진으로 예를들면 2번째 값을 삭제하면 1번째 노드가 3번째 노드를 가리키게 하기만 하면 된다.

- **즉, 조회시에는 ArrayList가 우위에 있지만, 삽입/삭제 시에는 LinkedList가 뛰어난 성능을 보여준다.**
  - 더 자세하게는, 순차적으로 추가/삭제하는 경우에는 ArrayList가 LinkedList보다 빠르지만 중간 데이터(비 순차적)를 추가/삭제하는 경우 LinkedList가 ArrayList보다 빠르다.

- [참고 블로그](https://dev-coco.tistory.com/19)
