# Network

📖 **Contents**

- Network
  - [API란](#api란)
  - [API서버](#api서버)
  - [Web이란](#web이란)
  - [웹사이트에서 url을 입력할 때](#웹사이트에서-url을-입력할-때)
  - [DNS 그리고 DNS 서버란](#dns-그리고-dns-서버란)
  - [AWS Route53이란](#aws-route53이란)
  - [HTTPS와 HTTP](#https와-http)
  - [쿠키와 세션](#쿠키와-세션)
  - [클라이언트 요청부터 서버 응답 과정](#클라이언트-요청부터-서버-응답-과정)
  - [Web 서버 동작 과정](#web-서버-동작-과정)
  - [Celery 관련 내용](#celery-관련-내용)
  - [wsgi란](#wsgi란)
  - [Nginx와 Gunicorn 둘 중 하나만 사용해도 될까](#nginx와-gunicorn-둘-중-하나만-사용해도-될까)
  - [인바운드와 아웃바운드 규칙](#인바운드와-아웃바운드-규칙)
  - [SSH란](#ssh란)
  - [IPv4와 IPv6](#ipv4와-ipv6)
  - [TCP란](#tcp란)


* * *

## API란
- **Application Programming Interface의 약자로, 데이터를 주고받을 때 사용하는 하나의 인터페이스, 우리가 만든 기능과 함수를 다른 사람들도 사용할 수 있게 해주는 인터페이스이다.** front-end가 back-end에 요청을 할 때, 즉 클라이언트가 서버에게 요청할 때 특정 규칙에 맞게 요청해야 하는데 이러한 사용 규칙을 제공하는 것을 API라고 한다. 웹 서버 따로 API 서버를 따로 구축할 수 있다.
- **옛날에는 template 파일을 랜더링하는 개발이었지만, 요즘에는 API 개발이 중심**
  - 랜더링 방식에서 JSON 형태의 응답으로 바뀐 이유는, 다양한 처리가 가능하기 때문. 데이터만 보내면 효율적이고 웹이나 앱, OPEN api 등 다양하게 활용될 수 있다.

- **REST API**
  - REST는 Representational State Transfer의 약자로, 응용프로그램(클라이언트)들이 시스템에 있는 자원(데이터)을 쉽게 사용하기 위해 시스템이 각 자원에 이름을 붙여 정리해놓은 것이라고 볼 수 있다. 
  - **RESTful한 API가 되려면, Request에는 URL, Method가 있어야 하고 / Response에는 Data type, Status code가 있어야 한다.**

```python
POST, GET         /users
GET, PUT, DELETE  /users/1
```

* * *

- **url에는 보통 동사가 포함되지 않지만, 어떤 행위를 했을 때는 허용이 되는 경우가 있다. ex) 유저가 회원가입 또는 회원탈퇴 등**

- **PUT, DELETE 라고 생각되는 url이 POST, GET인 경우?**
  - 실제로는 직접적인 DELETE를 잘 하지 않는다. 상태를 변경하지 데이터를 삭제하지는 않는다. 또는 "회원탈퇴" 라는 모델이 따로 있다면, 오히려 POST로 해당 모델의 자원을 생성하게 되는 것이라 볼 수 있다. 즉, 내부 로직에 따라 다르게 된다.

- **/company/1/mem-bers 이러한 url 케이스와 / ?name=AAA__AA  이러한 파라미터 케이스**
  - 파라미터는 DB 필드명과 비슷하게 설정
  - url에는 - 그냥 바를 사용하고 파라미터는 _ 언더바를 사용

- **파라미터는 옵셔널하다, 즉 파라미터가 없어도 되는 경우에 파라미터를 사용한다.**
  - id가 꼭 필요한 경우에는 url에 id/로 추가
  - id가 꼭 필요하지 않는 경우에는 url에 ?id=1 이렇게 파라미터로 추가

- **Response의 예시**
  - Response(data=data, status=200)
  - 대부분 JSON형태로 응답 

- **URL 유형**
  - https://.../api/users/1    => 이건 우리 API 서버라고 명확하게 해주는 것
  - https://.../users/1        => 이렇게 하면 일반 사용자가 들어가는 페이지 url를 의미
  - https://.../api/v1/users/1 => API 서버의 version 1를 의미
  - https://.../api/open/v1/.. => Open API 서버를 의미

- **아예 물리적으로 레포지토리로 2개로 구분하여 웹 서버와 API 서버를 구분할 수도 있다.**
  - 그런데 그렇게되면 관리해야 되는게 2개로 늘어나게 된다.
  - 그래서 보통은 규모가 크지 않는 이상 하나의 서버에서 웹도 제공하고 API도 제공한다.

- **노션에 글을 작성하는 순간, 진행되는 과정(혹은 url 주소를 입력했을 때 진행되는 과정)**
  - 우리가 노션에 글을 작성하는 순간, 0.3초 이후에 바로 POST 요청을 날리는 것을 개발자 도구로 확인할 수 있다. 그 다음, 먼저 KT 와이파이로 전송되고 -> 가까운 기지국으로 이동 -> 중앙 기지국 이동 -> 국가 센터 -> 세계 해저 전선 터널 따라서 -> 라스베이거스 기지국 -> 노션 서버로 도착해서 응답 -> 브라우저에 실제로 글이 작성된다.
  - **이러한 과정에서 HTTP 규약으로 보내게 되면 중간 중간에 누군가가 열어볼 수 있게 된다. 하지만, HTTPS 규약으로 보내게 되면 나랑 노션 서버말고는 못보게 암호화하여 서로 암호화한 키를 둘만 가지고 있게 된다.**


### open API
- 누군가가 back-end를 만들어놓고 여기에 주소와 사용 규칙을 공개한 것을 의미. 
- 그래서 우리는 이 back-end의 사용규칙과 주소만 알면, front-end만 만들어도 얼마든지 요청하고 데이터를 가져와서 사용할 수 있다. 우리가 규칙에 맞게 전송하기만 하면, 지도 / 결제 / 채팅 등 다양한 기능들을 사용할 수 있다.
  - ex) 우리가 카카오 책 검색 open API 서버 주소로 어떤 책에 대한 정보를 요청하면 -> API 서버에서는 자체 DB를 뒤져서 우리가 원하는 정보를 다시 전달해준다.
- 이러한 요청과 응답은 정해진 API 형식에 맞춰서 전달해야 한다. 이러한 형식이 작성된 문서를 **API 가이드**라고 한다. 요즘에는 거의 모든 API에서 JSON형태로 정보가 전달된다.

### open API를 통해 받은 JSON
- open API를 통해 받은 JSON 데이터를 실제 HTML 파일에 출력하려면 -> JSON 데이터를 JavaScript로 접근해야 한다.
- 해당 JSON 데이터를 JavaScript로 console에 표시할 수 있다.
  - 그리고나서, Jquery를 이용해 -> html의 특정 element에 어떤 요소를 넣어줄 수 있다.
  - <script></script> 이렇게 JavaScript 코드 사이에 HTML 특정 element를 설정하고 해당 데이터를 보여줄 수 있다.

- [참고 자료](https://enjoyinjoanne.tistory.com/56)


* * *

## API서버
- 웹브라우저라는 클라이언트가 있고 - django라는 서버가 있을 때, 일반적으로 브라우저에서 어떠한 버튼을 클릭한다고 하면 브라우저에서 /posts/create/와 같이 요청을 하게 된다. => 그러면 django 서버에서는 html template를 만들어서 html 응답을 해주게 된다.
- **이렇게 일반적인 요청 - 응답이 아닌, API 서버에서의 요청 - 응답 통신은 다른 의미가 된다.**
  - API 서버에서는 브라우저에서 /posts/create/와 같이 요청을 하는 것은 **"비동기식 요청"** 을 위해서이다.
  - 일반적인 요청을 동기식 요청이라고 한다면, **비동기식 요청은 버튼을 클릭했을 때 전체 페이지를 요청하고 로딩하는 것이 아니라, 일부분만 다시 그리기 위해 html 화면이 다 그려진 상태에서 일부분만 요청하는 것을 의미한다.**
  - 이러한 비동기식 요청을 하기 위해서는 브라우저에서 특별하게 ajax 요청을 해야 한다. 즉, ajax 통신을 해야 한다.
  - **그리고 이렇게 ajax 요청에 대해서는 JSON 형태의 데이터로 응답을 해줘야 한다. django에서는 딕셔너리의 형태로 데이터를 보내줘야 하는 것이다. 즉, html 파일인 template을 응답하는 게 아니라, JSON 형태로 데이터를 응답해줘야 한다.**
  - 이렇게 응답해주면, Ajax 모듈이 해당 응답을 받아서 key / value 데이터를 뽑아서 화면에 뿌려줄 수 있는 것이다.
  - **이 때, django에서는 DRF(Django REST Framework) 라이브러리가 있어야 이러한 요청을 받아서 JSON 형태의 데이터를 응답해줄 수 있다. DRF가 없는 django에서는 template만 응답으로 줄 수 밖에 없다. 그래서 django에서는 API 서버를 구축하기 위해 DRF를 사용하는 것이다.**

- 관련 개념으로는, 뷰나 리액트의 싱글페이지 어플리케이션이라는 개념이 있다.


* * *

## Web이란

- 정확한 의미의 '인터넷'은 수많은 컴퓨터들이 연결되어서 데이터를 주고받을 수 있는 네트워크, 공간을 의미
- 우리가 편하게 사용하고 있는 무선 인터넷이나 WiFi와 같은 것들도 궁극적으로는 유선으로 연결되어 있음 
- 그래서 수없이 많은 컴퓨터가 네트워크로 연결되어 있고, 그 네트워크 안에 또다른 네트워크가 존재하기 때문에 우리는 이것을 '인터넷'이라고 부른다.
- 우리가 인터넷을 사용한다는 것은, 우리가 이 네트워크에 컴퓨터로 접속해서 각종 텍스트나 이미지, 동영상 등의 데이터를 서로 주고 받는 것을 의미. 그것을 하나의 페이지로 주고받는 경우를 '웹 페이지'라고 볼 수 있다.

- 이 인터넷 내에서 데이터를 주고받는 방법 중 하나가 바로 '웹 서비스' 이다. 따라서 엄밀히 말하면 인터넷과 웹은 같은 의미로 볼 수 없다.
- 인터넷을 활용한 서비스 종류에는 웹 이외에도 파일 전송을 위한 FTP 서비스, 메일 서비스 등이 있다.

### 웹 서비스에서 컴퓨터 간 데이터를 주고받는 방법

- 데이터를 요청하는 쪽을 Client, 그 요청에 응답하는 쪽을 Server라고 한다.
- client가 server에게 얻고자 하는 데이터를 요청하면 -> server는 그러한 데이터를 찾아서 전달해주는 역할.
- 주로 client에서 웹 브라우저를 통해서 데이터를 request하게 되고, 그 request에 대해서 server가 HTML 파일 웹페이지를 response로 전달.
- 이 때, server에 데이터를 요청하려면 IP Address(Internet Protocol Address)가 필요 -> 컴퓨터가 네트워크에 접속했을 때 반드시 부여받게 되는 하나의 주소체계를 의미.
  - IP Address는 총 4개의 섹션으로 구분되어 있고, 각 섹션은 0~255 범위의 10진수 숫자로 표현됨 ex) 125.209.222.142
- 다만, 이러한 IP 주소를 모두 외울 수는 없으니, client가 텍스트로 이루어진 주소로 요청하게 되면 -> 그에 맞는 IP Address로 변환해서 서버를 찾을 수 있게끔 해주는 것.
  - 이렇게 IP Address를 기억하기 쉽게끔 이름을 부여한 것을 우리는 "Domain" 이라고 한다.
  - 그리고 이 Damain과 IP Address를 양방향으로 변환할 수 있게끔 해주는 것이 바로 **Domain Name System, 줄여서 DNS**라고 한다.

### HTTP

- 웹 서비스에서 데이터를 주고받을 때 반드시 지켜야 할 통신 규약
- HTTP는 Hyper Text Transfer Protocol의 약자로 Hyper Text가 웹사이트에서 볼 수 있는 링크, 하이퍼 링크를 의미. 그리고 Protocol은 규칙, 규약에 해당.
- 웹 서비스 등 해당 서비스에 맞게 정확한 프로토콜을 따라야 데이터를 원하는대로 주고받을 수 있다.
- 우리는 앞으로 웹 페이지를 만드는 방법에 대해서 배울 것이고, 이러한 웹 페이지(HTML파일)를 주고받으려면 HTTP에 대해서 알아야 한다.
> - [HTTP 관련 MDN 내용](https://developer.mozilla.org/ko/docs/Web/HTTP/Overview)


* * *

## 웹사이트에서 url을 입력할 때
- 브라우저에서 url를 입력하거나, 어떤 버튼을 눌러 정보를 요청할 때, 구글을 예를 들면, 자바스크립트가 구글 서버에게 요청을 보내게 된다. 
- **GET 메소드로 url과 파라미터를 보내준다. 또한, 크롬 등 브라우저가 해당 서버에게 정보들을 보내준다. 접속한 사람의 언어, 접속한 디바이스(삼성, 애플..) 등 이러한 정보들을 "headers" : {....} 이렇게 담겨서 보내준다. 해당 브라우저가 어떤 버전인지도 나온다.**

- **만약 인증방식이 토큰이라면 -> 토큰도 headers에 담겨져 있다. ex) headers[‘Auth’] = token 이렇게 담긴다.**
  - **토큰을 유저한테만 발급하는 게 아니라, 기기별로 발급한다.**
  - 모든 기기는 고유번호가 있어서 넷플릭스나 유튜브는 기기를 맥 2대 이상 접근하면 딴 곳에서 사용중이라고 나온다. 디바이스 마다 각자 토큰을 발급해놓게 되는 것이다.
  - ex) 유튜브는 10초마다 API가 요청된다. 스트리밍은 다음 1분 30초 보고 다음 1분 30초 보고 이렇게 되고 로딩 바가 처음부터 채워지지 않는다. 그래서 활성화된 API를 찾을 수 있고 같은 계정이지만 다른 기기가 있다면 이 사람이 몇 개의 디바이스가 있는지 알 수 있다.



* * *

## DNS 그리고 DNS 서버란
- **IP주소와 도메인명을 서로 교환해주는 장치를 DNS(Domain Name System)라고 한다.**
- **DNS는 일반적으로 도메인을 IP로 전환하여 IP 네트워크에 통신해서 목적지 IP를 찾아가는 과정을 의미한다. 즉, 도메인과 대응된 IP 주소를 알려준다.**

![image](https://user-images.githubusercontent.com/95380638/175050768-a9c285d0-ab52-4ec8-92a8-95cd4622b547.png)

- 일반적인 DNS의 작동방식은 위와 같다. 출처는 [다음](https://gentlysallim.com/dns%EB%9E%80-%EB%AD%90%EA%B3%A0-%EB%84%A4%EC%9E%84%EC%84%9C%EB%B2%84%EB%9E%80-%EB%AD%94%EC%A7%80-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC/)과 같다.

- **웹사이트의 데이터가 저장되어 있는 호스팅 서버는 인터넷 회선이 연결된 컴퓨터/장치이고 IP 주소가 할당되어 있다.** 그래서 이 주소가 실제 웹사이트 주소라고 할 수 있다.(ex. AWS의 EC2 서버)
  - **DNS 서버(즉, 네임서버)는 이러한 IP 주소를 특정 도메인 주소와 같다는 기록을 저장해두고 인터넷 사용자들이 도메인 주소를 검색했을 때 => IP 주소로 연결되도록 해주는 것이다.**

<br>

- **DNS 서버의 기본적인 IP 연결 과정**
  - ex) 한 사용자가 브라우저에서 naver.com를 검색했다면, 먼저 DNS 서버로 도메인 주소가 전달이 된다. 그리고 DNS 서버 내부에서 도메인 주소를 토대로 "naver.com = 12.123.123.123" 이라는 항목을 찾아내고 다시 브라우저에게 12.123.123.123의 IP 주소를 갖고 있는 호스팅 서버(해당 웹사이트 데이터가 저장된곳)로 가라고 지시하는 것이다. 그러면 브라우저가 다시 해당 IP 주소로 접속해서 웹사이트가 보이게 된다.

<br>

- **DNS 서버 종류 구분**
  - **DNS 서버가 초고성능으로 세상에 단 하나만 있다면 위 내용 그대로 이해하면 되겠지만, 그렇게 간단하지않다. 세상에 도메인 수가 엄청 많기 때문에 DNS 서버 종류를 계층화해서 단계적으로 처리하게 된다.**
  - 도메인의 총 관리는 ICANN에서 하기 때문에, DNS 서버도 최상위 도메인에서 개인 도메인의 서브 도메인까지 도메인 이름의 분류와 마찬가지로 디렉토리/계층 형태로 구분된다. 여기서 ICANN은 모든 인터넷 도메인과 DNS 서비스를 관리하는 기구이며, 일반적으로 ICANN - 레지스트리(Registry) - 레지스트라(Registrar) - 레지스트란트(Registrant)의 구조, 계층 형태를 가지게 된다.
  - **Root DNS Server** : ICANN이 직접 관리하는 서버로, TLD DNS 서버 IP들을 저장해두고 안내하는 역할을 한다.
  - **TLD(최상위 도메인) DNS Server** : 도메인 등록 기관(Registry)이 관리하는 서버로, Authoritative DNS 서버 주소를 저장해두고 안내하는 역할을 한다. 어떤 도메인 묶음이 어떤 Authoritative DNS Server에 속하는지 아는 이유는 도메인 판매 업체(Registrar)의 DNS 설정이 변경되면 도메인 등록 기관(Registry)으로 전달이 되기 때문이다.
    - 도메인 등록 기관 : .com / .net / .kr 등
  - **Authoritative DNS Server** : 실제 개인 도메인과 IP 주소의 관계가 기록/저장/변경되는 서버이다. 그래서 권한의 의미인 Authoritative가 붙는 것이다. 일반적으로 도메인/호스팅 업체의 ‘네임서버’를 말하지만, 개인 DNS 서버 구축을 한 경우에도 여기에 해당한다.
  - **Recursive DNS Server** : 인터넷 사용자가 가장 먼저 접근하는 DNS 서버이다. 위 3개의 DNS 서버를 매번 거친다면 효율이 좋지 않기 때문에, 한 번 거친 후 얻은 데이터를 일정 기간(TTL/Time to Live) 동안 캐시라는 형태로 저장해 두는 서버이다. 직접 도메인과 IP 주소의 관계를 기록/저장/변경하지는 않고 캐시만을 보관하기 때문에, Authoritative와 비교되는 의미로 반복의 Recursive가 붙는다. 대표적인게 KT/LG/SK와 같은 ISP(통신사) DNS 서버가 있고, 브라우저 우회 용도로 많이 쓰는 구글 DNS, 클라우드플레어와 같은 Public DNS 서버가 있다.
  - **기본적으로 브라우저는 캐시가 저장된 Recursive 서버를 사용하고, 실제 네임서버를 설정하는 곳은 Authoritative 서버라는 점만 주의해서 이해하자. 나머지 두 서버는 컨트롤할 수 있는 영역도 아니고 언급되는 경우도 적으니 전반적인 이해를 위해서만 알고 있자.**

<br>

- **DNS 서버의 자세한 IP 연결 과정**
  - ex) 브라우저에서 naver.com을 검색하고 사용하고 있는 통신사인 KT DNS 서버에게 도메인 주소에 해당하는 IP 주소를 요청(브라우저 기본 DNS 설정이 통신사 DNS 서버이기 때문)
  - ISP 서버에선 캐시 데이터가 없다는 걸 확인하고 루트 DNS 서버에게 어디로 가야 하는지 요청(캐시가 있다면 바로 Authoritative 서버에게 요청)
  - 루트 서버는 TLD DNS 서버 주소만 관리하기 때문에, xxx.com 도메인을 보고는 COM 최상위 도메인을 관리하는 TLD DNS 서버 주소를 안내
  - ISP 서버는 COM 서버에게 어디로 가야 하는지 다시 요청
  - COM 서버는 가비아 DNS 서버에서 해당 도메인이 관리되고 있는 걸 확인하고 안내
  - ISP 서버는 가비아 서버에게 또 다시 요청
  - 가비아 서버는 “naver.com = 12.123.123.123”이라는 정보를 확인하고 이 IP를 알려준다. 동시에 ISP 서버는 해당 정보를 캐시로 기록
  - ISP 서버는 브라우저에게 12.123.123.123라는 IP 주소를 안내
  - 브라우저는 12.123.123.123라는 IP 주소를 갖고 있는 호스팅 서버에게 웹사이트를 출력하라고 요청
  - 이제 마지막으로 우리가 보는 웹사이트 화면이 출력


- [참고 자료](https://goodgid.github.io/Server-DNS/)

* * *

## AWS Route53이란
- Route53이란, AWS에서 제공하는 DNS이다. 
- **Route53에서는, AWS Route53에서 확인할 수 있는 NS(Name Server)레코더 정보를 확인하고 해당 정보를 => 도메인 등록 대행기관(ex. 가비아)에 네임서버 정보로 입력하게 된다. 즉, Authoritative DNS 서버의 역할을 AWS Route53이 대신 해주는 의미가 된다.**
  - 그러면 이후에 도메인과 관련된 모든 작업을 AWS 내부에서만 수행할 수 있게 된다.

- **Route 53의 특징**
  - Public Host zone과 Private Host zone이 존재한다. Public Host zone은 일반 네임서버로 글로벌하게 동작하고, Private Host zone은 AWS내에서만 동작한다.
  - 도메인 자체에 ALIAS(별칭)를 줄 수 있다.
  - 특정 포트에 대한 모니터링이 가능하다.

- **Route 53 타입 종류**
  - **NS 타입** : 네임서버 타입으로 4개의 네임서버를 확인할 수 있다. 이렇게 네임서버가 4개나 있는 이유는 네임서버가 죽으면 우리의 서비스를 들어갈 수 없고, 서비스가 죽는것과 마찬가지이기 때문에 4개를 AWS에서 지정해준다. 이 네임서버를 통해 사용자가 요청을 했을 때 ip 정보를 반환해주게 된다.
  - **SOA 타입** : SOA 레코드는 필수 레코드이다. SOA레코드는 도메인 영역을 표시하는 역할을 하며 네임서버에게 어떤 기준에 의해 이 도메인을 관리하여야 하는지 알려주는 역할을 하게된다. SOA타입은 AWS에서 자동으로 생성한다.
  - **A 타입** : A 타입은 Address의 약자이다. domain name에 하나의 IP Address가 있음을 의미한다. 즉, 하나의 도메인에 해당하는 IP 주소의 값을 가지고 있다. A 타입 생성 시, Value에는 우리의 도메인의 ip를 입력하고, 유형은 IPv4로 선택하면 된다.
  - **TTL(Time To Leave)** : 타입별로 설정할 수 있는 요소로 캐시가 살아있는 시간을 의미한다. 연산이나 복잡한 절차를 저장해두었다가 다음에 다시 요청이 올때 이 저장된 결과값을 가지고오면 훨씬 더 빠르게 가지고 올 수 있다. DNS를 입력했을때 그 결과 ip를 어딘가에 저장해두었다가 바로 그 ip를 반환해주게 된다. 

- [참고자료](https://insight-bgh.tistory.com/261)

* * *

## HTTPS와 HTTP
- **HTTP**는 Hyper Text Transfer Protocol의 약자로 서버와 클라이언트간에 데이터를 주고 받는 프로토콜을 의미한다. **80번 포트**를 사용하고 있으며 텍스트, 이미지,영상, JSON 등등 거의 모든 형태의 데이터를 전송할 수 있다. 다만, HTTP는 암호화가 되지 않은 평문 데이터를 전송하는 프로토콜이기 때문에, HTTP로 비밀번호나 주민등록번호 등을 주고 받으면 제3자가 정보를 조회할 수 있는 문제점이 있다.
- **HTTPS**는 Hyper Text Transfer Protocol Secure의 약자로 HTTP에 데이터 암호화가 추가된 프로토콜이다. HTTPS는 443번 포트를 사용하고 있고 네트워크 상에서 중간에 제3자가 정보를 볼 수 없도록 암호화를 지원한다.
  - HTTPS는 **SSL(Secure Sockets Layer)** 이라는 보안계층 위에 HTTP를 얹어서 보안이 보장된 통신을 하는 프로토콜로 이러한 통신 방식을 **SSL 암호화 통신**이라고 한다. 이 SSL 암호화 통신은 공개키 암호화 방식의 알고리즘으로 구현된다.
  - **공개키 암호화 방식**에는 **공개키와 개인키 두 종류의 키가 존재**한다. 공개키는 모두에게 공개가능한 키 / 개인키는 나만 가지고 알고 있어야 하는 키라고 생각하면 된다. 한쪽 키로 데이터를 암호화 했다면 오직 다른쪽 키로만 복호화를 할 수 있다. 개인키는 보통 서버를 운영하는 회사가 가지고 공개키는 CA(Certificate Authority)라는 인증받은 기업들에서 관리하게 된다. 
  - CA는 서버 운영 기업이 넘겨준 공개키를 인증서 발급자, CA의 이름 등과 함께 묶어서 CA가 가지고 있는 개인키로 암호화해서 **SSL인증서**로 발급한다. 그리고 클라이언트에서 요청을 하면 서버는 클라이언트에게 SSL 인증서를 보낸다. 브라우저(클라이언트)는 대표적인 CA들의 리스트와 그들의 공개키를 보유하고 있다. 만약 인증서에 적힌 CA의 이름과 브라우저가 소유하고 있는 CA 이름이 같다면 CA의 공개키로 SSL 인증서를 복호화한다. 이제 SSL내부에 들어있던 서버의 공개키를 가지고 요청을 암호화해서 서버에게 보낸다. 서버측은 가지고 있는 개인키로 요청을 복호화하여 해석하고 응답은 다시 암호화 해서 보내게 된다. 이 과정을 통해 보안성이 강한 통신을 할 수 있게 된다.

- [관련 블로그](https://devjem.tistory.com/3#HTTPS%EB%-A%--%--%EC%--%B-%EB%--%A-%--%EB%B-%A-%EC%-B%-D%EC%-C%BC%EB%A-%-C%--%EB%B-%B-%EC%--%--%--%EC%-D%B-%EC%-A%--%EB%A-%BC%--%ED%--%B-%EA%B-%B-%ED%--%--%EB%-A%--%EA%B-%--%-F)
  - [관련 블로그 2](https://mangkyu.tistory.com/98)


* * * 

## 쿠키와 세션
- **쿠키 : 방문자의 정보를 방문자 컴퓨터의 메모리에 저장하는 것 ex) ID나 비밀번호를 저장하거나 방문한 사이트를 저장하는 데 사용** 
- **세션 : 방문자의 요청에 따른 정보를 방문자 메모리에 저장하는 것이 아닌 웹 서버가 세션 아이디 파일을 만들어 서비스가 돌아가고 있는 서버에 저장을 하는 것**
  - 즉, 프로세스들 사이에서 통신을 하기 위해 메시지 교환을 통해 서로를 인식한 이후부터 통신을 마칠 때까지의 기간동안 서버에 잠시 방문자 정보를 저장한다는 것. 세션이란 일정 시간동안 같은 사용자(정확하게 브라우저를 말한다)로 부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 일정하게 유지시키는 기술이라고 한다. 또한 여기서 일정 시간이란 방문자가 웹 브라우저를 통해 웹 서버에 접속한 시점으로부터 웹 브라우저를 종료함으로써 연결을 끝내는 시점을 말하며 즉, 방문자가 웹서버에 접속해 있는 상태를 하나의 단위로 보고 세션이라고 칭한다는 것.
  - 그래서 쿠키와 달리 세션은 사용자들의 로그인 정보에 대한 보안을 한층 업그레이드 할 수 있어 웹사이트에 방문하여 계속 접속을 유지할 때 이전의 접속 정보를 이용할 수 있는 방법으로 많이들 사용하는 것이다.
  - HTTP Session 동작 순서 : 클라이언트(사용자)가 서버로 접속(http 요청)을 시도 --> 서버(웹)는 접근한 클라이언트의 request-header field인 cookie를 확인해 클라이언트가 해당 session-id를 보내왔는지 확인 --> 만약 클라이언트로 부터 발송된 session-id가 없다면, 서버는 session-id를 생성해 클라이언트에게 response-header field인 set-cookie 값으로 session-id(임의의 긴 문자열)를 발행(응답)

- **즉, 처음 로그인을 하면 서버 측에서 해당 로그인 정보로 세션을 생성한다. 그리고 클라이언트에게 세션의 ID를 응답으로 보낸다. 클라이언트는 응답으로 받은 세션 ID를 쿠키 저장소에 보관한다. 이후 클라이언트는 요청을 보낼때마다 세션 ID를 쿠키에서 꺼내와 HTTP 헤더에 넣어 보내고, 서버는 세션 ID를 바탕으로 저장된 세션을 탐색해 요청을 보낸 유저가 맞는지 확인, 인증하게 된다. 이게 세션 & 쿠키 방식의 인증이다. 그래서 로그인을 할 때 마다 ID와 PW를 보내지 않고 => 로그인 후 발급되는 세션 ID를 보냄으로 인증을 대체하게 된다. 이렇게 하게 되면 HTTP 요청이 가로채졌을 때 ID와 PW가 노출되지 않는다. 하지만, 세션 ID가 노출될 수는 있어 누군가가 이 세션 ID를 HTTP 헤더에 넣어 유저인척 할 수 있다.**

- [참고 자료](https://88240.tistory.com/190)
  - [참고 자료 2](https://hoonihoon.tistory.com/entry/%EC%BF%A0%ED%82%A4Cookie-%EC%99%80-%EC%84%B8%EC%85%98Session-%EA%B0%9C%EB%85%90)


* * *

## 클라이언트 요청부터 서버 응답 과정
- **django 기준 흐름**
- 클라이언트 요청 -> 웹서버(static파일 처리, 로드밸런싱 처리, nginx) -> gunicorn(웹 서버와 django 서버 통신하기 위한 인터페이스) -> 미들웨어 -> 앱서버(django서버, API서버) -> (존재하는 경우)Celery(broker - worker) -> (존재하는 경우)캐시 서버(redis) -> (DB정보가 필요한 경우)데이터베이스 서버 


* * *

## Web 서버 동작 과정
- **우리가 웹브라우져에서 들어가고 싶은 웹페이지의 주소를 쳤을때, 그 요청이 서버 컴퓨터로 가지면 해당 서버 컴퓨터의 웹 서버라는 프로그램(소프트웨어)은 서버 컴퓨터에 저장되어 있는 웹페이지 파일 중 요청과 맞는 파일을 골라 다시 우리 웹브라우저로 넘겨준다. 이 때 이 주고받는 과정들은 HTTP 규약에 따라 진행된다. 하지만, 위의 구조로는 우리가 원하는 모든 웹페이지를 받아볼 수 없다.**
  - 웹페이지는 "정적 페이지"와 "동적 페이지"로 구분될 수 있다. 
  - 정적 페이지는 웹브라우저(클라이언트) 요청에 항상 같은 내용을 표시하는 웹페이지이다. 서버에 이미 저장된 html, css, javascript 파일들로 구성되어있다. 누가 언제 들어가든 항상 똑같은 내용이다.
  - 동적 페이지는 요청하는 클라이언트마다 각각 다른 내용이 표시되는 웹페이지이다. 로그인 정보, 장바구니, 게시판 등 이러한 동적 페이지를 제공하기 위해선 해당 클라이언트에게만 제공되는 정보를 저장한 데이터베이스의 연동이 필요하다. 
- **웹 서버의 경우 -> 정적 페이지만 처리할 수 있다. 그래서 별도의 동적 페이지를 처리해줄 수 있는 소프트웨어 프로그램이 필요하다.**
- **그래서 등장한 것이 CGI(Common Gateway Interface)프로그램으로, C, C++, PERL, PHP, PYTHON 등의 언어로 만들어졌다. 이 프로그램은 DB관련 로직을 처리하고 동적 페이지를 만들어 웹 서버에게 넘겨준다.**
  - 이 때, 이 CGI프로그램과 웹서버가 정보를 주고받는 규칙을 정의한 것이 CGI 규격이다. 
  - 그러나, 전통적인 CGI방식에서는 동적 처리를 진행할때마다 개별 독립적인 프로세스를 생성하는 방식이어서 요청이 많아질 경우, 프로세스 수가 증가해 서버 컴퓨터의 메모리량이 커지고 시스템 부하 현상이 발생헀다. 
- **위의 이유로 현재는 CGI기술을 사용하지 않고 다른 방법들을 사용한다.**
- **그 다음 등장한 것이 바로 애플리케이션 서버(Web Application Server(WAS))이다. Django 서버를 예로 들 수 있다.**
  - 동적 처리를 하는 응용 프로그램들을 따로 실행할 수 있는 서버를 만들어서 사용하는 방식이다. 
  - 클라이언트가 동적 페이지를 요청했을 때, 웹 서버는 요청을 받아 애플리케이션 서버에게 처리를 위임한다. 그리고 애플리케이션 서버는 동적 처리를 해주는 프로그램들을 실행시켜 DB로부터 원하는 결과를 처리한 후, 다시 웹 서버에게 넘겨주고 웹 서버는 클라이언트에게 결과를 보여준다.
  - 이렇게 서버를 2개로 구분한 이유는, 서로의 역할 구분하는 것이 더 효율적이기 때문이다.
- **오늘날 두 서버는 점점 더 전문화되는 방향으로 발전하고 있다. 웹 서버는 정적 페이지 제공 / 캐시 기능 / 프록시 기능 / http/https의 제어에 필요한 기능 등을 제공한다.    
  웹 애플리케이션 서버는 웹 서버와의 연동 규격을 잘 따르기만 하면 임의의 언어 플랫폼을 사용할 수 있어 많은 종류의 서버가 생겨났다. 자바, python 등**
  - 이러한 2개의 서버를 하나의 하드웨어에서 사용하는 것 보다 나눠쓰는 것이 메모리 효율이 높아지므로 대규모 사이트의 경우, 각각의 서버를 각각의 하드웨어에 설치해서 사용하기도 한다.

- **추가로 django의 경우, Django REST Framework를 설치하여 API 서버를 구축할 수 있다. 이러한 API 서버는 운영과 유지보수를 위해 WAS 서버와 따로 분리하여 운영하는 것이 일반적이다.**

- [참고 블로그](https://iamrealizer.tistory.com/6)


* * *

## Celery 관련 내용
- Celery란, python으로 작성된 비동기 작업 큐로, 비동기로 작업을 처리해서 응답시간을 줄일 수 있다. 무거운 작업들을 Celery Task로 정의해서 Message Broker(요청한 작업들을 담아두는 큐)에서 Task를 받고 여러 Celery Worker에게 적절히 분배하여 일을 수행하게 된다.
- [Celery 동작 구조](https://velog.io/@sms8377/Celery-Python-Celery%EB%9E%80)
- [Celery 예시](https://velog.io/@nameunzz/Celery-Redis)


* * *

## wsgi란
- **WSGI는 Web Server Gateway Interface의 약자로, nginx와 같은 web server와 django라는 프로그램이 서로 소통할 수 있게끔 해주는 인터페이스이다.** 대표적으로 **gunicorn**이라는 프로그램이 있다. 
- django의 runserver는 공식문서에서도 개발 및 테스트가 목적이기 때문에, 배포 환경에서는 보안에 대한 문제가 있어 사용하지 말라고 나와있다. 그래서 배포 환경에서는 wsgi를 통해서 서비스하도록 권장하고 있다.
- **wsgi를 쓴다면 django 등의 웹 프레임워크 기능을 할 수 있게 되는데, 여기에 nginx를 앞에 붙이면 더 좋은 성능을 낼 수 있다.** 
  - 가장 큰 이유로, nginx는 한 번에 들어오는 많은 요청들을 처리하여 로드 밸런싱 및 캐싱 기능을 해줄 수 있다는 점이다.
  - 몇몇 wsgi는 정적 파일을 지원하지 않기 때문에, nginx가 없다면 정적 파일을 django까지 요청이 도착한 다음에야 처리할 수 있으므로 성능이 저하된다.

- [관련 블로그](https://uiandwe.tistory.com/1268)


* * *

## Nginx와 Gunicorn 둘 중 하나만 사용해도 될까
- 클라이언트로부터 오는 HTTP 요청을 파이썬 스크립트가 요구하는 데이터 형식으로 변환하고 응답을 돌려줄 때도 파이썬 데이터를 HTTP 형식으로 바꿔주는 작업이 필요한데, 이 때 파이썬 앱 서버가 동작하는 기본적인 방식이 CGI, Common Gateway Interface이다. 그런데 CGI는 한 가지 문제점이 있었는데, 바로 요청이 들어올 때마다 파이썬 스크립트를 처음부터 실행한다는 것이다.
  - 그래서 이러한 문제점을 보완한 것이 WSGI(Web Server Gateway Interface)이고 웹 서버가 클라이언트의 요청을 받아서 스크립트에 전달해주면 스크립트는 스크립트 전체를 실행시키는 게 아니라 필요한 로직 하나만 실행한 후 결과를 응답해주는 식으로 동작함으로써 동적인 콘텐츠에 대한 요청에 빠르게 응답할 수 있게 해주는 것이다.
- 즉, WSGI는 별도의 프레임워크 같은 게 아니라, 동적인 데이터에 대응하기 위해서 웹 서버와 파이썬 웹 앱이 어떻게 서로 동작해야 하는지에 대한 내용을 담고 있는 specification이다.

- **Nginx가 필요한 이유** -> 정적인 파일 요청을 처리하고 reverse proxy server, load balancer 등의 역할을 수행하기 위해서
- **Gunicorn이 필요한 이유** -> 웹 앱에 HTTP 요청을 전달하고 응답을 되돌려주는 일을 할 WSGI server의 역할을 하기 위해서
- **Gunicorn만 써도 된다** -> Gunicorn이 WSGI middleware로서 웹 서버의 역할을 수행하기 때문에 Gunicorn만 써도 된다. 다만, Nginx가 제공하는 추가적인 혜택을 받지 못할 뿐이다. 
- **Nginx만 써도 된다** -> Flask나 Django 같은 프레임워크는 WSGI interface를 이미 어느 정도 구현해놓았기 때문에 프레임워크를 사용한다면 Nginx만 써도 된다. 다만 session, cookie, routing, authentication 등의 기능을 수행해주는 middleware의 역할이 사라지기 때문에 이 부분은 자기가 하드 코딩해야 한다.

- [관련 블로그](https://velog.io/@jimin_lee/Nginx%EC%99%80-Gunicorn-%EB%91%98-%EC%A4%91-%ED%95%98%EB%82%98%EB%A7%8C-%EC%8D%A8%EB%8F%84-%EB%90%A0%EA%B9%8C)

* * *

## 인바운드와 아웃바운드 규칙
- **AWS 이용 관련**
- 인바운드 규칙 : 인터넷을 포함한 외부 네트워크에서 EC2 인스턴스 또는 RDS로 향하는 정책
- 아웃바운드 규칙 : EC2 인스턴스 또는 RDS에서 인터넷을 포함한 외부 네트워크로 향하는 정책


* * * 

## SSH란
- 원격지 호스트 컴퓨터에 접속하기 위해 사용되는 인터넷 프로토콜 / 기본포트는 22번
  - 기존의 유닉스 시스템 셸에 원격 접속하기 위해 사용하던 텔넷은 암호화가 이루어지지 않아 계정 정보가 탈취될 위험이 높았으나, 여기에 암호화 기능을 추가하여 1995년에 SSH 프로토콜이 탄생
  - SSH는 암호화 기법을 사용하기 때문에, 통신이 노출된다고 하더라도 이해할 수 없는 암호화된 문자로 보이게 된다.

- **SSH 키**
  - **서버에 접속할때 비밀번호 대신 key를 제출하는 방식**
  - 우리가 AWS를 사용할 때 -> 이 SSH 규칙으로 터미널을 통해서 우리가 만든 가상 server에 접근할 수 있음
- [관련 블로그](https://velog.io/@hyeseong-dev/%EB%A6%AC%EB%88%85%EC%8A%A4-ssh%EB%9E%80)


* * *

## IPv4와 IPv6
- IPv4 : Internet Protocol version 4의 약자로, 전 세계적으로 사용된 첫번째 인터넷 프로토콜이다. 32비트 방식으로, 4개로 나눠진 최대 12자리 번호로 되어있다.
  - ex) 123.123.123.123

- IPv6 : Internet protocol version 6의 약자로, IPv4 주소의 고갈문제를 해결하기 위해서 128비트를 채택하여 2의 128승의 개수만큼 주소를 만들 수 있는 프로토콜을 의미. 아직 완전히 적용되지는 않았음.


* * *

## TCP란
- **Transmission Control Protocol의 약자로 서버와 클라이언트간에 데이터를 신뢰성 있게 전달하기 위해 만들어진 프로토콜이다.**
- 데이터를 전송하기 전에 데이터 전송을 위한 연결을 만드는 연결지향 프로토콜로, 데이터는 네트워크 선로를 통해 전달되는 과정에서 손실되거나 순서가 뒤바뀌어서 전달될 수 있는데, TCP는 손실을 검색해내서 이를 교정하고 순서를 재조합할수 있도록 해준다. 

- [관련 블로그](https://musclebear.tistory.com/2)

