# Network

📖 **Contents**

- Network
  - [API란](#api란)
  - [API서버](#api서버)
  - [Web이란](#web이란)
  - [DNS의 역할](#dns의-역할)
  - [HTTPS와 HTTP](#https와-http)
  - [쿠키와 세션](#쿠키와-세션)
  - [클라이언트 요청부터 서버 응답 과정](#클라이언트-요청부터-서버-응답-과정)
  - [Web 서버 동작 과정](#web-서버-동작-과정)
  - [Celery 관련 내용](#celery-관련-내용)
  - [wsgi란](#wsgi란)
  - [Nginx와 Gunicorn 둘 중 하나만 사용해도 될까](#nginx와-gunicorn-둘-중-하나만-사용해도-될까)
  - [인바운드와 아웃바운드 규칙](#인바운드와-아웃바운드-규칙)
  - [SSH란](#ssh란)
  - [IPv4와 IPv6](#ipv4와-ipv6)
  - [TCP란](#tcp란)


* * *

## API란
- Application Programming Interface의 약자로, front-end가 back-end에 요청을 할 때 특정 규칙에 맞게 요청해야 하는데 이러한 사용 규칙을 제공하는 것을 API라고 한다. 웹 서버 따로 API 서버를 따로 구축할 수 있다.

### open API
- 누군가가 back-end를 만들어놓고 여기에 주소와 사용 규칙을 공개한 것을 의미. 
- 그래서 우리는 이 back-end의 사용규칙과 주소만 알면, front-end만 만들어도 얼마든지 요청하고 데이터를 가져와서 사용할 수 있다. 우리가 규칙에 맞게 전송하기만 하면, 지도 / 결제 / 채팅 등 다양한 기능들을 사용할 수 있다.
  - ex) 우리가 카카오 책 검색 open API 서버 주소로 어떤 책에 대한 정보를 요청하면 -> API 서버에서는 자체 DB를 뒤져서 우리가 원하는 정보를 다시 전달해준다.
- 이러한 요청과 응답은 정해진 API 형식에 맞춰서 전달해야 한다. 이러한 형식이 작성된 문서를 **API 가이드**라고 한다. 요즘에는 거의 모든 API에서 JSON형태로 정보가 전달된다.

### open API를 통해 받은 JSON
- open API를 통해 받은 JSON 데이터를 실제 HTML 파일에 출력하려면 -> JSON 데이터를 JavaScript로 접근해야 한다.
- 해당 JSON 데이터를 JavaScript로 console에 표시할 수 있다.
  - 그리고나서, Jquery를 이용해 -> html의 특정 element에 어떤 요소를 넣어줄 수 있다.
  - <script></script> 이렇게 JavaScript 코드 사이에 HTML 특정 element를 설정하고 해당 데이터를 보여줄 수 있다.

- [참고 자료](https://enjoyinjoanne.tistory.com/56)


* * *

## API서버
- 웹브라우저라는 클라이언트가 있고 - django라는 서버가 있을 때, 일반적으로 브라우저에서 어떠한 버튼을 클릭한다고 하면 브라우저에서 /posts/create/와 같이 요청을 하게 된다. => 그러면 django 서버에서는 html template를 만들어서 html 응답을 해주게 된다.
- **이렇게 일반적인 요청 - 응답이 아닌, API 서버에서의 요청 - 응답 통신은 다른 의미가 된다.**
  - API 서버에서는 브라우저에서 /posts/create/와 같이 요청을 하는 것은 **"비동기식 요청"** 을 위해서이다.
  - 일반적인 요청을 동기식 요청이라고 한다면, **비동기식 요청은 버튼을 클릭했을 때 전체 페이지를 요청하고 로딩하는 것이 아니라, 일부분만 다시 그리기 위해 html 화면이 다 그려진 상태에서 일부분만 요청하는 것을 의미한다.**
  - 이러한 비동기식 요청을 하기 위해서는 브라우저에서 특별하게 ajax 요청을 해야 한다. 즉, ajax 통신을 해야 한다.
  - **그리고 이렇게 ajax 요청에 대해서는 JSON 형태의 데이터로 응답을 해줘야 한다. django에서는 딕셔너리의 형태로 데이터를 보내줘야 하는 것이다. 즉, html 파일인 template을 응답하는 게 아니라, JSON 형태로 데이터를 응답해줘야 한다.**
  - 이렇게 응답해주면, Ajax 모듈이 해당 응답을 받아서 key / value 데이터를 뽑아서 화면에 뿌려줄 수 있는 것이다.
  - **이 때, django에서는 DRF(Django REST Framework) 라이브러리가 있어야 이러한 요청을 받아서 JSON 형태의 데이터를 응답해줄 수 있다. DRF가 없는 django에서는 template만 응답으로 줄 수 밖에 없다. 그래서 django에서는 API 서버를 구축하기 위해 DRF를 사용하는 것이다.**

- 관련 개념으로는, 뷰나 리액트의 싱글페이지 어플리케이션이라는 개념이 있다.


* * *

## Web이란

- 정확한 의미의 '인터넷'은 수많은 컴퓨터들이 연결되어서 데이터를 주고받을 수 있는 네트워크, 공간을 의미
- 우리가 편하게 사용하고 있는 무선 인터넷이나 WiFi와 같은 것들도 궁극적으로는 유선으로 연결되어 있음 
- 그래서 수없이 많은 컴퓨터가 네트워크로 연결되어 있고, 그 네트워크 안에 또다른 네트워크가 존재하기 때문에 우리는 이것을 '인터넷'이라고 부른다.
- 우리가 인터넷을 사용한다는 것은, 우리가 이 네트워크에 컴퓨터로 접속해서 각종 텍스트나 이미지, 동영상 등의 데이터를 서로 주고 받는 것을 의미. 그것을 하나의 페이지로 주고받는 경우를 '웹 페이지'라고 볼 수 있다.

- 이 인터넷 내에서 데이터를 주고받는 방법 중 하나가 바로 '웹 서비스' 이다. 따라서 엄밀히 말하면 인터넷과 웹은 같은 의미로 볼 수 없다.
- 인터넷을 활용한 서비스 종류에는 웹 이외에도 파일 전송을 위한 FTP 서비스, 메일 서비스 등이 있다.

### 웹 서비스에서 컴퓨터 간 데이터를 주고받는 방법

- 데이터를 요청하는 쪽을 Client, 그 요청에 응답하는 쪽을 Server라고 한다.
- client가 server에게 얻고자 하는 데이터를 요청하면 -> server는 그러한 데이터를 찾아서 전달해주는 역할.
- 주로 client에서 웹 브라우저를 통해서 데이터를 request하게 되고, 그 request에 대해서 server가 HTML 파일 웹페이지를 response로 전달.
- 이 때, server에 데이터를 요청하려면 IP Address(Internet Protocol Address)가 필요 -> 컴퓨터가 네트워크에 접속했을 때 반드시 부여받게 되는 하나의 주소체계를 의미.
  - IP Address는 총 4개의 섹션으로 구분되어 있고, 각 섹션은 0~255 범위의 10진수 숫자로 표현됨 ex) 125.209.222.142
- 다만, 이러한 IP 주소를 모두 외울 수는 없으니, client가 텍스트로 이루어진 주소로 요청하게 되면 -> 그에 맞는 IP Address로 변환해서 서버를 찾을 수 있게끔 해주는 것.
  - 이렇게 IP Address를 기억하기 쉽게끔 이름을 부여한 것을 우리는 "Domain" 이라고 한다.
  - 그리고 이 Damain과 IP Address를 양방향으로 변환할 수 있게끔 해주는 것이 바로 **Domain Name System, 줄여서 DNS**라고 한다.

### HTTP

- 웹 서비스에서 데이터를 주고받을 때 반드시 지켜야 할 통신 규약
- HTTP는 Hyper Text Transfer Protocol의 약자로 Hyper Text가 웹사이트에서 볼 수 있는 링크, 하이퍼 링크를 의미. 그리고 Protocol은 규칙, 규약에 해당.
- 웹 서비스 등 해당 서비스에 맞게 정확한 프로토콜을 따라야 데이터를 원하는대로 주고받을 수 있다.
- 우리는 앞으로 웹 페이지를 만드는 방법에 대해서 배울 것이고, 이러한 웹 페이지(HTML파일)를 주고받으려면 HTTP에 대해서 알아야 한다.
> - [HTTP 관련 MDN 내용](https://developer.mozilla.org/ko/docs/Web/HTTP/Overview)


* * *

## DNS의 역할
- **IP주소와 도메인명을 서로 교환해주는 장치를 DNS(Domain Name System)라고 한다.**
- DNS 서버는 **캐시 서버**와 **콘텐츠 서버**로 나뉜다.
  - 클라이언트인 웹 브라우저가 인터넷에서 도메인명으로 엑세스할 때 --> 캐시 서버는 받은 도메인명의 맨 오른쪽부터 순서대로 검색하여, 해당 도메인명을 관리하는 콘텐츠 서버들을 하나씩 찾는다. 그래서 마지막으로 콘텐츠 서버를 찾게 되면 해당 서버가 호스트명 + 도메인명에 대응하는 IP주소를 알려주게 되고, 캐시 서버는 이 IP주소를 웹 브라우저에게 알려주면서 해당 사이트로 접속할 수 있게 해준다. 이러한 동작을 **이름 해결** 이라고 한다.

- 도메인명은 ‘www.examaple.co.kr’ 와 같이 점으로 구분된 문자열로 구성되어 있다. 하나하나 문자열을 **라벨**이라고 하고 오른쪽부터 순서대로 탑레벨(제1레벨) 도메인, 제 2레벨 도메인, 제 3레벨 도메인 이렇게 부른다.
  - 즉, 트리모양의 계층 구조로 이루어져 있다.

- [참고 자료](https://goodgid.github.io/Server-DNS/)


* * *

## HTTPS와 HTTP
- **HTTP**는 Hyper Text Transfer Protocol의 약자로 서버와 클라이언트간에 데이터를 주고 받는 프로토콜을 의미한다. **80번 포트**를 사용하고 있으며 텍스트, 이미지,영상, JSON 등등 거의 모든 형태의 데이터를 전송할 수 있다. 다만, HTTP는 암호화가 되지 않은 평문 데이터를 전송하는 프로토콜이기 때문에, HTTP로 비밀번호나 주민등록번호 등을 주고 받으면 제3자가 정보를 조회할 수 있는 문제점이 있다.
- **HTTPS**는 Hyper Text Transfer Protocol Secure의 약자로 HTTP에 데이터 암호화가 추가된 프로토콜이다. HTTPS는 443번 포트를 사용하고 있고 네트워크 상에서 중간에 제3자가 정보를 볼 수 없도록 암호화를 지원한다.
  - HTTPS는 **SSL(Secure Sockets Layer)** 이라는 보안계층 위에 HTTP를 얹어서 보안이 보장된 통신을 하는 프로토콜로 이러한 통신 방식을 **SSL 암호화 통신**이라고 한다. 이 SSL 암호화 통신은 공개키 암호화 방식의 알고리즘으로 구현된다.
  - **공개키 암호화 방식**에는 **공개키와 개인키 두 종류의 키가 존재**한다. 공개키는 모두에게 공개가능한 키 / 개인키는 나만 가지고 알고 있어야 하는 키라고 생각하면 된다. 한쪽 키로 데이터를 암호화 했다면 오직 다른쪽 키로만 복호화를 할 수 있다. 개인키는 보통 서버를 운영하는 회사가 가지고 공개키는 CA(Certificate Authority)라는 인증받은 기업들에서 관리하게 된다. 
  - CA는 서버 운영 기업이 넘겨준 공개키를 인증서 발급자, CA의 이름 등과 함께 묶어서 CA가 가지고 있는 개인키로 암호화해서 **SSL인증서**로 발급한다. 그리고 클라이언트에서 요청을 하면 서버는 클라이언트에게 SSL 인증서를 보낸다. 브라우저(클라이언트)는 대표적인 CA들의 리스트와 그들의 공개키를 보유하고 있다. 만약 인증서에 적힌 CA의 이름과 브라우저가 소유하고 있는 CA 이름이 같다면 CA의 공개키로 SSL 인증서를 복호화한다. 이제 SSL내부에 들어있던 서버의 공개키를 가지고 요청을 암호화해서 서버에게 보낸다. 서버측은 가지고 있는 개인키로 요청을 복호화하여 해석하고 응답은 다시 암호화 해서 보내게 된다. 이 과정을 통해 보안성이 강한 통신을 할 수 있게 된다.

- [관련 블로그](https://devjem.tistory.com/3#HTTPS%EB%-A%--%--%EC%--%B-%EB%--%A-%--%EB%B-%A-%EC%-B%-D%EC%-C%BC%EB%A-%-C%--%EB%B-%B-%EC%--%--%--%EC%-D%B-%EC%-A%--%EB%A-%BC%--%ED%--%B-%EA%B-%B-%ED%--%--%EB%-A%--%EA%B-%--%-F)
  - [관련 블로그 2](https://mangkyu.tistory.com/98)


* * * 

## 쿠키와 세션
- **쿠키 : 방문자의 정보를 방문자 컴퓨터의 메모리에 저장하는 것 ex) ID나 비밀번호를 저장하거나 방문한 사이트를 저장하는 데 사용** 
- **세션 : 방문자의 요청에 따른 정보를 방문자 메모리에 저장하는 것이 아닌 웹 서버가 세션 아이디 파일을 만들어 서비스가 돌아가고 있는 서버에 저장을 하는 것**
  - 즉, 프로세스들 사이에서 통신을 하기 위해 메시지 교환을 통해 서로를 인식한 이후부터 통신을 마칠 때까지의 기간동안 서버에 잠시 방문자 정보를 저장한다는 것. 세션이란 일정 시간동안 같은 사용자(정확하게 브라우저를 말한다)로 부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 일정하게 유지시키는 기술이라고 한다. 또한 여기서 일정 시간이란 방문자가 웹 브라우저를 통해 웹 서버에 접속한 시점으로부터 웹 브라우저를 종료함으로써 연결을 끝내는 시점을 말하며 즉, 방문자가 웹서버에 접속해 있는 상태를 하나의 단위로 보고 세션이라고 칭한다는 것.
  - 그래서 쿠키와 달리 세션은 사용자들의 로그인 정보에 대한 보안을 한층 업그레이드 할 수 있어 웹사이트에 방문하여 계속 접속을 유지할 때 이전의 접속 정보를 이용할 수 있는 방법으로 많이들 사용하는 것이다.
  - HTTP Session 동작 순서 : 클라이언트(사용자)가 서버로 접속(http 요청)을 시도 --> 서버(웹)는 접근한 클라이언트의 request-header field인 cookie를 확인해 클라이언트가 해당 session-id를 보내왔는지 확인 --> 만약 클라이언트로 부터 발송된 session-id가 없다면, 서버는 session-id를 생성해 클라이언트에게 response-header field인 set-cookie 값으로 session-id(임의의 긴 문자열)를 발행(응답)

- [참고 자료](https://88240.tistory.com/190)
  - [참고 자료 2](https://hoonihoon.tistory.com/entry/%EC%BF%A0%ED%82%A4Cookie-%EC%99%80-%EC%84%B8%EC%85%98Session-%EA%B0%9C%EB%85%90)


* * *

## 클라이언트 요청부터 서버 응답 과정
- **django 기준 흐름**
- 클라이언트 요청 -> 웹서버(static파일 처리, 로드밸런싱 처리, nginx) -> gunicorn(웹 서버와 django 서버 통신하기 위한 인터페이스) -> 미들웨어 -> 앱서버(django서버, API서버) -> (존재하는 경우)Celery(broker - worker) -> (존재하는 경우)캐시 서버(redis) -> (DB정보가 필요한 경우)데이터베이스 서버 


* * *

## Web 서버 동작 과정
- **우리가 웹브라우져에서 들어가고 싶은 웹페이지의 주소를 쳤을때, 그 요청이 서버 컴퓨터로 가지면 해당 서버 컴퓨터의 웹 서버라는 프로그램(소프트웨어)은 서버 컴퓨터에 저장되어 있는 웹페이지 파일 중 요청과 맞는 파일을 골라 다시 우리 웹브라우저로 넘겨준다. 이 때 이 주고받는 과정들은 HTTP 규약에 따라 진행된다. 하지만, 위의 구조로는 우리가 원하는 모든 웹페이지를 받아볼 수 없다.**
  - 웹페이지는 "정적 페이지"와 "동적 페이지"로 구분될 수 있다. 
  - 정적 페이지는 웹브라우저(클라이언트) 요청에 항상 같은 내용을 표시하는 웹페이지이다. 서버에 이미 저장된 html, css, javascript 파일들로 구성되어있다. 누가 언제 들어가든 항상 똑같은 내용이다.
  - 동적 페이지는 요청하는 클라이언트마다 각각 다른 내용이 표시되는 웹페이지이다. 로그인 정보, 장바구니, 게시판 등 이러한 동적 페이지를 제공하기 위해선 해당 클라이언트에게만 제공되는 정보를 저장한 데이터베이스의 연동이 필요하다. 
- **웹 서버의 경우 -> 정적 페이지만 처리할 수 있다. 그래서 별도의 동적 페이지를 처리해줄 수 있는 소프트웨어 프로그램이 필요하다.**
- **그래서 등장한 것이 CGI(Common Gateway Interface)프로그램으로, C, C++, PERL, PHP, PYTHON 등의 언어로 만들어졌다. 이 프로그램은 DB관련 로직을 처리하고 동적 페이지를 만들어 웹 서버에게 넘겨준다.**
  - 이 때, 이 CGI프로그램과 웹서버가 정보를 주고받는 규칙을 정의한 것이 CGI 규격이다. 
  - 그러나, 전통적인 CGI방식에서는 동적 처리를 진행할때마다 개별 독립적인 프로세스를 생성하는 방식이어서 요청이 많아질 경우, 프로세스 수가 증가해 서버 컴퓨터의 메모리량이 커지고 시스템 부하 현상이 발생헀다. 
- **위의 이유로 현재는 CGI기술을 사용하지 않고 다른 방법들을 사용한다.**
- **그 다음 등장한 것이 바로 애플리케이션 서버(Web Application Server(WAS))이다. Django 서버를 예로 들 수 있다.**
  - 동적 처리를 하는 응용 프로그램들을 따로 실행할 수 있는 서버를 만들어서 사용하는 방식이다. 
  - 클라이언트가 동적 페이지를 요청했을 때, 웹 서버는 요청을 받아 애플리케이션 서버에게 처리를 위임한다. 그리고 애플리케이션 서버는 동적 처리를 해주는 프로그램들을 실행시켜 DB로부터 원하는 결과를 처리한 후, 다시 웹 서버에게 넘겨주고 웹 서버는 클라이언트에게 결과를 보여준다.
  - 이렇게 서버를 2개로 구분한 이유는, 서로의 역할 구분하는 것이 더 효율적이기 때문이다.
- **오늘날 두 서버는 점점 더 전문화되는 방향으로 발전하고 있다. 웹 서버는 정적 페이지 제공 / 캐시 기능 / 프록시 기능 / http/https의 제어에 필요한 기능 등을 제공한다.    
  웹 애플리케이션 서버는 웹 서버와의 연동 규격을 잘 따르기만 하면 임의의 언어 플랫폼을 사용할 수 있어 많은 종류의 서버가 생겨났다. 자바, python 등**
  - 이러한 2개의 서버를 하나의 하드웨어에서 사용하는 것 보다 나눠쓰는 것이 메모리 효율이 높아지므로 대규모 사이트의 경우, 각각의 서버를 각각의 하드웨어에 설치해서 사용하기도 한다.

- **추가로 django의 경우, Django REST Framework를 설치하여 API 서버를 구축할 수 있다. 이러한 API 서버는 운영과 유지보수를 위해 WAS 서버와 따로 분리하여 운영하는 것이 일반적이다.**

- [참고 블로그](https://iamrealizer.tistory.com/6)


* * *

## Celery 관련 내용
- Celery란, python으로 작성된 비동기 작업 큐로, 비동기로 작업을 처리해서 응답시간을 줄일 수 있다. 무거운 작업들을 Celery Task로 정의해서 Message Broker(요청한 작업들을 담아두는 큐)에서 Task를 받고 여러 Celery Worker에게 적절히 분배하여 일을 수행하게 된다.
- [Celery 동작 구조](https://velog.io/@sms8377/Celery-Python-Celery%EB%9E%80)
- [Celery 예시](https://velog.io/@nameunzz/Celery-Redis)


* * *

## wsgi란
- **WSGI는 Web Server Gateway Interface의 약자로, nginx와 같은 web server와 django라는 프로그램이 서로 소통할 수 있게끔 해주는 인터페이스이다.** 대표적으로 **gunicorn**이라는 프로그램이 있다. 
- django의 runserver는 공식문서에서도 개발 및 테스트가 목적이기 때문에, 배포 환경에서는 보안에 대한 문제가 있어 사용하지 말라고 나와있다. 그래서 배포 환경에서는 wsgi를 통해서 서비스하도록 권장하고 있다.
- **wsgi를 쓴다면 django 등의 웹 프레임워크 기능을 할 수 있게 되는데, 여기에 nginx를 앞에 붙이면 더 좋은 성능을 낼 수 있다.** 
  - 가장 큰 이유로, nginx는 한 번에 들어오는 많은 요청들을 처리하여 로드 밸런싱 및 캐싱 기능을 해줄 수 있다는 점이다.
  - 몇몇 wsgi는 정적 파일을 지원하지 않기 때문에, nginx가 없다면 정적 파일을 django까지 요청이 도착한 다음에야 처리할 수 있으므로 성능이 저하된다.

- [관련 블로그](https://uiandwe.tistory.com/1268)


* * *

## Nginx와 Gunicorn 둘 중 하나만 사용해도 될까
- 클라이언트로부터 오는 HTTP 요청을 파이썬 스크립트가 요구하는 데이터 형식으로 변환하고 응답을 돌려줄 때도 파이썬 데이터를 HTTP 형식으로 바꿔주는 작업이 필요한데, 이 때 파이썬 앱 서버가 동작하는 기본적인 방식이 CGI, Common Gateway Interface이다. 그런데 CGI는 한 가지 문제점이 있었는데, 바로 요청이 들어올 때마다 파이썬 스크립트를 처음부터 실행한다는 것이다.
  - 그래서 이러한 문제점을 보완한 것이 WSGI(Web Server Gateway Interface)이고 웹 서버가 클라이언트의 요청을 받아서 스크립트에 전달해주면 스크립트는 스크립트 전체를 실행시키는 게 아니라 필요한 로직 하나만 실행한 후 결과를 응답해주는 식으로 동작함으로써 동적인 콘텐츠에 대한 요청에 빠르게 응답할 수 있게 해주는 것이다.
- 즉, WSGI는 별도의 프레임워크 같은 게 아니라, 동적인 데이터에 대응하기 위해서 웹 서버와 파이썬 웹 앱이 어떻게 서로 동작해야 하는지에 대한 내용을 담고 있는 specification이다.

- **Nginx가 필요한 이유** -> 정적인 파일 요청을 처리하고 reverse proxy server, load balancer 등의 역할을 수행하기 위해서
- **Gunicorn이 필요한 이유** -> 웹 앱에 HTTP 요청을 전달하고 응답을 되돌려주는 일을 할 WSGI server의 역할을 하기 위해서
- **Gunicorn만 써도 된다** -> Gunicorn이 WSGI middleware로서 웹 서버의 역할을 수행하기 때문에 Gunicorn만 써도 된다. 다만, Nginx가 제공하는 추가적인 혜택을 받지 못할 뿐이다. 
- **Nginx만 써도 된다** -> Flask나 Django 같은 프레임워크는 WSGI interface를 이미 어느 정도 구현해놓았기 때문에 프레임워크를 사용한다면 Nginx만 써도 된다. 다만 session, cookie, routing, authentication 등의 기능을 수행해주는 middleware의 역할이 사라지기 때문에 이 부분은 자기가 하드 코딩해야 한다.

- [관련 블로그](https://velog.io/@jimin_lee/Nginx%EC%99%80-Gunicorn-%EB%91%98-%EC%A4%91-%ED%95%98%EB%82%98%EB%A7%8C-%EC%8D%A8%EB%8F%84-%EB%90%A0%EA%B9%8C)

* * *

## 인바운드와 아웃바운드 규칙
- **AWS 이용 관련**
- 인바운드 규칙 : 인터넷을 포함한 외부 네트워크에서 EC2 인스턴스 또는 RDS로 향하는 정책
- 아웃바운드 규칙 : EC2 인스턴스 또는 RDS에서 인터넷을 포함한 외부 네트워크로 향하는 정책


* * * 

## SSH란
- 원격지 호스트 컴퓨터에 접속하기 위해 사용되는 인터넷 프로토콜 / 기본포트는 22번
  - 기존의 유닉스 시스템 셸에 원격 접속하기 위해 사용하던 텔넷은 암호화가 이루어지지 않아 계정 정보가 탈취될 위험이 높았으나, 여기에 암호화 기능을 추가하여 1995년에 SSH 프로토콜이 탄생
  - SSH는 암호화 기법을 사용하기 때문에, 통신이 노출된다고 하더라도 이해할 수 없는 암호화된 문자로 보이게 된다.

- **SSH 키**
  - **서버에 접속할때 비밀번호 대신 key를 제출하는 방식**
  - 우리가 AWS를 사용할 때 -> 이 SSH 규칙으로 터미널을 통해서 우리가 만든 가상 server에 접근할 수 있음
- [관련 블로그](https://velog.io/@hyeseong-dev/%EB%A6%AC%EB%88%85%EC%8A%A4-ssh%EB%9E%80)


* * *

## IPv4와 IPv6
- IPv4 : Internet Protocol version 4의 약자로, 전 세계적으로 사용된 첫번째 인터넷 프로토콜이다. 32비트 방식으로, 4개로 나눠진 최대 12자리 번호로 되어있다.
  - ex) 123.123.123.123

- IPv6 : Internet protocol version 6의 약자로, IPv4 주소의 고갈문제를 해결하기 위해서 128비트를 채택하여 2의 128승의 개수만큼 주소를 만들 수 있는 프로토콜을 의미. 아직 완전히 적용되지는 않았음.


* * *

## TCP란
- **Transmission Control Protocol의 약자로 서버와 클라이언트간에 데이터를 신뢰성 있게 전달하기 위해 만들어진 프로토콜이다.**
- 데이터를 전송하기 전에 데이터 전송을 위한 연결을 만드는 연결지향 프로토콜로, 데이터는 네트워크 선로를 통해 전달되는 과정에서 손실되거나 순서가 뒤바뀌어서 전달될 수 있는데, TCP는 손실을 검색해내서 이를 교정하고 순서를 재조합할수 있도록 해준다. 

- [관련 블로그](https://musclebear.tistory.com/2)

