# Security

📖 **Contents**

- Security
  - [패스워드는 서버에 어떻게 보관될까](#패스워드는-서버에-어떻게-보관될까)
  - [JWT 토큰이란](#jwt-토큰이란)
  - [OAuth란](#oauth란)

* * *

## 패스워드는 서버에 어떻게 보관될까
- **단방향 해시 함수를 사용하여 패스워드를 암호화해서 보관한다.**
- 단뱡향 해시 함수는 어떤 수학적 연산이나 알고리즘에 의해 원본 데이터를 매핑시켜 완전히 다른 암호화된 데이터로 변환시키는 것을 의미한다. 이 변환을 해시라고 하고, 해시에 의해 암호화된 데이터를 다이제스트(digest)라고 한다. 이렇게 DB에 저장된 다이제스트는 DB가 해킹당한다 하더라도 단방향으로 해싱된 문자이기 때문에 복호화를 할 수 없다.

- [관련 블로그](https://st-lab.tistory.com/100)


* * *

## JWT 토큰이란
- **먼저 세션으로 권한 및 인가를 허용하는 과정은 다음과 같다.**
  - 사용자가 로그인에 성공하면 세션을 발행
  - 그 세션 id를 브라우저에 쿠키로 저장하고 서버 메모리 또는 데이터베이스에도 세션을 저장
  - 인가가 필요한 요청을 보낼 때 서버에 쿠키인 세션 id를 보냄 
  - 서버에서 메모리 또는 데이터베이스에 저장된 값과 쿠키인 세션 id와 비교해서 맞다면 권한 및 인가를 허용

- **토큰 방식**
  - **회원가입 시 유저에 매칭되는 토큰을 생성하여 저장한다. 로그인 요청이 들어오면 해당 토큰을 응답으로 보내주고, 클라이언트는 이 토큰을 잘 가지고 있다가 요청을 보낼 때 헤더에 토큰을 넣어 보낸다. 서버는 요청으로 들어온 토큰이 있는지 확인하여 인증하게 된다. 토큰 자체에 사용자에 대한 정보가 있어서 서버는 이 토큰만을 가지고 어떤 유저인지 구분해낼 수 있다.**
  - **토큰은 기본적으로 암호화방식을 채택한다. 이 암호화에 필요한 키는 바로 우리가 settings.py에서 본 SECRET_KEY이다.** 따라서 이 키가 노출되지 않는다면 토큰 자체로는 어떤 정보도 얻어낼 수 없다. 보안을 강화하기 위해 토큰에 대해 유효기간을 설정해줄 수 있다.

- **JWT(JSON Web Token)이란,** 
  - 예를 들어, eyJhbGciOiJIUzI1NiIsIn 이러한 형식이다. 사용자가 로그인을 하면 서버에서 토큰을 발행해주는 것으로, 이 토큰을 서버가 기억하고 있지 않는다.
    - 인가가 필요한 요청을 보낼 때 사용자는 해당 토큰을 보내야 한다.
  - 이 토큰은 암호화된 3가지 데이터를 이어붙인 형태(aaa.bbb.ccc)로 구성되어 있다. 
  - 첫번째로는 헤더 : 세번째 서명 값을 만드는데 사용하는 알고리즘과 type이 들어간다. ex) HS256 / JWT
  - 두번째로는 페이로드 : 토큰이 갖는 데이터를 의미.
  - 세번째로는 서명 : 1번 헤더에 정의된 알고리즘을 통해 암호화한 비밀 값으로 서버만 알고 있음

- **JWT 단점**
  - 세션처럼 모든 사용자들의 상태를 기억하고 있지 않기 때문에 기억하는 대상들의 상태를 항상 제어할 수 없다.
  - 이미 발행한 토큰이 해커한테 넘어가도 토큰을 무효화할 방법이 없다.

- **해결책으로 로그인 시 accessToken / refreshToken 이렇게 2개의 토큰을 발행해준다.** 
  - accessToken은 매번 인가받을 때 사용하는 토큰(수명이 짧다)
  - refreshToken은 accessToken의 수명이 다했을 때 accessToken을 재발행 받기 위한 토큰(보통 2주 정도 유지)
  - 누군가를 로그아웃 시키려면 refeshToken을 db에서 지워버리면 되는데 그래도 accessToken의 수명 동안은 바로 차단할 방법은 없음

- [관련 블로그](https://velog.io/@syoung125/JWT-%ED%86%A0%ED%81%B0%EC%9D%B4%EB%9E%80)


* * * 

## OAuth란
- 사용자가 어떤 애플리케이션을 이용할 때, 비밀번호를 입력하지 않고 OAuth를 제공하는 애플리케이션에 계정 정보를 공유하여 접근 권한을 부여할 수 있는 수단
- OAuth가 사용되기 전에는 각 애플리케이션이나 웹 사이트마다 개별적인 인증 방식으로 아이디와 비밀번호를 사용하여 로그인 => OAuth는 제각각인 인증방식을 표준화한 것

<br>

- **관련 용어**
  - 구글이나 페이스북을 우리가 제어하고자 하는 자원을 갖고있는 서버라는 뜻에서 **Resource Server** 라고 지칭, 즉, 데이터를 가지고 있는 서버 / **Authorization Server**도 있다. 인증과 관련된 처리를 전담하는 서버
  - 일반 사용자 및 유저는 이 자원의 소유자이기 때문에, **Resource Owner** 라고 한다.
  - 우리의 웹서비스를 이 resource server에 접속해서 정보를 가져가는 **Client** 라고 한다.

<br>

### 전체적인 흐름
- 사용자가 우리 서비스에 접속해서 글을 작성하거나 글을 읽는다면, 우리의 서비스가 사용자를 대신해서 서비스 제공자(구글 등)의 달력에 날짜를 기록하는 등을 해줄 수 있다. 이러기 위해서 우리가 사용자로부터 사용자가 사용하고 있는 서비스 제공자에게 접근할 수 있도록 허가를 받아야 한다. 서비스 제공자의 사용자 id, 비밀번호가 있을 텐데, 그것들을 우리가 사용자로부터 전달받아서 우리가 사용자의 id와 비밀번호를 기억하고 있다가, 우리가 실제로 서비스 제공자쪽으로 접속할 때 그 id와 비밀번호를 이용하면 될 것이다. **근데, 사용자 입장에서는 위험하다. 자신의 구글, 페이스북의 id와 비밀번호를 처음 보는 웹서비스쪽에 맞겨야 되는 것이기 때문이다. 그래서 사용자는 우리의 서비스를 믿을 수 없다. 또, 구글이나 페이스북 입장에서도 자신들의 사용자의 id와 비밀번호를 신뢰할 수 없는 제 3자가 가지고 있다는 건 매우 불만족스러운 상황이다.** 바로 이러한 상황에서 우리가 OAuth를 이용하면 훨씬 더 안전하게 우리가 만든 서비스를 서비스 제공자와 사용할 수 있게 된다.  
  - OAuth에서는 대신에 사용자의 요청에 의해서 구글이나 페이스북이 id, 비밀번호 대신에 **accessToken**이라는 것을, 일종의 비밀번호를 발급해준다. 이 accessToken은 구글이나 페이스북의 id와 비밀번호가 아니라는 장점이 있다. 그리고 구글이나 페이스북이 갖고 있는 모든 기능이 아니라, 그 중에 우리의 서비스가 필요한 필수적인 기능만 부분적으로 허용하는 비밀번호이다. 그래서 우리의 서비스가 이 accessToken을 OAuth를 통해서 획득한 다음에, 우리가 이 accessToken를 통해서 구글이나 페이스북 서비스에 접근해서, 데이터를 가져오고 수정하고 생성하고 삭제하는 작업을 할 수 있게 되는 것이다. 

### OAuth 등록절차 - Client가 Resource Server에 등록하는 과정
- 클라이언트가 리소스 서버를 이용하기 위해서는, 리소스 서버의 승인을 사전에 받아놔야 한다. 이걸 이제 “등록”이라고 한다. 
- 이 등록을 하기 위해서는 **Client ID와 Client Secret 그리고 Authorized redirect URIs** 이 3가지 요소를 리소스 서버로부터 공통적으로 받는다. 
  - 여기서 client ID라고 하는 값은 우리가 만들고 있는 애플리케이션을 식별하는 식별자, ID라고 보면 된다. Client Secret이라고 하는 값은 위의 ID에 대한 비밀번호이다. 그래서 client ID는 외부에 노출될 수 있지만, Client Secret은 절대로 외부에 노출되면 안 된다. 
  - 그 다음으로 Authorized(권한이 부여된) redirect URIs라고 하는 것은, 리소스 서버가 우리에게 권한을 부여하는 과정에서 우리한테 **Authorized CODE**라는 값을 전달해 줄 것이다. 그 때, ‘이 주소로 전달해주세요!’ 라고 알려주는 것이다.











