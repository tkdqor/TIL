# ETC

📖 **Contents**

- ETC
  - [Directory & Terminal](#디렉터리)
  - [Linux 명령어](#linux-명령어)
  - [Git](#Git)
  - [Git remote url 변경](#git-remote-url-변경)
  - [Github](#github이란)
  - [책 '비전공자를 위한 이해할 수 있는 IT지식' 요약](#비전공자를-위한-이해할-수-있는-IT-지식-요약-내용)

* * *

## 디렉터리
- 우리가 흔히 사용하는 폴더의 같은 의미.

### 계층구조
- 데이터를 효율적으로 관리하기 위해 사용하는 디렉터리의 구성. 나뭇가지처럼 트리 구조로 이루어진다.

### 디렉터리 경로
- 디렉터리가 위치한 곳을 나타내는 주소를 의미.
- **절대 경로와 상대경로로 구분.**


### 절대경로
- 디렉터리가 위치한 곳을 나타내는 가장 정확하고 디테일한 주소를 의미. 주소를 처음부터 끝까지 적은 것을 의미한다.
- 현재 위치한 곳(Working Directory)과 상관없이 항상 같은 위치를 가리킬 수 있는 주소. ex) 우리 서울시 서초구 강남대로 465에서 만나자..

- 바탕화면은 Desktop 디렉터리로 표현되는데, 절대경로로 표현하면 맥에서는 Users/본인이름/Desktop 이렇게 표현한다. 윈도우는 C드라이브부터 시작하게 된다. 또한, 윈도우는 경로를 나타날 때 백슬래쉬를 사용. ex) C:\Program Files\Adobe (우리나라는 원화표시로 사용)
- 그래서 우리가 어떤 디렉터리에 있든 항상 같은 디렉터리를 가리킬 수 있는 게 절대경로이다.


### 상대경로
- 디렉터리가 위치한 곳을 현재 위치를 기준으로 설명하는 경로를 의미한다. 현재 어디에 위치하느냐에 따라 동일한 경로도 다르게 표현될 수 있다. ex) 우리 반대편에서 만나자..
- 상대경로에서 현재 본인이 위치한 곳은 점(.)으로 표현하고 / 현재 위치한 곳보다 한 단계 상위의 부모 디렉터리의 위치는 점점(..)으로 표현한다.

ex) A 디렉터리에서 하위 B 디렉터리로 이동할 때는 -> ./B 또는 B 을 입력하면 된다.(./를 생략할 수 있다.)      
    A 디렉터리에서 상위 C 디렉터리로 이동할 때는 -> ../ 입력.
    
    
## Terminal
- 지금은 컴퓨터에게 마우스나 키보드, 화면 터치 등 다양한 방식으로 다양한 방법을 통해 컴퓨터에 명령을 입력할 수 있지만 옛날에는 이러한 방법들이 없었다. 단순히 전달받은 입력값에 대해 처리만 할 뿐, 컴퓨터와 사용자가 실시간으로 상호작용하는 것은 힘들었다.
- 시간이 지나 터미널이라는 장치가 개발되고 사람이 텍스트로 컴퓨터에게 데이터를 입력할 수 있게 되었고 그 입력에 대한 처리 결과를 화면에 표시할 수 있게 되었다. 이렇게 텍스트를 기준으로 컴퓨터와 사용자가 상호작용 하는 것을 Command-Line interface, CLI라고 부른다.
- 이 CLI를 제공하는 프로그램을 Command-Line Interpreter 또는 Shell이라고 부른다. 대표적인 Shell 프로그램으로 유닉스 운영체제에서 사용하는 Bash Shell, 윈도우에서 사용하는 PowerShell이 있다. 이 Shell 프로그램으로 과거 터미널이라는 장치를 소프트웨어 형태로 구현한 것을 Terminal Emulator라고 부른다.

-> 즉, 터미널이란 텍스트 기반으로 컴퓨터에게 명령을 내리고 그 결과를 확인할 수 있게끔 해주는 것이다. 운영체제에 따라 다양한 소프트웨어가 있고 환경에 따라 명령어가 다를 수 있다.   
   윈도우에는 cmd나 powershell이 내장되어 있고, 맥에서는 terminal이 내장되어 있다.   
   우리가 나중에 서비스를 배포하기 위해 서버를 직접 발급받아 서버 내부에서 작업하게 될 때, 현업에서 쓰이는 거의 모든 서버는 Linux라는 운영체제를 사용하고 있고 이 운영체제에서 가장 많이 쓰이는 shell은 Bash shell이다.
   
-> Linux와 Mac은 유사한 점이 많아 똑같은 명령어 체계를 사용할 수 있지만, 윈도우의 경우에는 전혀 다른 명령어 체계를 배워야 한다. 하지만 윈도우에서 Git Bash라는 프로그램을 사용하면 Linux와 Mac과 동일한 Bash 기반의 명령어를 사용할 수 있기 때문에 윈도우의 경우 git Bash를 설치하는 게 좋다. git를 설치하면 자동으로 설치가 된다.


### Terminal 명령어
- 터미널에 들어가면 현재 컴퓨터에 로그인 되어있는 계정정보와 컴퓨터 정보, 우리가 현재 위치해 있는 경로가 표시된다.   
  kimsangbaek@gimsangbaeg-ui-MacBookAir ~ %  -> 순서대로 계정의 유저이름 / @컴퓨터이름(호스트명) / ~경로를 의미. ~표시는 영어로 Tilde라고 하는데, Home Directory를 의미한다.   
  터미널을 실행하면, 맨 처음 위치하게 되는 디렉터리가 바로 홈 디렉터리이다.
  
1) pwd 
- 현재 디렉터리가 위치하고 있는 경로를 의미. Working Directory의 절대경로가 출력됨. print working directory의 약자.

2) ls
- list의 약자로, 현재 위치한 디렉터리 내부에 어떤 파일와 디렉터리들이 있는지 내용물들을 나열해준다. 여기서 Desktop이 바탕화면에 해당한다.

3) cd 디렉터리이름
- change directory의 약자로 현재 위치한 경로를 다른 위치로 바꿔주는 명령어를 의미. 이 명령어를 이용해서 원하는 디렉터리 위치로 이동할 수 있다.   
- ex) cd Desktop 이렇게 입력했을 때는 사실 -> cd ./Desktop과 같은 코드이다. 즉, 여기서는 자식 디렉터리로 이동하는 것이기에 ./를 생략한 것이다. 그리고 상대경로를 이용했다고 볼 수 있다.
- 만약, 절대경로를 이용한다면 pwd를 입력해서 현재 절대경로를 확인 및 복사하고 붙여넣은 다음, 그 뒤에 /자식 디렉터리를 입력해주면 된다. ex) /Users/kimsangbaek/Desktop/likelion 

4) cd ..
- 한 단계 위의 디렉터리로 이동하려면 다음과 같은 명령어를 입력하면 된다.

5) Tab 키
- 컴퓨터는 내부 디렉터리 구조를 다 알고 있기 때문에 한 두 글자를 입력하고 Tab 키를 누르면 알아서 디렉터리 이름이 자동완성된다. 

6) clear
- 터미널 화면을 맨 윗줄에서부터 입력할 수 있게 해주는 명령어.

7) mkdir (make directory)
- 새로운 디렉터리를 만들어주는 것. mkdir이라고 입력하고 한 칸 띄운 후에 만들 디렉터리 이름을 입력해주면 된다.

* * *

## Linux 명령어

## Ubuntu

- 먼저 리눅스는 서버 컴퓨터의 운영체제(OS)로서, 클라이언트의 요청에 응답한다.
  리눅스는 무료로 배포되었기 때문에 사람들이 발전시켰고, 리눅스의 유명한 버전 중 하나가 바로 우분투(Ubuntu)이다.
  
  
## command 라인을 배워야 하는 이유
- 백엔드 개발자라면 터미널 윈도우를 이용해서 다른 원격에 있는 서버에 접속한다든지 문제있는 버그를 디버깅하거나 자동화를 위해 스크립트를 작성하는 일이 빈번 할 것이다.


## 개발자라면 알아야 할 Shell 명령어 15가지
- Unix에는 Bourne shell, Bash, fish, zsh 이렇게 다양한 shell들이 있다. Unix shell 명령어를 공부하면 Unix 계열의 Linux나 Mac OS에서도 shell command를 사용하는데 편리하다. 또한 요즘에는 윈도우 안에 Linux가 포함되어져 있기 때문에(WSL) 사용가능하다. 

- Mac OS에서 제공하는 기본 터미널이 아닌 iTerm를 이용해보기.


### Manual
- Shell 커맨드에 대해서 자세히 알아보기 전에 중요한 명령어가 있다.
```terminal
man
```

- man은 Manual 또는 users Manual의 약자인데, 이 명령어가 무엇인지 모르겠거나 어떤 옵션들을 함께 써야하는지 모르겠다 할 때, man 명령어를 이용해서 자세히 알아볼 수 있다. man man 이렇게 입력하면 man 명령어에 대한 설명이 나온다. 해당 화면에서 나가고 싶을 때는 q를 입력하면 된다.

```terminal
clear
```

- 그 다음은 clear 명령어이다. 터미널에 있는 모든 텍스트를 깔끔하게 청소해주는 명령어다. man clear로 clear에 대한 내용도 확인해보자.

### Navigating file system
- 이번에는 파일탐색기처럼 터미널에서 폴더와 파일들을 탐색할 수 있게 해주는 명령어들을 알아보자.

```terminal
pwd
```

- 첫번째로는 지금 내가 어떤 경로에 있는지 알아볼 수 있는 pwd이다. Print Working Directory의 약자로 내가 현재 있는 곳의 전체 경로를 print 해주는 명령어이다. server에서 로그를 남기거나 스크립트를 작성할 때도 많이 사용한다.

```terminal
open .
ls
ls 과제폴더
ls  -l
ls -a
ls -la
```

- 두번째로는 ls 명령어이다. ls 명령어는 현재 디렉터리 안에 있는 폴더와 파일들을 출력해준다. list의 약자이다. 또한, 특정한 폴더 안을 보고 싶을때는, ls 하고 폴더 이름을 적어주면 된다.
- 또한, 파일에 대해서 자세한 내용을 보고 싶다면 ls -l 이렇게 long 포맷이라는 옵션을 이용하면, 파일의 이름과 사이즈, 언제 수정되었는지 그리고 파일을 소유하고 있는 사람의 오너도 확인해볼 수 있다.
- 그리고 UI상에서는 보이지 않는 숨겨져 있는 파일이나 디렉터리도 보고 싶다면, ls -a 즉, all 옵션을 이용하면 숨겨진 파일들도 다 볼 수 있다.
  - 그리고 long 포맷과 all 옵션을 함께 사용하고 싶다면, ls -la를 이용해서 사용할 수 있다.

- open . 을 입력하면 현재 위치한 디렉터리 폴더를, 파일탐색기를 실제로 켜서 보여준다. 여기서 점은 현재 경로를 의미한다.

```terminal
cd 디렉터리 이름
cd ..
cd ~
cd -
```

- cd는 change directory의 약자로 현재 디렉터리 위치를 변경할 수 있다. 그리고 cd .. 은 상위 경로를 의미한다. 
- 또한, cd ~는 현재 설정된 사용자의 home 디렉터리로, 최상위 경로로 이동하게 된다.
- 마지막으로 cd -를 입력하면, 지금 위치로 오기 전에 이전 경로로 이동하게 된다.

```terminal
find . -type file -name "*.txt"
find . -type file -name "*.json"
find . -type directory -name "*2"
```

- find 명령어는 파일 시스템에서 특정한 파일이나 디렉터리를 찾을 때 유용하게 사용할 수 있다. 내가 현재 있는 경로와 그 하위에 있는 모든 폴더에 한해서, 모든 텍스트 파일을 찾고 싶다면 -> find 다음 현재 경로에서부터 시작해서 type은 file이고 이름은 .txt 확장자로 끝나는 모든 파일들에 대해서 찾고 싶을 때 find . -type file -name "*.txt" 이렇게 사용한다. 
  - 만약, 확장자가 json으로 끝나는 파일들을 찾고 싶다면 두번째 명령어를 입력해보자.

- 그리고, 파일이 아니라 디렉터리, 폴더를 찾고 싶다면 find . -type directory -name "*2" 이렇게 해주면 된다. 이름은 2로 끝나는 폴더이다.

```terminal
which python3
which code
```

- 그 다음 명령어는 which이다. which는 내가 지금 실행하고자 하는 프로그램이 어디에 설치되어져 있는지, 어디에 설정되어 있는지 경로를 확인할 때 사용할 수 있다. 그래서 which python3 하게 되면 python3의 실행 경로를 확인해볼 수 있다. which code는 VS code의 경로를 확인할 수 있다.

### Create and manage files
- 이제는 파일을 만들고 경로를 만들고, 파일을 복사 / 이동 / 삭제할 수 있는 명령어를 익혀보자. 또한 모든 파일에 한해서 키워드로 검색하는 방법도 있다.
- UI 탐색기가 아니라, 터미널을 사용하는 가장 큰 장점중에 하나가 마우스를 사용하지 않고 빠르게 일들을 처리하고 확인할 수 있다는 점이 장점이라고 볼 수 있다.

```terminal
touch new_file1.txt
```

- touch 다음에 원하는 파일 이름을 작성하게 되면 -> 새로운 파일을 만들 수 있다. 
- 위와 같이 txt 파일을 만들고 그 내부에 글들을 작성해보자.
  - touch는 파일이 존재하지 않는다면 파일을 만들고, 기존에 존재하는 파일을 touch하게 되면 그 파일에 수정한 날짜가 touch를 한 시점으로 업데이트가 된다.

```terminal
cat new_file1.txt
cat new_file1.txt new_file2.txt
```

- cat 명령어를 이용해서 파일 이름을 입력하면, 파일안에 있는 내용들을 출력해서 볼 수 있다.
- cat 다음에 파일명 1개를 작성해도 되고, cat 다음에 여러개의 파일이름을 작성하면 -> 모든 파일들의 콘텐츠를 한 번에 확인할 수 있다.


```terminal
echo "hello world"
echo "hello world" > new_file3.txt
echo "Hello Brave New World" > new_file3.txt
echo "Goodbye world" >> new_file3.txt
```

- echo 명령어 다음에 ".." 이렇게 문자열을 입력하면, 문자열을 터미널에 메아리 치듯이 출력해준다.
- echo 다음 문자열을 입력하고, 오른쪽 화살표를 입력한 다음 파일명을 작성하게 되면 -> echo 옆에 있는 문자열을 새로운 파일을 만들면서 content로 직접 넣어줄 수 있다.
  - 여기서 한 가지 중요한 포인트는, 오른쪽 화살표 하나만을 이용하면 입력한 문자열을 그대로 새롭게 덮어씌워주는 기능을 하게된다. 즉, 이전에 작성한 내용들이 삭제되고 새로운 문자열이 생성된다.
  - 만약 나는 덮어씌우지 않고 뒤에다가 문자열을 추가하고 싶다면 -> 오른쪽 화살표를 2개 이용해서 파일명을 적어주면 된다.


```terminal
mkdir 원하는이름
mkdir -p div/div2/div3
```

- mkdir은 경로를 만드는 명령어로 make directory의 약자로 디렉터리를 만들 수 있는 명령어이다. mkdir 다음에 원하는 이름을 작성하면, 현재 있는 경로에서 새로운 디렉터리를 생성해준다.
- 만약, 한번에 디렉터리 여러 개를 생성해서 경로를 만들고 싶다면 -> -p 옵션을 이용해서 원하는 경로를 전부 적으면 중간중간 필요한 디렉터리가 자동으로 생성된다.


- **이제, 파일을 관리할 수 있는 3가지 명령어에 대해서 알아보자.**

```terminal
cp file1.txt dir1/
```

- 먼저 cp는 copy의 약자로 cp 다음에 원하는 파일명과 / 원하는 경로를 작성해주면 원래 있었던 해당 파일을 복사해서 지정한 경로로 위치해 준다.


```terminal
mv file2.txt dir1/
mv file3.txt file2.txt
```

- 만약, 복사하지 않고 이동만 시키고 싶다면 move의 약자인 mv를 사용한다. mv 다음에 원하는 파일과 어디로 이동하고 싶은지 경로를 작성해주면 된다.
- 그리고 cp나 mv 모두 새로운 파일로 이동하거나 복사하고 싶다면(?) mv 원하는 파일 대상 파일  이렇게 작성할 수 있다.

```terminal
rm file1.txt
rm -r dir2
```

- rm은 remove의 약자로 파일을 삭제할 때 rm 다음에 원하는 파일 이름을 작성하면 해당 파일을 삭제할 수도 있다.
- rm dir2 처럼, 디렉터리를 삭제하려고 할 때는 경고 메세지가 나온다. 그래서 -r 옵션을 사용해서 삭제해야 한다.


```terminal
grep "world" *.txt
grep -n "world" *.txt
grep -ni "world" *.txt
grep -nir "world" .
```

- grep이라는 명령어는, Global regular expression print의 약자로 우리가 코딩을 할 때 한 파일 안에서 키워드로 검색을 하거나 또는 프로젝트 전체에 한해서 키워드로 검색할 경우가 많이 있을 것이다. 이 때 터미널에서 동일하게 할 수 있는 명령어가 바로 grep이다. 
  - grep 다음에 검색하고자 하는 키워드를 작성하고 특정한 파일을 대상으로 찾고 싶다면, 확장자를 명시해주면 된다.
  - 또한, 검색했을 때 해당 내용이 정확히 몇번째 줄에 있는지 확인하고 싶다면, -n 옵션을 사용해서 확인해볼 수 있다.
  - 그리고, 대소문자 상관없이 다 검색하고 싶다면, -i 옵션을 사용하면 된다.
  - 지금 현재 있는 경로에서, 보통은 현재 프로젝트의 최상위 경로에서 특정 문자를 전부 다 검색하고 싶을 때는 -r 옵션을 추가로 주면 된다. 다만 ni옵션을 같이 주어서 몇번째 줄인지 / 그리고 대소문자 상관없이 검색하고 검색하고자 하는 단어 다음에 현재 경로를 뜻하는 .을 입력해주면 된다. 이렇게 하면, 현재 경로와 그 하위에 있는 모든 서브 폴더에 한해서 해당 문자를 검색할 수 있다.


### Work with environment variables
- 마지막 카테고리로는 환경변수 설정하기이다. 
- **환경변수라는 것은, 내 컴퓨터에서 특정한 키워드가 어떠한 일을 하거나 경로를 저장할 수 있도록 만들고 그렇게 정의해놓은 변수들을 의미한다.**

```terminal
export MY_DIR="dir1"
env
cd $MY_DIR
unset MY_DIR
```

- 유닉스에서는 export라는 명령어를 이용해서 환경변수를 설정할 수 있다. export 다음에 환경변수를 만들어줄 수 있고 보통 대문자로 만들어준다. 그리고 단어 사이사이에 구분자를 넣어줄 때는 _ 이렇게 밑의 대쉬를 이용하고 있다. 위의 예시로 export 다음에 MY_DIR(나의 디렉터리)를 써주고 "dir1" 즉, export MY_DIR="dir1" 이렇게 입력하면 -> MY_DIR은 dir1이다 라고 설정해준 것이다.
- 이렇게 export를 이용하면, 환경변수 즉, 내 컴퓨터 상에 이러한 변수를 설정할 수 있는 것이다.
  - 설정된 모든 환경변수를 보고싶다면, env 명령어를 입력하면 -> 모든 환경변수를 출력해볼 수 있다. ex) 내 맥북에서 env를 입력해보면 -> PATH라는 변수가 python 경로로 정의되어 있다는 것을 확인해볼 수 있다.

- 위에서처럼 MY_DIR이라는 변수를 정의했다면 이제 -> 터미널이나 내 컴퓨터에서 이 MY_DIR이라는 환경변수를 이용하여 dir1를 나타낼 수 있다. 우리가 프로그래밍을 할 때, 변수를 설정하는 것과 똑같다고 보면 된다. 
  - 그래서 터미널에서 cd 다음에 dir1이라고 명시해도 되지만, 지금은 환경변수로 저장을 해놨기 때문에 환경변수를 사용할 때는 -> 달러 싸인 다음에 환경변수 이름을 작성하면 바로 dir1으로 이동할 수 있게 된다.

- 환경변수를 제거하고 싶다면, unset MY_DIR 이렇게 unset 명령어를 이용해서 지정된 환경변수를 삭제할 수 있다.

### Vi, Vim
- 많은 사람들이 터미널을 사용하면서 수정모드에 들어온 건 알겠는데, 도대체 여기서 어떻게 나가는지 힘들어하는 사람들이 많다.
- **Vi 또는 Vim은 터미널에서 많이 이용되는 텍스트 에디터이다.** Vim은 터미널에서 뿐만 아니라, VS Code에서 코딩을 할 때도 유용하게 사용할 수 있다.

- 터미널에서 Git를 사용하거나, 어떤 특정한 파일을 수정할 때 우리가 알게 모르게 Vim를 이용하게 된다. 이 Vim에서 파일을 수정할 때, 어떻게 다시 터미널로 돌아가는지 알아보자.

```terminal
vim file1.txt
```

- 터미널에서 vim 다음에 원하는 파일명을 작성하면 -> 새로운 파일을 만들 수 있고 또한 터미널 화면이 vim 에디터 모드로 들어가게 된다.
<img width="480" alt="image" src="https://user-images.githubusercontent.com/95380638/158926809-7f679a40-1125-4d91-a049-17798eb0cf07.png">

- **이렇게 vim 에디터에 들어왔을 때 어떤 파일을 수정하고 싶다면 -> i를 입력해야 한다.** i라는 insert 명령어를 클릭한 다음에, 글자를 수정하거나 삭제할 수 있다. 
  - 글자를 추가로 입력해서 이제 insert 모드에서 나가려면 -> 키보드 제일 왼쪽에 있는 esc를 누른다. 그리고 :콜론을 누르고 원하는 명령어를 작성하면 된다.
  - :w는 방금 수정한 내용을 꼭 저장해달라는 write changes 의미이다.
  - :q는 꺼달라는 quit의 의미이다. 그래서 파일을 수정하다가 이 수정한 내용은 무시하고 그냥 끄고 싶을 때는 :q를 이용하면 된다.
  - 만약 저장하면서 종료하고 싶다면 -> :wq 명령어를 쓰면 된다.

```terminal
vim file1.txt
```

- 위와 똑같이 vim 다음에 기존에 존재하는 파일명을 입력하면, 터미널 화면이 해당 파일을 수정할 수 있는 화면으로 바뀌게 된다. 
<img width="471" alt="image" src="https://user-images.githubusercontent.com/95380638/158928284-35e797d5-e4c5-43ca-b691-91fab22b6380.png">

- 이렇게 다시 열어서 i를 눌러서 수정할 수 있게 모드를 바꾸고 -> 텍스트를 추가해서 입력한 다음, 저장하지 않고 esc 누르고 :q만 이용해서 종료하려고 하면

<img width="436" alt="image" src="https://user-images.githubusercontent.com/95380638/158928547-ee063e72-9475-4aa3-8660-6951830866c2.png">

- vim이 이렇게 저장하고 있는데 중지하는 게 맞는지 경고를 하게 된다.   
    
- **이 때, 응 맞아 그냥 종료해줘 라고 하고 싶을 때는 -> :q! 이렇게 q 다음 !를 붙여줘야지 강제로 종료가 된다. 그러면 실제로 추가한 내용을 저장하지 않고 끄게 된다.**

- [참고 유튜브](https://www.youtube.com/watch?v=EL6AQl-e3AQ)

* * * 

## Git

- git은 Command line Interface로 명령어를 입력하는 방법과 마우스로 쓸 수 있게 GUI로 만들어진 소프트웨어(ex. Source Tree)를 쓰는 방법이 있다.
1. https://git-scm.com/ 해당 사이트에 접속해서 먼저 git을 설치.
2. IDE라고 불리는 통합 개발 환경을 조성해주는 소프트웨어를 사용 (ex. Vs code)
3. 원하면 마우스로 git을 다룰 수 있게 해주는 SourceTree 홈페이지로 가서 다운로드. https://www.sourcetreeapp.com/


### Git 사용법

**1. Git 저장소 만들기**   
- 터미널을 이용해서 현재 폴더로 이동한 후,
```
git init
```
다음과 같이 입력하면 빈 저장소가 만들어졌다는 메시지가 뜬다. 즉, 해당 폴더가 git의 관리 하에 들어간 것이다.  
그리고 나서는,
```
git config --global user.name "내 이름"
git config --global user.email "내 이메일 주소"
```
이렇게 입력해주면 된다. 그러면 해당 폴더안에 .git 이라는 숨겨진 폴더가 생성된다. 


**2. 현재 시점을 저장하기**
```
git status
```
- 해당 명령어로 현재 git에 담기지 않은 파일들을 확인할 수 있다. (이 파일들이 만들어졌다는 사실을 알 수 있다..?)

```
git add -A
```
- 이렇게 이어서 입력하면, 해당 폴더의 모든 것들을 git의 타임캡슐에 넣는 것이다.
- 이 상태에서 다시 git status를 입력하게 되면 Changes to be committed: 라는 메시지가 뜨게 되고 git에 같이 묻은 것들 이라고 이해하면 된다.

```
git commit -m "해당 커밋에 대한 설명 적기"
```
- 그리고 commit를 할 때 -m을 이용해서 해당 commit에 대한 설명을 적어주자. 이렇게 되면 설명을 붙여서 캡슐을 묻은 것이라고 볼 수 있다.
- 이 상태에서 git status를 입력해보면 -> 담아서 묻을 게 없다고 나온다.
- 그리고 이 상태에서 다시  
  git add -A -> git commit -m "dd" 이렇게 입력해서 -> 변화된 파일들에 대한 commit을 추가로 진행해도 그 이전 작업들이 같이 이어져 온다고 생각하면 된다.

```
git log
```
- 이 명령어를 입력하면, 그동안의 commit 내역들을 확인해볼 수 있다.(캡슐에 담은 정보와 메시지를 확인 가능)
- 그리고 :q를 입력해서 해당 상태에서 빠져나올 수 있다.


**3-1. 과거로 돌아가기 - Reset**
- 과거의 상태로 돌아가는 방법은, 과감한 방법과 신중한 방법이 있다. 
- 과감한 방법은 -> 돌아갈 과거 이후 행적은 복원할 여지 없이 완전히 지우겠다는 것이다. 
```
git log
```
이렇게 입력한 다음, 돌아가고 싶은 시점의 캡슐에서 commit 일련번호의 앞 여섯자리만 복사하고 
```
git reset 앞의여섯자리 --hard
```
해당 명령어를 입력해주면 된다.

그러면 터미널에
```
HEAD is now at 68e22af 연습용 커밋
```
이런식으로 현재 그 시점에 와 있다는 메시지가 뜨고 그 시점 이후에 작업한 파일의 생성 및 삭제 등 모든 내역들이 사라진 것을 확인할 수 있다. 즉, 다시 미래 시점으로 가지 못한다. 


**3-2. 과거로 돌아가기 - Revert**
- 해당 방법은 미래에 한 발을 걸치고 과거로 가는 방법이라고 볼 수 있다.
```
git log
```
이렇게 입력한 다음, 이번엔 돌아갈 시점이 아닌 -> 취소할 시점의 일련번호 앞 여섯자리를 확인하면 된다. 즉, 가장 최근 것을 고르면 된다.
```
git revert 앞의여섯자리 
```
이런식으로 명령어를 입력해주면 새 커밋 메시지를 작성하는 화면이 뜬다. 이 때, 그대로 작성하겠다는 vi 명령어인 :wq를 입력해주자.  
그러면 reset했을때와 마찬가지로 파일들이 과거 상태로 돌아와있는 것을 확인할 수 있다.  
그리고 다시
```
git log
```
입력해서 기록을 보면, 우리가 선택한 취소할 시점 이후 -> Revert "ddd" 이렇게 뜨면서 새로운 캡슐이 묻힌 것을 볼 수 있다. 즉, 시점을 취소하기 위해 그 내역과 반대되는 새로운 캡슐을 묻은 것이라고 볼 수 있고 다시 원하는 과거로 다시 돌아갈 수 있다.


**4-1. branch 사용해보기**
- 현재 진행하고 있는 프로젝트가 있지만, 뭔가 다른 시도를 해보고 싶을 경우가 있을 것이다. 그렇다고 기존의 프로젝트 파일들을 함부로 변경할 수는 없다.  
- 그럴 때는 다른 평행우주를 만들어서 사용해보자.
```
git branch 이름적기
```
이렇게 입력하면 기존의 master에서 -> 새로운 이름을 가진 branch가 생성된다.  
branch는 가지라는 뜻으로 현 시점에서 두 미래로 분기하겠다는 의미. 가지를 하나 만든 상태에서
```
git branch
```
이러한 명령어를 입력하게 되면
```
* master
  my-idea
```
다음과 같이 기본 branch인 master와 새로 만든 branch인 my-idea를 나타내준다.  
그래서 새로 만든 branch로 넘어가려면 
```
git checkout 새로만든branch이름    ex.) git checkout my-idea
```
이렇게 입력하면
```
Switched to branch 'my-idea'
```
이렇게 터미널에 뜨게 된다.  
그리고 새로 만들어지는 branch는 원 branch의 현 상태를 그대로 가져오게 된다. 새로 만든 branch에서 작업을 진행해보고 
```
git add .   or    git add -A
git commit -m "새로운 branch 작업"
```
이렇게 다시 캡슐에 묻어보자.


**4-2. 기존 branch로 돌아가기**
- 한창 나만의 branch에서 작업하고 있는 도중에, 다시 원래 branch로 돌아가야 한다면
```
git checkout 이동할branch이름   ->  여기서는 git checkout master
```
이렇게 입력해주면 원래 branch로 돌아갈 수 있다.


**5-1. 다른 branch에서 가져오기**
- 다른 branch에서 작업한 내용들을 기존의 master branch로 가져와보자.
```
git checkout master
```
먼저 master branch로 돌아온다.
```
git merge 가져올branch이름   ex.) git merge my-idea
```
이렇게 입력해서 변화를 가져올 branch이름을 입력해주고 vi화면에서
```
:wq
```
맨 위에 적힌 것을 그대로 쓰도록 :wq를 입력해준다.  
이렇게하면 master branch에 다른 branch에서 작업한 내용이 덮어쓰여져서 보여지게 된다. 이 상태에서
```
git log --graph --all --decorate
```
이 명령어를 입력하면 시각화된 작업내역을 확인할 수 있다.


**merge가 충돌하는 경우**
- 예시를 들어보면, master branch와 다른 branch에서 모두 같은 파일에 동일한 내용을 수정하는 경우에는 merge를 했을 때 충돌하는 경우가 발생할 수 있다.
- 따라서, 최대한 다른 branch에서는 같은 파일을 수정하는 일을 피해서 작업할 수 있도록 조심해야한다.


**5-2. 다른 branch에서 가져오기 - Rebase**
- 실제 프로젝트에서는 branch의 생성 및 변경이 굉장히 복잡하게 구성되어 있다. 
- 이럴 때, 모든 변경 내용들이 한줄로 딱 깔끔하게 정리됐으면 좋겠다 싶을 때는 -> merge 대신 rebase를 사용하자.
```
git rebase 가져올branch이름    ex.) git rebase my-idea
```
이렇게 기존의 master branch에서 '병합' 대신 '재배치'를 선택하면 가지들이 깔끔하게 한 줄로 보여지게 된다.  
프로젝트나 팀의 성격에 따라 merge나 rebase를 선택하면 된다.


**6. 다 사용한 branch 삭제하기**
- 다 사용한 branch를 삭제하고 싶을 때는 
```
git branch -D 브랜치이름
```
해당 명령어를 입력하면 된다.


- [참고 자료](https://git-scm.com/book/ko/v2)

* * * 

## Git remote url 변경
- 먼저 해당 디렉터리 위치에서 

```terminal
git remote -v
```

- 해당 명령어로 지금 설정 되어있는 remote url를 확인할 수 있다. 그리고나서 해당 remote url를 변경하고 싶을 때는,

```terminal
git remote set-url origin 변경할url주소
```

- 이렇게 remote url를 변경할 수 있다.

- [참고 블로그](https://devpouch.tistory.com/23?category=1023131)

* * *

## Github이란
- Git으로 관리한 내용들을 Github을 사용하여 온라인에 업로드해서 보관하고 다른 사람과 협업하는 과정을 다뤄보자.
- Git에서 commit을 통해 -> 나의 프로젝트를 local 저장소에 반영했고 -> push를 통해 local 저장소의 내용을 원격 저장소에 반영하자.
- Git을 사용해서 클라우드를 쓰듯이 소스들을 업로드해서 저장하고 다른 개발자들과 공유할 수 있는 Git 저장소들 중, 대표적인 것으로 Bitbucket, Gitlab, Github 등이 있다.

* * * 

**1. Github 저장소 만들기**
- github 계정을 만들고 로그인 이후에 Create a new repository를 클릭하면 -> Git으로 관리되는 프로젝트 폴더 하나가 원격으로 저장되는 공간이 생성된다.
- 이 때, Public를 선택하면 Github에 접속한 모든 사람들이 내 코드를 방문하거나 검색할 수 있다. 
- Private은 나, 그리고 내가 이 레파지토리에 초대한 특정 사용자들만 볼 수 있다.
- 오픈소스로 만들어서 사람들에게 공유하고 도움이나 참여를 받으려면 혹은 기업들에게 공개할 내 포트폴리오로 사용하려면 Public을 선택하자.
- 해당 사항들을 선택하여 저장소를 생성.
  - Github repository의 url은 -> https://github.com/username/레파지토리명  이렇게 설정된다.


**2-1. Github에 소스 올리기**
- 이제 자신의 프로젝트를 새로 생성한 레파지토리에 올려보자.
```
git status
```
해당 명령어로 현재까지의 사항들이 모두 commit 되어있는지 확인하기. 여기서 빠진 게 있다면 전부 add해서 commit을 먼저 진행하자.
```
git remote
```
이 상태에서 위의 명령어를 입력하면 현 폴더의 원격 레파지토리를 확인할 수 있는데, 아직 설정한 게 없다면 아무것도 뜨지 않을 것이다.  
이제 github에서 만든 새로운 레파지토리를 원격 저장소로 추가해보자.
- https://www.yalco.kr/_02_github_token/  

해당 내용을 통해 먼저 Personal access token를 생성해주자. 그 이후에는
```
git remote add origin 새로만든github주소
```
이 명령어는 새로 만든 github 레파지토리를 본인의 local 프로젝트의 'origin'이란 이름의 원격 저장소로 설정하겠다는 의미이다.  
이 'origin'은 원하는 다른 이름으로 수정해도 되나 Git 초기화 시 기본 브랜치명이 master인 것처럼 흔히 기본값으로 사용되는 이름이라고 생각하면 된다.
```
git push -u origin master
```
이 push 명령어는 프로젝트 폴더의 현 브랜치에 commit된 내용들을 origin이라는 이름의 원격 레파지토리에 진행하고 원격 레파지토리의 master라는 이름의 브랜치를 올리겠다는 의미이다.  
해당 명령어를 다 입력하고 나면
```
Branch 'master' set up to track remote branch 'master' from 'origin'.
```
다음과 같은 내용이 뜨면서 local 컴퓨터의 master branch가 origin이라는 원격 저장소의 master branch를 추적한다고 나온다.  
그리고나서 github에 가보면 -> local로부터 push한 파일들이 올라와 있고 / 각 파일들이 어떤 commit에서 마지막으로 생성되었거나 변경되었는지 나와있다.  
파일명을 클릭하면, 파일의 내용을 볼 수 있고 / commit 메시지를 클릭하면, 해당 commit에서 어떤 변화들이 있었던건지 확인할 수도 있다.
```
git remote
```
다시 입력해보면, 이제는 origin이라는 추가한 원격 레파지토리의 이름이 나오게 된다.


**2-2. 변화된 내용을 다시 push하기**
- 자신의 프로젝트에서 작업을 하고 변경된 내용을 github에 push해보자.
```
git add -A
git commit -m "새로운 파일 추가"
```
이렇게 변경된 파일을 local에서 추가하고 다시 commit한 다음
```
git push origin master
```
라고 입력해주면 github에 추가된 내용을 확인할 수 있다. 


**3. 다루지 않을 파일 설정하기 - .gitignore**
- 프로젝트를 진행할 때, Git으로 관리하고 Github에 올릴 필요가 없거나 오히려 그래서는 안 되는 파일들이 있을 수 있다.
- 코드를 실행하면 패키지가 다운받아지거나 코드대로 빌드되어서 자동으로 생성되는 파일들은, 어차피 코드만 있으면 그 때마다 실행해서 만들 수 있기 때문에 굳이 Git에 무리를 주거나 Github 용량을 차지할 필요가 없다.
- 또한, 보안적으로 중요한 내용 / 예를 들어 데이터베이스 계정 등이 담긴 파일은 오픈소스 프로젝트라도 대중에게 공개되면 안 된다.
- 이럴 때 사용되는 게 바로 **.gitignore 파일** 이다.

1. 프로젝트 폴더 바로 안쪽, 최상위에 .gitignore라는 파일을 생성한다. 해당 파일은 숨김파일로 지정된다. 
  - https://www.atlassian.com/git/tutorials/saving-changes/gitignore 여기에서 Git 관리에서 제외시킬 파일이나 폴더, 기타 요소를 지정하는 형식이 나와있다.

2. 새롭게 파일을 추가하고 해당 파일의 이름을 .gitignore라는 파일안에 입력해준다. **주의할 점은 .gitignore라는 파일을 생성한 다음에 추가된 파일에 대해서만 적용이 된다.**
   - ex) .gitignore 파일안에 ajajaja.py 이렇게 입력

3. 그리고나서
```
git status
```
라고 입력해봤을 때, 해당 파일은 commit 해야할 목록에서 없어진다. 이 상태에서
```
git add -A
git commit -m "gitignore사용"
```
이렇게 입력하고 
```
git push origin master
```
github에 push까지 해주면 우리가 .gitignore파일에 적어두었던 python 파일은 github에 push가 되지 않는다는 것을 확인할 수 있다.  
안드로이드나 스프링 등 처음부터 골격이 세팅된 프로그래밍 프로젝트를 생성하면, 이 .gitignore파일을 확인해볼 수 있다. 그래서 해당 내용은 github에 올릴 필요가 없는 내용들이고 빌드하면 만들어지는 것이거나 컴퓨터 IDE 세팅이라는 것 등을 파악할 수 있다.


**4. Github 소스 내려받기**
- 이제 Github에 올린 소스들을 내 컴퓨터에 다운받아보자.
- 레파지토리가 Public이라면 누구나 가능하고, 집에 있는 Mac으로 작업해서 Github에 올린 소스들을 회사의 컴퓨터에서 다운받는다고 가정해보자.

- 레파지토리 페이지에서 Code 라는 버튼을 클릭하고 -> 해당 레파지토리의 주소를 복사한 다음 
```
git clone 복사한주소     ex.) git clone https://github.com/tkdqor/likelion.git
```
터미널에 입력해보자. 그러면 **해당 레파지토리명의 폴더**가 생긴 것을 볼 수 있다. 


**5. 작업 주고받기**
- commit 메시지는 팀원들과 협업할 때, 이번 커밋에서 어떤 변화들이 주어졌는지 간략히 알려주는 역할도 수행한다.  
  구글에 "commit 메시지 작성법"도 찾아보자.

- 만약, 다른 팀원이 우리가 같이 작업하고 있는 레파지토리에 push를 진행했을 때 -> 우리가 확인하는 방법이 있다.
```
git fetch
```
이 명령어를 입력한 후에,
```
git status
```
을 입력해보면
```
... Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded.
```
이렇게 이 브랜치가 원격 origin의 master 브랜치에 커밋 하나가 뒤쳐져 있다고 나오게 된다. 즉, Github에서 다운받아야 할 사항이 있다는 얘기이다. 그러면 받아보자.
```
git pull 원격명 브랜치명        ex.) git pull origin master
```
이 명령어를 입력한 이후에는 변경사항이 새롭게 다운된다.

- 이렇게, Git과 Github을 사용해서 원격으로 협업할 때는 뭔가 작업하거나 push하기 이전에 먼저 해당 과정을 거쳐서 다운받아야 할 사항이 있는지 확인하고 있으면 pull를 해주고 작업을 하는 게 좋다.  
  - 팀원이 작업한 내용들을 꾸준히 업데이트 받아야 괜한 작업을 하거나 conflict가 나는 일을 방지할 수 있다.
  - 그리고 Github에 다른 누군가가 올린 내역을 pull로 다 업데이트 받기 전까지는 내쪽에서 push를 할 수 없다. / 관련 [오류 링크](https://github.com/tkdqor/TIL/blob/main/%EC%98%A4%EB%A5%98%EB%AA%A8%EC%9D%8C%EC%A7%91/github%20push%20%EC%98%A4%EB%A5%98.md)


**6. branch 주고받기**
- local 환경에서 다른 branch로 checkout된 상태에서, 작업을 한 뒤 해당 branch에서 github으로 push하는 경우
```
git push origin 새로운branch명     ex.) git push origin my-idea
```
이렇게 입력하고 난 뒤, Github페이지에서 branch를 눌러보면 my-idea라는 새로운 branch가 새로 생겨나게 되고 선택하게 되면, local의 새로운 branch상태가 새롭게 반영이 된다.

- 내가 공동으로 작업하고 있는 하나의 레파지토리의 master가 아닌 다른 branch를 다운받아보자.
- 먼저
```
git fetch
```
해당 명령어를 입력해보면, 새로운 branch가 만들어졌다는 메시지가 뜬다.
- 그리고 원격에 어떤 branch가 있는지 확인해야 한다. **git branch**는 local에서의 branch만 볼 수 있지만, 
```
git branch -a
```
이렇게 터미널에 입력하면 
```
remotes/origin/my-idea
```
이런식으로 원격 저장소의 다른 branch를 확인할 수 있다. 이걸 local로 가져오기 위해서는,
```
git checkout -b my-idea(새롭게만들branch이름) origin /my-idea(원격에있는branch이름)
```
해당 명령어를 입력하면, local에 my-idea라는 이름으로 branch를 새롭게 만들고, 원격의 my-idea라는 branch의 내용을 받아와서 새롭게 만든 my-idea branch로 들어간다는 의미이다.
```
git branch
```
이 명령어로 local에서도 my-idea라는 branch가 생성된 걸 확인할 수 있다.


**7. 충돌 해결하기**
- Gitf를 사용하면서 익혀나갈 때, 많은 사람들이 어려워하고 부딪치기 싫어하는 이유가 충돌이 발생하는 경우 때문이다.
- branch간에도 발생할 수 있지만, 같은 branch에서 같은 파일의 같은 부분을 원격의 두 컴퓨터가 같이 건드린 상황에서도 발생할 수 있다. 
  - push 하기 전에 먼저 github의 내용을 pull 하려고 하는데 내가 똑같은 파일을 수정했다면, 해당 파일을 충돌하지 않도록 수정한 다음 저장해주고 다시 진행하면 된다.


**8. 원격의 branch를 지우는 경우**
```
git push -d 원격명 브랜치명       ex.) git push -d origin my-idea
```
이렇게 입력해주면 삭제가 된다.


* * *

## 비전공자를 위한 이해할 수 있는 IT 지식 요약 내용

- 개발자는 컴파일러에게 문서로 일을 시키는 사람, 프로그래밍 언어를 통해 운영체제 위에 돌아가는 프로그램을 만드는 사람이다. 프로그래밍 언어를 사용해 컴파일러에게 명령을 전달하면, 컴파일러가 코딩한 문서를 기계어인 0과 1로 변환해 컴퓨터에게 전달을 하게 된다.

- **IDE**란, Integrated Development Environment의 약자로 통합 개발 환경이라고 하는 프로그램을 의미. 개발을 하기 위한 모든 것들을 제공해주는 환경이라고 보면 된다. 대표적으로 vs code가 있다.

- 프로그래밍 언어를 구분하는 기준 중 하나는 '저수준'과 '고수준'이 있다. '저수준'은 컴퓨터 친화적인 언어를 의미하고 / '고수준'은 인간 친화적인 언어를 의미한다.
  - **'저수준'** 언어는 컴퓨터가 어떻게 일해야 하는지 구체적으로, 꼼꼼하게 적어줘야 하기 때문에 배우기 쉽지 않다. 대신 낮은 사양의 컴퓨터에서도 작동할 수 있다.
  - **'고수준'** 언어는 학습하기 쉽다. 컴퓨터에게 꼼꼼하게 설명하지 않아도 된다. 하지만 그만큼 작동이 느리다. 

- 컴퓨터의 구성은 **CPU / 메모리(RAM) / HDD(하드디스크) 또는 SSD라고 불리는 보조기억장치**로 구성되어 있다. 이 부품들을 **메인보드**에 설치하면 컴퓨터가 된다.
  - CPU는 따로 데이터를 저장하지 않기 때문에 데이터를 연산하거나 처리하려면 저장된 데이터를 CPU로 보내줘야 한다. 그래서 CPU는 창고 역할을 하는 보조기억장치에 신호를 보낸다. 하지만 데이터가 많기 때문에 작업시간이 오래 걸리게 되고, 그래서 메모리가 생기게 되었다. 작업이 필요한 큰 데이터 뭉치를 보조기억장치에서 메모리로 한 번 옮겨놓고 CPU는 메모리 안에서만 작업을 진행하면 된다.
  - ex) 포토샵 프로그램을 실행하는 경우를 예로 들면, 포토샵은 윈도우 기준으로 'C 드라이브 - Program files - Adobe - Photoshop'에 저장되어 있다. 보통 우리는 바탕화면에 있는 포토샵 아이콘인 포토샵 실행 파일의 바로가기를 더블클릭해서 실행하게 되는데, 이것은 보조기억장치에 저장된 프로그램을 실행하는 것과 같다. 그리고 바로 실행되는 게 아니라, 로딩 화면이 뜨고 시간이 걸리게 되는데 -> 이 과정이 보조기억장치에서 실행에 필요한 데이터가 메모리로 올라가고 있는 것이다. 이 과정이 끝나면 CPU가 메모리 위에서 빠르게 작업을 할 수 있기 때문에 우리가 포토샵에서 빠르게 작업할 수 있는 것이다.

- 위의 복잡한 과정을 모두 대신 진행해주는 소프트웨어가 바로 **'운영체제(Operating System)'** 이다. 대표적으로 윈도우, 맥 OS, iOS, 안드로이드가 있다. 윈도우와 맥 OS는 PC에서 / iOS와 안드로이드는 모바일에서 사용된다. 이러한 운영체제는 우리 대신 하드웨어를 관리해준다. 하드웨어의 용량을 확인하고 다양한 소프트웨어를 손쉽게 설치할 수 있게 해준다. 윈도우는 마이크로소프트 / 맥 OS와 iOS는 애플 / 안드로이드는 구글에서 만들었다. 이러한 회사에서 사용하는 운영체제 위에 돌아가는 프로그램을 만들기 위해서는 각자 다른 언어를 익혀야 한다. 애플은 Objective-C 또는 스위프트라는 언어를, 구글은 자바 또는 코틀린이라는 언어를 사용해야 한다.

- **LAN(Local Area Network)**: 컴퓨터가 연결된 작은 지역을 의미. 학교 컴퓨터실 하나, 아파트 하나, 커피숍 하나한가 모두 LAN이다. LAN을 연결하는 선을 LAN선이라고 부른다.

- **MAN(Metropolitan Area Network)**: 도시의 여러 LAN을 하나로 연결한 구성.

- **WAN(Wide Area Network)**: 도시와 도시, 나라와 나라를 모두 연결해서 구성.

- **카카오톡을 다운로드하는 과정**
  - 앱스토어에서 카카오톡을 검색하고 다운로드 버튼을 누르면 -> 가까운 기지국으로 카카오톡 설치 파일을 보내달라는 신호가 가게 된다. 신호는 WAN을 따라 이동한다. 앱스토어이기 때문에 애플이 가지고 있는 서버 컴퓨터에게 신호가 간다.
  - 애플의 서버 컴퓨터에서 카카오톡 설치 파일을 우리의 스마트폰으로 다시 보내준다. 이후 우리가 스마트폰에서 앱을 터치해 실행하면 -> 보조기억장치에 카카오톡 실행 파일들이 저장되고, 실행에 필요한 데이터들이 메모리 위로 올라가게 된다. 그리고 CPU가 이 데이터들을 처리하면서 카카오톡을 우리가 사용할 수 있게 된다.

- 스마트폰으로 또는 컴퓨터로 파일을 달라고 요청하는 쪽을 '클라이언트' / 파일을 주는 카카오톡 컴퓨터를 '서버'라고 한다.

- **리눅스**는 하나의 운영체제(OS)이고, 리눅스 위에서 '서버 프로그램'을 돌리게 된다. 리눅스는 기본적으로 무료이다. 그래서 다양한 버전의 리눅스가 발전되었는데, 그 버전 중 유명한 버전이 바로 **'우분투(Ubuntu)'** 이다. 또 다른 버전으로는 레드햇(Red hat) 리눅스가 있다. 레드햇은 리눅스를 개량해서 유료로 판매하는 회사이다. 수많은 회사의 운영체제 품질을 보장해주는 역할을 해준다.

- 윈도우나 맥 OS와 같은 운영체제는, 폴더나 휴지통과 같이 **그래픽 UI**가 있어 쉬운 방법으로 컴퓨터를 활용할 수 있지만 서버의 리눅스 운영체제는 이러한 그래픽 UI가 필요하지 않다. 그래서 대다수의 리눅스 버전들은 그래픽 UI 없이 명령어로만 동작을 시키게 된다. 

- **개인이 서버를 운영한다면?**
  - 우리가 컴퓨터를 구매해서 집에서 쇼핑몰 서버를 만든다고 한다면, 일단 운영체제를 설치하고 서버 프로그램을 만들어서 실행시킨다. 이렇게 24시간 계속 돌리면 항상 운영되는 서버가 된다. 하지만 전기세가 많이 나갈 것이고, 갑자기 정전이 되어 전원이 꺼지면 서버가 정지된다. 그러면 고객들의 컴플레인이 발생할 것이다. 만약 서버 컴퓨터가 고장나서 저장장치도 복구할 수 없다면 회원 정보, 결제 정보, 배송 정보, 상품 정보 등 소중한 데이터들을 복구 할 수 없을 수도 있다. 
  - 그래서 이러한 일들을 대신해주는 서비스를 제공하는 업체가 생겨났는데, 바로 **'호스팅 업체'** 라고 한다. 대표적으로 Cafe 24, 가비아 등이 있다. 해외에는 대표적으로 **아마존의 AWS**가 있으며, 서버 컴퓨터를 대여해주고 다양한 분야의 기업들에게 솔루션을 제공하고 있다.  ex) 에이블리도 서버 컴퓨터를 AWS를 통해서 24시간 돌리고 있는 것이다.


