


## 클라이언트 요청부터 서버의 응답까지 전체 과정(아직 확실한지 모름)
- 클라이언트 요청 -> 미들웨어 -> 웹서버(static파일 처리, nginx) -> gunicorn(웹 서버와 django 서버 통신하기 위한 인터페이스) -> 앱서버(django서버, API서버) -> Celery(broker - worker) -> (존재하는 경우)캐시 서버(redis) -> (DB정보가 필요한 경우)데이터베이스 서버 
- 엘라스틱 서치는 어떤 위치에 있는걸까?



## Web 서버 동작 과정
- **우리가 웹브라우져에서 들어가고 싶은 웹페이지의 주소를 쳤을때, 그 요청이 서버 컴퓨터로 가지면 해당 서버 컴퓨터의 웹 서버라는 프로그램(소프트웨어)은 서버 컴퓨터에 저장되어있는 웹페이지 파일 중 요청과 맞는 파일을 골라 다시 우리 웹브라우져로 넘겨준다. 이 때 이 주고받는 과정들은 HTTP 규약에 따라 진행된다. 하지만, 위의 구조로는 우리가 원하는 모든 웹페이지를 받아볼 수 없다.**
  - 웹페이지는 "정적 페이지"와 "동적 페이지"로 구분될 수 있다. 
  - 정적 페이지는 웹브라우저(클라이언트) 요청에 항상 같은 내용을 표시하는 웹페이지이다. 서버에 이미 저장된 html, css, javascript 파일들로 구성되어있다. 누가 언제 들어가든 항상 똑같은 내용이다.
  - 동적 페이지는 요청하는 클라이언트마다 각각 다른 내용이 표시되는 웹페이지이다. 로그인 정보, 장바구니, 게시판 등 이러한 동적 페이지를 제공하기 위해선 해당 클라이언트에게만 제공되는 정보를 저장한 데이터베이스의 연동이 필요하다. 
- **웹 서버의 경우 -> 정적 페이지만 처리할 수 있다. 그래서 별도의 동적 페이지를 처리해줄 수 있는 소프트웨어 프로그램이 필요하다.**
- **그래서 등장한 것이 CGI(Common Gateway Interface)프로그램으로, C, C++, PERL, PHP, PYTHON 등의 언어로 만들어졌다. 이 프로그램은 DB관련 로직을 처리하고 동적 페이지를 만들어 웹 서버에게 넘겨준다.**
  - 이 때, 이 CGI프로그램과 웹서버가 정보를 주고받는 규칙을 정의한 것이 CGI 규격이다. 
  - 그러나, 전통적인 CGI방식에서는 동적 처리를 진행할때마다 개별 독립적인 프로세스를 생성하는 방식이어서 요청이 많아질 경우, 프로세스 수가 증가해 서버 컴퓨터의 메모리량이 커지고 시스템 부하 현상이 발생헀다. 
- **위의 이유로 현재는 CGI기술을 사용하지 않고 다른 방법들을 사용한다.**
- **그 다음 등장한 것이 바로 애플리케이션 서버(Web Application Server(WAS))이다. 나의 경우, Django 서버라고 보면 된다.**
  - 동적 처리를 하는 응용 프로그램들을 따로 실행할 수 있는 서버를 만들어서 사용하는 방식이다. 
  - 클라이언트가 동적 페이지를 요청했을 때, 웹 서버는 요청을 받아 애플리케이션 서버에게 처리를 위임한다. 그리고 애플리케이션 서버는 동적 처리를 해주는 프로그램들을 실행시켜 DB로부터 원하는 결과를 처리한 후, 다시 웹 서버에게 넘겨주고 웹 서버는 클라이언트에게 결과를 보여준다.
  - 이렇게 서버를 2개로 구분한 이유는, 서로의 역할 구분하는 것이 더 효율적이기 때문이다.
- **오늘날 두 서버는 점점 더 전문화되는 방향으로 발전하고 있다. 웹 서버는 정적 페이지 제공 / 캐시 기능 / 프록시 기능 / http/https의 제어에 필요한 기능 등을 제공한다.    
  웹 애플리케이션 서버는 웹 서버와의 연동 규격을 잘 따르기만 하면 임의의 언어 플랫폼을 사용할 수 있어 많은 종류의 서버가 생겨났다. 자바, python 등**
  - 이러한 2개의 서버를 하나의 하드웨어에서 사용하는 것 보다 나눠쓰는 것이 메모리 효율이 높아지므로 대규모 사이트의 경우, 각각의 서버를 각각의 하드웨어에 설치해서 사용하기도 한다.

- **추가로 django의 경우, Django REST Framework를 설치하여 API 서버를 구축할 수 있다. 이러한 API 서버는 운영과 유지보수를 위해 WAS 서버와 따로 분리하여 운영하는 것이 일반적이다.**

- 참고 블로그 : https://iamrealizer.tistory.com/6

<br>

## Celery 관련 내용
- Celery란, python으로 작성된 비동기 작업 큐로, 비동기로 작업을 처리해서 응답시간을 줄일 수 있다. 무거운 작업들을 Celery Task로 정의해서 Message Broker(요청한 작업들을 담아두는 큐)에서 Task를 받고 여러 Celery Worker에게 적절히 분배하여 일을 수행하게 된다.
- [Celery 동작 구조](https://velog.io/@sms8377/Celery-Python-Celery%EB%9E%80)
- [Celery 예시](https://velog.io/@nameunzz/Celery-Redis)





## call by reference가 무슨 말인가요?
- 함수의 호출 방법은 대표적으로 Call by value(값에 의한 호출)와 Call by reference(참조에 의한 호출)가 있다.
- 함수 호출이란 말 그대로 정의된 함수를 호출하는 것으로 함수에 정의한 매개변수의 형태에 따라 Call by value 혹은 Call by reference인지 결정된다.
- **Call by value란, 함수 호출 시 넘기는 인자(함수가 호출될 때 매개변수에 실제로 담기는 값)의 값이 매개변수에 복사(Copy)돼서 함수 내에서 매개변수(매개변수란, 함수를 정의할 때 사용되는 변수)에 직접적인 데이터 조작을 가해도 인자에 전혀 영향을 주지 않는 것이다. 즉, 값을 복사를 하여 처리한다는 것이다.**
  - **매개변수는 그 값이 Stack에 할당**된다. Stack이란, 메모리의 스택(stack) 영역으로 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다.
  - **그래서 원래 값이 보존된다는 장점이 있다. 단, 복사하기 때문에 메모리 사용이 늘어난다.**

- **Call by reference란, 인자의 값이 매개변수에 복사(Copy)된다는 점은 동일하다. 다만 복사되는 값이 데이터의 주소 값이라는 차이점이 존재한다. 쉽게 말하면 Call by reference란, 말 그대로 참조값으로 함수를 호출했단 뜻이다. (여기서 참조라는 개념이 우리가 잘 알고 있는 포인터이다) 즉, 직접 참조를 하는 것이다.**
  - 중요한 차이점은 함수를 정의할 때 매개변수가 포인터 변수로 정의되었단 점이다. 즉, 변수의 주소를 인자로 받는 것이다. 그래서 주소에 저장된 값에 직접 접근할 수 있게 된다.
  - **그래서 직접 참조해 빠르다는 장점이 있다. 단, 원래 값에 영향을 받게 된다.**

- 참고 자료 : https://kangworld.tistory.com/64
  - https://bskyvision.com/795
  - https://codingplus.tistory.com/29


## Event Listener가 무슨말인가요?
- **이벤트 리스너란 이벤트가 발생했을 때 그 처리를 담당하는 함수를 가리키며, 이벤트 핸들러(event handler)라고도 한다.**
- DOM 객체에서 특정 이벤트가 발생하면 이벤트 리스너를 이용해서 특정 함수를 호출할 수 있다.
  - DOM은 Document Object Model의 약자로 document라는 변수로 html 문서를 객체로 인식하여 문서 내 모든 요소에 접근할 수 있도록 하는 방법을 의미한다.

- 참고 자료 : http://www.tcpschool.com/javascript/js_dom_concept
  - http://www.tcpschool.com/javascript/js_event_eventListenerRegister


## OOP에서 상속이 무슨말인가요?
- 일단 **OOP란, Object Oriented Programming의 약자로 객체지향 프로그래밍을 의미**한다. 객체 지향 프로그래밍은 클래스와 객체를 사용하여 프로그램을 설계하는 방법론으로 특징으로는 캡슐화, 추상화, 다형성, 상속성을 가진다.
- **그 중에서 상속이란, 기존 클래스의 속성과 메서드를 사용하여 새 클래스를 만드는 것으로 새롭게 만든 클래스에 기존 상위 클래스의 기능을 가져와서 재사용하거나 새로운 기능을 추가할 수 있게 만들어주는 개념이라고 볼 수 있다.**
  - 이러한 상속은 코드 재사용에 상당히 유용하다.

- 참고 자료 : https://limkydev.tistory.com/30
  - https://ko.strephonsays.com/polymorphism-and-vs-inheritance-in-oop-12018


## non-blocking call이 뭔가요?
- **non-blocking 방식은 I/O작업을 진행하는 동안 유저 프로세스의 작업을 중단시키지 않고, 유저 프로세스가 I/O를 처리하기 위해 커널에 함수를 호출하는 system call이 진행되면 커널에서 함수의 진행 상황과 상관없이 바로 결과를 반환하는 것을 의미한다.**
- 즉, 애플리케이션 실행 시 운영체제 대기 큐에 들어가지 않고 실행 여부와 관계없이 바로 응답을 보내는 경우를 의미한다. 
  - 다른말로 하면 호출된 함수가 바로 리턴해서 호출한 함수에게 제어권을 넘겨주고, 호출한 함수가 다른 일을 할 수 있는 기회를 줄 수 있다면 non-blocking 방식이다.

- **I/O란,** 입력(Input)/출력(Output)의 약자로 컴퓨터 및 주변장치에 데이터를 전송하는 프로그램, 운영 혹은 장치를 일컫는 말이다. 키보드와 마우스처럼 입력을 위한 기기, 프린터처럼 출력에만 사용되는 기기 등 다양하다.
- **커널이란,** 메모리에 상주하는 운영체제의 일부분을 의미.

- 참고 자료 : https://yoonucho.github.io/review/2019/02/26/sync_async_blocking_non-blocking.html
  - https://asfirstalways.tistory.com/348


## 버전관리에서 commit이 뭔가요?
- **commit은, 파일 및 폴더의 추가/변경 사항을 저장소에 기록하기 위해 commit이라는 버튼을 눌러서 변화에 대해 기록하는 것이다.** commit은 특정 소스가 변경된 이유를 메시지로 입력해 버전을 관리해 나갈 수 있다. 이러한 commit 기록을 관리하면 과거의 변경이력과 내용을 파악할 수 있다.

- 참고 자료 : https://steady-coding.tistory.com/277
  - https://backlog.com/git-tutorial/kr/intro/intro1_3.html
  - 해당 자료 꼭 다시 읽어보기 : https://sabarada.tistory.com/71


## try/catch는 무슨 뜻인가요?
- **try/catch문은 코드 상의 논리적인 문제가 있어 '예외'가 발생하는 경우, 이러한 예외 처리를 명시적으로 표현할 수 있게 해주는 코드이다.**
- 먼저 try 안의 코드가 실행되고 에러가 없다면 catch 블록을 건너뛰게 된다. 에러가 있다면 try안의 코드가 실행이 중단되고, catch 블록에서 해당 에러에 대한 처리를 진행해 나갈 수 있게 된다.
- 참고 자료 : https://ko.javascript.info/try-catch
  - https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=mdown&logNo=221347592097


## 디버깅할 때 breakpoint가 뭔가요?
- **breakpoint는 디버깅을 목적으로 실행중인 디버깅 대상 프로세스를 의도적으로 멈추게 하는 장소를 가리킨다.** 
- 프로세스가 멈추면 멈춘 시점의 변수나 스택 파라미터, 혹은 특정 메모리 지점의 값 등을 조사할 수 있다.

- 참고 자료 : https://to-paz.tistory.com/106


## 패스워드는 서버에 어떻게 보관되나요?
- **단방향 해시 함수를 사용하여 패스워드를 암호화해서 보관한다.**
- 단뱡향 해시 함수는 어떤 수학적 연산이나 알고리즘에 의해 원본 데이터를 매핑시켜 완전히 다른 암호화된 데이터로 변환시키는 것을 의미한다. 이 변환을 해시라고 하고, 해시에 의해 암호화된 데이터를 다이제스트(digest)라고 한다. 이렇게 DB에 저장된 다이제스트는 DB가 해킹당한다 하더라도 단방향으로 해싱된 문자이기 때문에 복호화를 할 수 없다.

- 참고 자료 : https://st-lab.tistory.com/100


## SSD가 HDD보다 빠른 이유가 뭔가요?
- **HDD는 데이터를 읽거나 쓸 때 스핀들 모터로 원판을 돌리고 헤드가 그 위를 헤집어야 하는 물리적 작동이 필요하지만, SSD는 그러한 과정이 생략되어 움직이는 부품이 없어 속도가 빠르고 전력 소모량이 적고 내구성과 신뢰성도 높다.**
- HDD는 하드디스크드라이브(Hard Disk Drive), SSD는 솔리드스테이트드라이브(Solid State Drive)를 의미.
- SSD는 컨트롤러가 낸드플래시 셀에서 정보를 바로 조회하기 때문에 속도가 빠름. 

- 참고 자료 : http://m.ddaily.co.kr/m/m_article/?no=125956
  - https://active12.tistory.com/15




## JWT 토큰이란?
- 세션과 JWT 토큰 둘 다 모두 "인증"이 아닌 "권한" / "인가"와 관련된 기술이다.

- **먼저 세션으로 권한 및 인가를 허용하는 과정은 다음과 같다.**
  - 사용자가 로그인에 성공하면 세션을 발행
  - 그 세션 id를 브라우저에 쿠키로 저장하고 서버 메모리 또는 데이터베이스에도 세션을 저장
  - 인가가 필요한 요청을 보낼 때 서버에 쿠키인 세션 id를 보냄 
  - 서버에서 메모리 또는 데이터베이스에 저장된 값과 쿠키인 세션 id와 비교해서 맞다면 권한 및 인가를 허용

- **반면에 JWT(JSON Web Token)이란,** 
  - 예를 들어, eyJhbGciOiJIUzI1NiIsIn 이러한 형식이다. 사용자가 로그인을 하면 서버에서 토큰을 발행해주는 것으로, 이 토큰을 서버가 기억하고 있지 않는다.
  - 이 토큰은 암호화된 3가지 데이터를 이어붙인 형태(aaa.bbb.ccc)로 구성되어 있다. 
  - 첫번째로는 헤더 : 세번째 서명 값을 만드는데 사용하는 알고리즘과 type이 들어간다. ex) HS256 / JWT
  - 두번째로는 페이로드 : 토큰이 갖는 데이터를 의미.
  - 세번째로는 서명 : 1번 헤더에 정의된 알고리즘을 통해 암호화한 비밀 값으로 서버만 알고 있음

- **JWT 단점**
  - 세션처럼 모든 사용자들의 상태를 기억하고 있지 않기 때문에 기억하는 대상들의 상태를 항상 제어할 수 없다.
  - 이미 발행한 토큰이 해커한테 넘어가도 토큰을 무효화할 방법이 없다.

- **해결책으로 로그인 시 accessToken / refreshToken 이렇게 2개의 토큰을 발행해준다.** 
  - accessToken은 매번 인가받을 때 사용하는 토큰(수명이 짧다)
  - refreshToken은 accessToken의 수명이 다했을 때 accessToken을 재발행 받기 위한 토큰(보통 2주 정도 유지)
  - 누군가를 로그아웃시키려면 refeshToken을 db에서 지워버리면 되는데 그래도 accessToken의 수명 동안은 바로 차단할 방법은 없음

- 참고 자료 : https://velog.io/@syoung125/JWT-%ED%86%A0%ED%81%B0%EC%9D%B4%EB%9E%80


## 프로세스와 쓰레드에 대해서 설명해주세요 
- https://brunch.co.kr/@kd4/3#comment
- 프로세스는 운영체제로부터 프로세서, 필요한 주소 공간, 메모리 등 자원을 할당받는 작업의 단위이고 / 쓰레드는 한 프로세스 내에서 동작되는 여러 실행 단위로 프로세스가 할당받은 자원을 이용하는 실행의 단위이다. 그래서 같은 프로세스 내의 스레드끼리 자원을 공유한다.
- 멀티 프로세스로 할 수 있는 작업들을 굳이 하나의 프로세스에서 스레드로 나눠서 일을 하는 이유는, 운영체제는 시스템 자원을 효율적으로 관리하기 위해서 스레드를 사용하기 때문이다.
  - 프로세스 간의 통신보다 스레드 간의 통신 비용이 적어 작업들 간의 통신 부담이 줄어들게 된다.





## 데이터베이스 인덱싱 자료구조인 B-Tree
- 데이터베이스에서 쿼리가 처리될 때, 우리가 django ORM을 사용해서 데이터를 조회하면 데이터베이스에 맞는 쿼리가 생성되어 전송된다. 그리고 데이터베이스는 쿼리를 받으면 내부의 Optimizer가 실행계획을 계산해서 최적화된 탐색 방식으로 인덱스를 타도록 조회를 수행한다. 쿼리가 데이터베이스에 Hit 되고나서 Optimizer가 데이터베이스 내부에서 조회를 수행한다.
  - **Optimizer는 DBMS의 핵심 엔진이다.**
- 우리가 DB에서 사용하는 pk같은 경우, 우리가 먼저 Primary Key로 선언을 하는 것이기 때문에 그것도 사실 키이다. 그래서 얘네들은 자동으로 인덱싱이 된다. 그래서 보통은 우리가 인덱싱을 사용하지 않고도 빠르게 탐색하는 방법 중 하나는, 웬만하면 get이나 filter를 사용할 때 pk를 통해서 검색하는 것이 진짜 빠르게 검색이 된다.
- [관련 블로그](https://coding-factory.tistory.com/743)


## wsgi란? wsgi를 사용하는 이유?
- WSGI는 Web Server Gateway Interface의 약자로, nginx와 같은 web server와 django라는 프로그램이 서로 소통할 수 있게끔 해주는 인터페이스이다. 대표적으로 gunicorn이라는 프로그램이 있다. 
- django의 runserver는 공식문서에서도 개발 및 테스트가 목적이기 때문에, 배포 환경에서는 보안에 대한 문제가 있어 사용하지 말라고 나와있다. 그래서 배포 환경에서는 wsgi를 통해서 서비스하도록 권장하고 있다.
- **wsgi를 쓴다면 django 등의 웹 프레임워크 기능을 할 수 있게 되는데, 여기에 nginx를 앞에 붙이면 더 좋은 성능을 낼 수 있다.** 
  - 가장 큰 이유로, nginx는 한 번에 들어오는 많은 요청들을 처리하여 로드 밸런싱 및 캐싱 기능을 해줄 수 있다는 점이다.
  - 몇몇 wsgi는 정적 파일을 지원하지 않기 때문에, nginx가 없다면 정적 파일을 django까지 요청이 도착한 다음에야 처리할 수 있으므로 성능이 저하된다.

- 참고자료 : https://uiandwe.tistory.com/1268


## Nginx와 Gunicorn 둘 중 하나만 사용해도 될까
- 클라이언트로부터 오는 HTTP 요청을 파이썬 스크립트가 요구하는 데이터 형식으로 변환하고 응답을 돌려줄 때도 파이썬 데이터를 HTTP 형식으로 바꿔주는 작업이 필요한데, 이 때 파이썬 앱 서버가 동작하는 기본적인 방식이 CGI, Common Gateway Interface이다. 그런데 CGI는 한 가지 문제점이 있었는데, 바로 요청이 들어올 때마다 파이썬 스크립트를 처음부터 실행한다는 것이다.
  - 그래서 이러한 문제점을 보완한 것이 WSGI(Web Server Gateway Interface)이고 웹 서버가 클라이언트의 요청을 받아서 스크립트에 전달해주면 스크립트는 스크립트 전체를 실행시키는 게 아니라 필요한 로직 하나만 실행한 후 결과를 응답해주는 식으로 동작함으로써 동적인 콘텐츠에 대한 요청에 빠르게 응답할 수 있게 해주는 것이다.
- 즉, WSGI는 별도의 프레임워크 같은 게 아니라, 동적인 데이터에 대응하기 위해서 웹 서버와 파이썬 웹 앱이 어떻게 서로 동작해야 하는지에 대한 내용을 담고 있는 specification이다.

- **Nginx가 필요한 이유** -> 정적인 파일 요청을 처리하고 reverse proxy server, load balancer 등의 역할을 수행하기 위해서
- **Gunicorn이 필요한 이유** -> 웹 앱에 HTTP 요청을 전달하고 응답을 되돌려주는 일을 할 WSGI server의 역할을 하기 위해서
- **Gunicorn만 써도 된다** -> Gunicorn이 WSGI middleware로서 웹 서버의 역할을 수행하기 때문에 Gunicorn만 써도 된다. 다만, Nginx가 제공하는 추가적인 혜택을 받지 못할 뿐이다. 
- **Nginx만 써도 된다** -> Flask나 Django 같은 프레임워크는 WSGI interface를 이미 어느 정도 구현해놓았기 때문에 프레임워크를 사용한다면 Nginx만 써도 된다. 다만 session, cookie, routing, authentication 등의 기능을 수행해주는 middleware의 역할을 하는 애가 없기 때문에 이 부분은 자기가 하드 코딩해야 한다.

- 참고자료 : https://velog.io/@jimin_lee/Nginx%EC%99%80-Gunicorn-%EB%91%98-%EC%A4%91-%ED%95%98%EB%82%98%EB%A7%8C-%EC%8D%A8%EB%8F%84-%EB%90%A0%EA%B9%8C


## 결제 & 취소과정 및 트랜잭션
- [관련 내용](https://han.gl/nxfTO)

- **일반적인 결제 과정**
  - 처음에 먼저 우리 DB에 고객이 입력한 주문 내역 정보들을 입력하기(결제정보 입력창으로부터 정보 받기)
  - 그 다음에 고객이 결제창을 띄워서 PG사한테 결제 요청 하기
  - 결제 수단 마다 인증 단계 진행하기(카드사 또는 은행 서버 등등)
  - 우리 서버에서 최종 결제 승인을 진행
  - 승인이 끝나고 나면 우리 서버 DB에 있는 결제 내역을 성공으로 업데이트 하기

- **일반적인 취소 과정**
  - 결제 취소 요청
  - PG사에 결제 취소 API 호출
  - 성공 응답이면 트랜잭션 시작
  - 모델 레코드 상태를 CANCELED로 변경하고 취소 시각을 입력
  - 구매 수량 원 상태로 복구
  - 마지막으로 트랜잭션 종료


- **트랜잭션**이란, 우리의 단계 뿐만이 아니라 외부의 단계를 포함해서 수행되는 시간이 서로 다르지만, 한 번에 묶음 처리 되어야 하는 처리 과정을 의미한다. 또한, 컴퓨터 사이언스 분야에서 트랜잭션은 **"쪼개질 수 없는 업무처리의 단위"** 를 의미한다.
  - 트랜잭션에서 하나라도 내부에 있는 작업이 실패하게 되면, (하나의 수정작업 update가 실패하면) 트랜젝션 상의 모든 업데이트가 취소된다. 즉, 모든 업데이트가 실패 이전 상태로 복구된다. 이것을 **"롤백"** 이라고 부른다.
  - 데이터베이스 작업이나 결제 및 송금 과정과 같이 **코드를 한 단위로 수행하는 것**을 의미한다.

- **TPS**
  - TPS란 Transaction Per Second의 약자로 1초 당 처리할 수 있는 트랜잭션의 개수를 의미한다.
  - ex) 실제로 API가 호출이 되서 응답이 될 때 그 하나의 단위를 트랜잭션이라고 본다면, 1초 당 API가 호출되는 카운트를 의미하기도 한다.
  - ex) TPS를 DB에 다시 대입해서 생각해보면, DB가 동시에 처리가능한 트랜잭션의 수가 될 수도 있다.

- **트랜잭션의 4가지 특성 - ACID**
  - 1. Atomicity(원자성) : 트랙잭션의 작업이 모두 수행되거나 혹은 모두 수행이 안되거나 이다. 하나의 트랜잭션 안에 여러가지 코드가 들어가 있고 여러가지 오퍼레이션이 수행되더라도 그 중 하나라도 실패한다면 아무것도 실행이 안되는 상태가 보장이 되어야 한다.
  - 2. Consistency(일관성) : 트랜잭션이 수행되는 순간에는 여러번 읽더라도 데이터베이스의 상태가 똑같해야 한다는 것이다. 예를 들어, 내가 트랜잭션을 시작했는데 거기있는 값이 일관성없이 이리저리 바뀌게 된다면 트랜잭션이 수행되는 동안에 내가 보고있는 데이터가 변질이 계속 되는 것이다. 그러면 일관성이 없다고 볼 수 있다.
  - 3. Isolation(독립성, 고립성) : 하나의 트랜잭션이 수행되고 데이터를 갱신하는 동안에는 이 트랜잭션이 완료되기 전에 갱신중인 데이터에 다른 트랜잭션이 접근하지 못하게 해야한다는 것이다. 내가 어떤 데이터를 막 수정하고 있는데 다른 애가 와서 덮어쓰고 내가 수정하려고 하면 내껄 날려버리고 이러면 안될 것이다.
  - 4. Durability(지속성) : 트랜잭션이 끝나고 나면 커밋이 마무리가 되고 그 갱신 사항이 이후에도 계속 유지되고 적용되어야 한다는 것이다. 

- [결제 흐름 예시](https://han.gl/TAvUr)

<br>

## values / annotate / aggregate
- **values** : iterable로 사용될 때 모델 인스턴스가 아닌 사전을 반환하는 QuerySet를 반환
  - [공식 문서](https://docs.djangoproject.com/en/4.0/ref/models/querysets/#django.db.models.query.QuerySet.values)
```python
# This list contains a Blog object.
>>> Blog.objects.filter(name__startswith='Beatles')
<QuerySet [<Blog: Beatles Blog>]>

# This list contains a dictionary.
>>> Blog.objects.filter(name__startswith='Beatles').values()
<QuerySet [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]>
```

- **values() 메서드에 특정 필드를 지정하면 각 사전에는 지정한 필드에 대한 필드 키/값만 포함된다.**
```python
>>> Blog.objects.values()
<QuerySet [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]>
>>> Blog.objects.values('id', 'name')
<QuerySet [{'id': 1, 'name': 'Beatles Blog'}]>
```

<br>

- **annotate** : 엑셀에 column를 하나 추가하는 것과 같이 필드 하나를 만들고 거기에 다른 필드의 값을 그대로 복사하거나, 다른 필드의 값들을 조합한 값을 넣을 수 있게 해주는 메서드이다.
  - annotate의 사전적 의미는 '주석을 달다'라는 것으로 django에서는 주석 대신 필드를 추가한다고 생각하면 된다.

<br>

- **aggregate** : django에서 한 필드 전체의 합이나 평균, 개수 등을 계산할 때 사용할 수 있는 메서드이다.
  - aggregate의 사전적 의미는 '합계', '종합'이다.
  - **아래와 같이 딕셔너리 형태로 출력해준다.**

```python
# OrderLog 모델의 price라는 필드의 모든 값을 더해주기
>>> OrderLog.objects.all().aggregate(total_price=Sum('price'))
{'total_price': 262200}
```


- [관련 블로그](http://raccoonyy.github.io/django-annotate-and-aggregate-like-as-excel/)
- [관련 블로그2](https://tech.toktokhan.dev/2021/04/26/django-query-func/)



<br>

## Python & Django 질문 대비
- [python 관련 블로그](https://han.gl/JaNWX)
  - 해당 블로그 1~4 확인하기
- [python 관련 블로그2](https://uiandwe.tistory.com/1272?category=923644)


<br>


* * *
## 추가로 알고있어야 할 개념들
- [디자인 패턴 개념](https://velog.io/@syoung125/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-13%EA%B0%80%EC%A7%80)
  - [디자인 패턴 유튜브](https://www.youtube.com/watch?v=lJES5TQTTWE)
  - [python 싱글턴 패턴](https://wikidocs.net/69361)
- [Jquery를 사용하는 이유](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=seonsin25&logNo=30154924257)
- [좋은 내용 블로그](https://uzleem.tistory.com/23)
- [자료구조란](https://andrew0409.tistory.com/148)
- [컴파일러 vs 인터프리터](https://coding-factory.tistory.com/303)
- [기술 면접 가이드라인 github 저장소](https://github.com/JaeYeopHan/Interview_Question_for_Beginner)
- [컴퓨터에서 실수를 부동소수점 방식으로 처리](https://velog.io/@hyungraelee/%EC%8B%A4%EC%88%98%EC%9D%98-%EB%B6%80%EB%8F%99-%EC%86%8C%EC%88%98%EC%A0%90-%EC%A0%80%EC%9E%A5-%EB%B0%A9%EC%8B%9D)
- [운영체제 관련 개념](https://goodmilktea.tistory.com/23)
- [웹에서 매핑이란](https://threeidiotscoding.tistory.com/26)
- [render의 HttpResponse 리턴 vs redirect의 HttpResponseRedirect 리턴](https://milooy.wordpress.com/2016/03/03/pass-data-through-redirect-in-django/)
- [유니코드란](https://sweetday-alice.tistory.com/179)
- [데몬(daemon) 프로세스란](https://blogger.pe.kr/770)
- 배포 관련 
  - [Deploy 1](https://github.com/tkdqor/TIL/blob/main/Django/Django%20CRUD/Deploy%20(1).md)
  - [Deploy 2](https://github.com/tkdqor/TIL/blob/main/Django/Django%20CRUD/Deploy%20(2).md)
  - [Deploy 3](https://github.com/tkdqor/TIL/blob/main/Django/Django%20CRUD/Deploy%20(3).md)
  - [site deployment](https://github.com/tkdqor/TIL/tree/main/Django/taling/site%20deployment)
- DRF(Django REST Framework) 관련 내용
  - [DRF 내용](https://url.kr/vl82fg)
- [데이터베이스 인덱싱에 사용되는 자료구조인 B-Tree](https://han.gl/gRfHZ)


* * * 
## Impact museum 관련 내용

### 인바운드 규칙
- 인터넷을 포함한 외부 네트워크에서 EC2 인스턴스 또는 RDS로 향하는 정책

### 아웃바운드 규칙
- EC2 인스턴스 또는 RDS에서 인터넷을 포함한 외부 네트워크로 향하는 정책

### SSH
- 원격지 호스트 컴퓨터에 접속하기 위해 사용되는 인터넷 프로토콜 / 기본포트는 22번
- 이 SSH가 있어야 우리가 터미널을 통해서 우리가 만든 가상 server에 접근할 수 있음
- https://velog.io/@hyeseong-dev/%EB%A6%AC%EB%88%85%EC%8A%A4-ssh%EB%9E%80

### 기본 포트
- HTTP의 기본 포트는 80번 / django의 기본포트는 8000번
- https://dailyheumsi.tistory.com/19

### IPv4 
- Internet Protocol version 4의 약자로, 전 세계적으로 사용된 첫번째 인터넷 프로토콜이다. 32비트 방식으로, 4개로 나눠진 최대 12자리 번호로 되어있다.
- ex) 123.123.123.123

### IPv6
- internet protocol version 6의 약자로, IPv4 주소의 고갈문제를 해결하기 위해서 128비트를 채택하여 2의 128승의 개수만큼 주소를 만들 수 있는 프로토콜을 의미. 아직 완전히 적용되지는 않았음.

### TCP
- Transmission Control Protocol의 약자로 서버와 클라이언트간에 데이터를 신뢰성 있게 전달하기 위해 만들어진 프로토콜이다.
- 데이터를 전송하기 전에 데이터 전송을 위한 연결을 만드는 연결지향 프로토콜로, 데이터는 네트워크 선로를 통해 전달되는 과정에서 손실되거나 순서가 뒤바뀌어서 전달될 수 있는데, TCP는 손실을 검색해내서 이를 교정하고 순서를 재조합할수 있도록 해준다. 
- https://musclebear.tistory.com/2


### Lazy-loading이란
- Django의 ORM은 다른 ORM과 마찬가지로 Lazy-loading방식을 사용한다. **Lazy-loading이란 python 코드로 ORM에서 명령을 실행할 때마다 데이터베이스에 접근하여 데이터를 가져오는 것이 아닌 모든 명령처리가 끝나고 실제 데이터를 불러와야할 때 데이터베이스 Query문을 실행하는 방식을 말한다.**
  - 반대로 **Eager-loading(즉시 로딩)은 Lazy-loading의 반대 개념이다. Lazy-loading은 Query문을 하나, 하나 실행하여 데이터를 가져온다면 Eager-loading은 지금 당장 사용하지 않을 데이터도 포함하여 Query문을 실행**하기 때문에 밑에 설명할 Lazy-loading의 N+1문제의 해결책으로 많이 사용하게 된다. Django에서 Eager-loading을 실행하는 방법은 select_related 메소드와 prefetch_related 메소드를 사용한다. 

- 우리가 ORM으로 쿼리문을 만들면 바로 데이터베이스에 Hit가 되는 것이 아니라, template에서 {% for item in recommendations %}  또는 {{ item.restaurant.category.name }} 이러한 코드가 실행될 때 마다 데이터베이스에 Hit를 치게 된다. 이게 바로 “lazy-loading 방식”이다. 그 다음 바로 이어서 {{ item.restaurant.main_image.image }} 해당 코드가 실행될 때는, 이미 메모리에 불러온 restaurant이 있기 때문에 Hit 하지는 않는다. 
  - **Lazy-loading의 성능이슈인 N+1 Query 문제는 외래키(Foreign Key)를 참조해서 데이터를 가져올 때 발생한다.** {% for item in recommendations %} 이러한 코드가 있고 그 밑에 {{ item.restaurant.category.name }} 이렇게 코드가 있을 때, 데이터 개수인 N번 Hit 하는 게 아니라 처음 for문에서 한 번더 Hit가 발생하게 된다.

- 근데, 너무 많이 데이터베이스에 Hit를 치게 되면 —> 데이터베이스에 부하가 많이 걸리게 된다. 그래서 이렇게 lazy-loading 를 방지하는 방법으로 django에서는 select_related 메소드를 사용할 수 있다.

```python
...
recommendations = Recommendation.objects.filter(visible=True).order_by('sort').select_related('restaurant').all()[:4]
...
```

- **이런식으로 views.py에서 Recommendation를 읽어올 때 select_related 메소드를 사용하면, lazy-loading를 쓰지 않고 아예 연결된 restaurant도 같이 가져오겠다는 의미가 된다.** 
  - 이 때 ‘restaurant’은 related_name이라고 생각하면 되서 modes.py에도 같은 이름으로 되어있는지 확인하자.

- [관련 내용](https://han.gl/WYHSi)
- [관련 블로그](https://velog.io/@anjaekk/Django-Django-ORM%EC%9D%98-Lazy-loading%EA%B3%BC-N1-Query-%EB%AC%B8%EC%A0%9C)

<br>

### django signal이란
- **django에는 어떤 DB 이벤트나 아니면 django에서 정의하는 여러가지 시스템 이벤트라고 할 만한 것들이 있는데, 그래서 이런 이벤트가 발생했을 때 -> 우리가 중간에 캐치를 해서 그 이벤트가 발생한 시점에 '뭔가 처리를 하고 싶다' 라는 코드를 작성해두면, django가 그걸 기억해두었다가 그 이벤트가 발생하는 전이나 후에 처리를 해주는 것을 signal이라고 한다.**
