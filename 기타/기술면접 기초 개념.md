## 1byte = 8bit
- 컴퓨터는 모든 정보를 0과 1로 저장하고 그 0과 1의 집합을 디지털 데이터라고 한다. 그리고 0과 1의 정보를 나타내는 최소 단위를 **1비트(bit)** 라고 한다.
- 또한, 1비트 하나로 많은 양의 데이터를 표현할 수 없기에 8개의 비트를 묶어 **1바이트(byte)** 로 사용하고 있다. 컴퓨터는 기본적으로 이렇게 바이트 단위로 데이터를 읽고 쓰는 작업을 진행한다. 
- 따라서, 컴퓨터가 데이터를 저장하는 최소 단위는 1byte라고 할 수 있다.

=> 1비트가 0과 1 2가지를 표현할 수 있으므로 8비트, 즉 1바이트는 -> 2의 8승으로 총 256종류의 정보를 나타낸다.


## 1픽셀은 3byte
- **픽셀(pixel)** 이란, 이미지를 이루는 가장 작은 단위를 의미. 이미지를 구성하는 점이라고 볼 수 있다.
- ex) 모니터 해상도를 나타내는 640x480과 같은 숫자들이 바로 픽셀의 개수를 의미한다. 즉, 가로 픽셀 640개 / 세로 픽셀 480개로 총 307,200개의 픽셀로 해상도가 구성되었다는 것을 말해주는 것이다.

- **이진 영상(binary image)**   
  디지털 이미지 중 가장 간단한 형태.   
  각 픽셀이 1비트로 이루어져 있음. 그래서 밝음(1)과 어두움(0)만 표현.

- **흑백 영상(gray-scale image)**  
  각 픽셀의 밝기 값을 0~255 사이 값으로 표현한 이미지.   
  즉, 1바이트(=8비트)의 메모리를 사용.
  
- **컬러 영상(color image)**  
  컬러 영상은 빨강, 녹색, 파랑 이렇게 3개의 채널로 표현된다. 각 채널은 0~255 사이의 값으로 8비트로 이루어진다.   
  따라서, 1픽셀 당 -> 8비트 3개(Red, Green, Blue)를 조합하여 총 24비트이므로   
  1픽셀은 3바이트가 된다.


## 2^10은 = 10bit = 1,024
- 1비트는 0과 1 2가지로 표현되니까 2^1승으로 표현된다. 그리고 2비트는 00, 10, 01, 11 이렇게 4가지로 2^2승으로 표현된다.
- 마찬가지로 8비트는 -> 2^8승으로 256가지를 표현할 수 있고 0~255의 데이터를 저장할 수 있게 된다. 이러한 8비트를 1바이트라고 한다.
=> 그래서 2^10승은 -> 10비트를 의미하고 -> 1,024라는 값이 되는 것을 알 수 있다.


## Stack과 Queue의 차이는?
- https://jud00.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%8A%A4%ED%83%9DStack%EA%B3%BC-%ED%81%90Queue%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90
- **Stack이란, 데이터를 차곡차곡 쌓아올린 형태의 자료구조이다. 데이터가 순서대로 쌓이다가 가장 마지막에 삽입된 자료가 가장 먼저 삭제되는 구조를 가지고 있다.**
  - Stack은 정해진 방향으로만 쌓을 수 있고, top으로 정한 곳을 통해서만 접근할 수 있다. 새로 삽입되는 자료는 top이 가리키는 가장 맨 위에 쌓이게 되고 자료를 삭제할 때도 top을 통해서 삭제가 가능.
  - **Stack에서 삽입 연산은 push / 삭제 연산은 pop이라고 한다. 후입선출의 구조로 LIFO(Last In First Out)이라고 부른다.**
  - ex) 웹 브라우저 방문 기록 뒤로가기, 실행 취소(undo), 역순 문자열 만들기, 후위 표기법 계산

- **큐(Queue)는 먼저 들어온 것이 먼저 나가는 선입선출로 FIFO(First In First Out)의 구조를 가지고 있다.**
  - FIFO 구조를 위해서 큐의 왼쪽 끝에는 삽입 작업이 / 오른쪽 끝에는 삭제 작업이 나뉘어서 이루어진다.
  - **삽입 연산이 이루어지는 곳을 리어(rear)라고 하고, 리어에서 이루어지는 삽입 연산을 인큐(Enqueue)라고 부른다.**
  - **삭제 연산이 이루어지는 곳을 프론트(front)라고 하고, 프론트에서 이루어지는 삭제 연산을 디큐(Dequeue)라고 부른다.**
  - ex) 은행 업무, 대기열 순서와 같은 우선순위의 작업 예약 등, 서비스 센터 대기시간, 프로세스 관리


## Binary Tree의 시간 복잡도가 어떻게 되나요?(나중에 물어보거나 자세하게 더 알아보기!)
- 먼저 **시간 복잡도**란, 우리가 작성한 코드의 실행시간이 실행해보기 전에 정확하게 추측하는 것은 힘들겠지만 반복문을 몇 번 사용했는지, 입력값은 어떻게 되는지 등을 통해 대략적으로 추측할 수 있다. **즉, 입력값과 연산 수행 시간의 상관관계를 나타내는 척도를 시간 복잡도라고 한다.**
- Binary Tree의 시간 복잡도는 **O(log_2(N))** 이다.
  - 해설 : https://neos518.tistory.com/145
  - 이진 트리 설명 : https://ratsgo.github.io/data%20structure&algorithm/2017/10/21/tree/


## DNS의 역할이 무엇인가요?
- **IP주소와 도메인명을 서로 교환해주는 장치를 DNS(Domain Name System)라고 한다.**
- DNS 서버는 **캐시 서버**와 **콘텐츠 서버**로 나뉜다.
  - 클라이언트인 웹 브라우저가 인터넷에서 도메인명으로 엑세스할 때 --> 캐시 서버는 받은 도메인명의 맨 오른쪽부터 순서대로 검색하여, 해당 도메인명을 관리하는 콘텐츠 서버들을 하나씩 찾는다. 그래서 마지막으로 콘텐츠 서버를 찾게 되면 해당 서버가 호스트명 + 도메인명에 대응하는 IP주소를 알려주게 되고, 캐시 서버는 이 IP주소를 웹 브라우저에게 알려주면서 해당 사이트로 접속할 수 있게 해준다. 이러한 동작을 **이름 해결** 이라고 한다.

- 도메인명은 ‘www.examaple.co.kr’ 와 같이 점으로 구분된 문자열로 구성되어 있다. 하나하나 문자열을 **라벨**이라고 하고 오른쪽부터 순서대로 탑레벨(제1레벨) 도메인, 제 2레벨 도메인, 제 3레벨 도메인 이렇게 부른다.
  - 즉, 트리모양의 계층 구조로 이루어져 있다.

- 참고 자료 : https://goodgid.github.io/Server-DNS/


## HTTPS와 HTTP의 차이는 뭔가요?
- **HTTP**는 Hyper Text Transfer Protocol의 약자로 서버와 클라이언트간에 데이터를 주고 받는 프로토콜을 의미한다. 80번 포트를 사용하고 있으며 텍스트, 이미지,영상, JSON 등등 거의 모든 형태의 데이터를 전송할 수 있다. 다만, HTTP는 암호화가 되지 않은 평문 데이터를 전송하는 프로토콜이기 때문에, HTTP로 비밀번호나 주민등록번호 등을 주고 받으면 제3자가 정보를 조회할 수 있는 문제점이 있다.
- **HTTPS**는 Hyper Text Transfer Protocol Secure의 약자로 HTTP에 데이터 암호화가 추가된 프로토콜이다. HTTPS는 443번 포트를 사용하고 있고 네트워크 상에서 중간에 제3자가 정보를 볼 수 없도록 암호화를 지원한다.
  - HTTPS는 **SSL(Secure Sockets Layer)** 이라는 보안계층 위에 HTTP를 얹어서 보안이 보장된 통신을 하는 프로토콜로 이러한 통신 방식을 **SSL 암호화 통신**이라고 한다. 이 SSL 암호화 통신은 공개키 암호화 방식의 알고리즘으로 구현된다.
  - **공개키 암호화 방식**에는 **공개키와 개인키 두 종류의 키가 존재**한다. 공개키는 모두에게 공개가능한 키 / 개인키는 나만 가지고 알고 있어야 하는 키라고 생각하면 된다. 한쪽 키로 데이터를 암호화 했다면 오직 다른쪽 키로만 복호화를 할 수 있다. 개인키는 보통 서버를 운영하는 회사가 가지고 공개키는 CA(Certificate Authority)라는 인증받은 기업들에서 관리하게 된다. 
  - CA는 서버 운영 기업이 넘겨준 공개키를 인증서 발급자, CA의 이름 등과 함께 묶어서 CA가 가지고 있는 개인키로 암호화해서 **SSL인증서**로 발급한다. 그리고 클라이언트에서 요청을 하면 서버는 클라이언트에게 SSL 인증서를 보낸다. 브라우저(클라이언트)는 대표적인 CA들의 리스트와 그들의 공개키를 보유하고 있다. 만약 인증서에 적힌 CA의 이름과 브라우저가 소유하고 있는 CA 이름이 같다면 CA의 공개키로 SSL 인증서를 복호화한다. 이제 SSL내부에 들어있던 서버의 공개키를 가지고 요청을 암호화해서 서버에게 보낸다. 서버측은 가지고 있는 개인키로 요청을 복호화하여 해석하고 응답은 다시 암호화 해서 보내게 된다. 이 과정을 통해 보안성이 강한 통신을 할 수 있게 된다.

- 관련 자료 : https://devjem.tistory.com/3#HTTPS%EB%-A%--%--%EC%--%B-%EB%--%A-%--%EB%B-%A-%EC%-B%-D%EC%-C%BC%EB%A-%-C%--%EB%B-%B-%EC%--%--%--%EC%-D%B-%EC%-A%--%EB%A-%BC%--%ED%--%B-%EA%B-%B-%ED%--%--%EB%-A%--%EA%B-%--%-F
- https://mangkyu.tistory.com/98



## 클라이언트 요청부터 서버의 응답까지 전체 과정(아직 확실한지 모름)
- 클라이언트 요청 -> 미들웨어 -> 웹서버(static파일 처리, nginx) -> gunicorn(웹 서버와 django 서버 통신하기 위한 인터페이스) -> 앱서버(django서버, API서버) -> Celery(broker - worker) -> (존재하는 경우)캐시 서버(redis) -> (DB정보가 필요한 경우)데이터베이스 서버 
- 엘라스틱 서치는 어떤 위치에 있는걸까?



## Web 서버 동작 과정
- **우리가 웹브라우져에서 들어가고 싶은 웹페이지의 주소를 쳤을때, 그 요청이 서버 컴퓨터로 가지면 해당 서버 컴퓨터의 웹 서버라는 프로그램(소프트웨어)은 서버 컴퓨터에 저장되어있는 웹페이지 파일 중 요청과 맞는 파일을 골라 다시 우리 웹브라우져로 넘겨준다. 이 때 이 주고받는 과정들은 HTTP 규약에 따라 진행된다. 하지만, 위의 구조로는 우리가 원하는 모든 웹페이지를 받아볼 수 없다.**
  - 웹페이지는 "정적 페이지"와 "동적 페이지"로 구분될 수 있다. 
  - 정적 페이지는 웹브라우저(클라이언트) 요청에 항상 같은 내용을 표시하는 웹페이지이다. 서버에 이미 저장된 html, css, javascript 파일들로 구성되어있다. 누가 언제 들어가든 항상 똑같은 내용이다.
  - 동적 페이지는 요청하는 클라이언트마다 각각 다른 내용이 표시되는 웹페이지이다. 로그인 정보, 장바구니, 게시판 등 이러한 동적 페이지를 제공하기 위해선 해당 클라이언트에게만 제공되는 정보를 저장한 데이터베이스의 연동이 필요하다. 
- **웹 서버의 경우 -> 정적 페이지만 처리할 수 있다. 그래서 별도의 동적 페이지를 처리해줄 수 있는 소프트웨어 프로그램이 필요하다.**
- **그래서 등장한 것이 CGI(Common Gateway Interface)프로그램으로, C, C++, PERL, PHP, PYTHON 등의 언어로 만들어졌다. 이 프로그램은 DB관련 로직을 처리하고 동적 페이지를 만들어 웹 서버에게 넘겨준다.**
  - 이 때, 이 CGI프로그램과 웹서버가 정보를 주고받는 규칙을 정의한 것이 CGI 규격이다. 
  - 그러나, 전통적인 CGI방식에서는 동적 처리를 진행할때마다 개별 독립적인 프로세스를 생성하는 방식이어서 요청이 많아질 경우, 프로세스 수가 증가해 서버 컴퓨터의 메모리량이 커지고 시스템 부하 현상이 발생헀다. 
- **위의 이유로 현재는 CGI기술을 사용하지 않고 다른 방법들을 사용한다.**
- **그 다음 등장한 것이 바로 애플리케이션 서버(Web Application Server(WAS))이다. 나의 경우, Django 서버라고 보면 된다.**
  - 동적 처리를 하는 응용 프로그램들을 따로 실행할 수 있는 서버를 만들어서 사용하는 방식이다. 
  - 클라이언트가 동적 페이지를 요청했을 때, 웹 서버는 요청을 받아 애플리케이션 서버에게 처리를 위임한다. 그리고 애플리케이션 서버는 동적 처리를 해주는 프로그램들을 실행시켜 DB로부터 원하는 결과를 처리한 후, 다시 웹 서버에게 넘겨주고 웹 서버는 클라이언트에게 결과를 보여준다.
  - 이렇게 서버를 2개로 구분한 이유는, 서로의 역할 구분하는 것이 더 효율적이기 때문이다.
- **오늘날 두 서버는 점점 더 전문화되는 방향으로 발전하고 있다. 웹 서버는 정적 페이지 제공 / 캐시 기능 / 프록시 기능 / http/https의 제어에 필요한 기능 등을 제공한다.    
  웹 애플리케이션 서버는 웹 서버와의 연동 규격을 잘 따르기만 하면 임의의 언어 플랫폼을 사용할 수 있어 많은 종류의 서버가 생겨났다. 자바, python 등**
  - 이러한 2개의 서버를 하나의 하드웨어에서 사용하는 것 보다 나눠쓰는 것이 메모리 효율이 높아지므로 대규모 사이트의 경우, 각각의 서버를 각각의 하드웨어에 설치해서 사용하기도 한다.

- **추가로 django의 경우, Django REST Framework를 설치하여 API 서버를 구축할 수 있다. 이러한 API 서버는 운영과 유지보수를 위해 WAS 서버와 따로 분리하여 운영하는 것이 일반적이다.**

- 참고 블로그 : https://iamrealizer.tistory.com/6


## 스마트폰 카메라 해상도가 (대략) 어떻게 되나요?
- 해상도란, 이미지 안에 얼마나 많은 픽셀이 들어가 있는지 나타낸 것이다. 그리고 픽셀이 작을수록 사진이 선명해진다. ex) 같은 크기의 사진을 입자 4개로 만든 것과 1,000만개로 만든 것을 비교하면 4개로 만든 건 모자이크같이 형상을 알아보기 힘들 것이다. 
- 내가 사용하고 있는 아이폰12 pro 기준으로 대략 해상도는 12백만 화소(픽셀)라고 한다. 가로 4290 X 세로 2800 픽셀이다.
- https://lifenourish.tistory.com/1301


## 왜 사진에는 JPG를 사용할까요?
- **JPG(JPEG)는 정지 화상을 위해 만들어진 손실 압축 파일 형식으로, 약간의 손실을 감수하고 용량을 줄이고 작은 크기로 사진을 저장하는데 유용하기 때문에 사용된다.**
  - JPG(JPEG)는 손실 압축(lossy compression), direct color으로 사진같이 복잡한 색상을 갖는 이미지 저장에 적합하다. 그리고 문자, 선등 뚜렷한 윤곽선을 가지는 이미지는 품질 저하(뭉개짐, 노이즈)가 다소 뚜렷하게 보인다.
  - PNG는 비손실 압축(lossless compression, indexed color으로 텍스트, 선, 아이콘 등을 저장하는데 적합하다.

- 손실압축은 용량을 줄이기 위해 화질을 낮추고 비교적 크게 용량이 감소하지만, 원래 형식을 복원할 수 없다. 
- 무손실압축은 적은 용량만이 감소되지만, 원래 형식으로 복원이 가능하다. 
- Direct color는 픽셀마다 색 정보를 가지고 있음. 다양한 컬러. 큰 용량.
- Indexed color는 픽셀마다 색 정보를 가지고 있는 것이 아니라 Pallette에 별도로 컬러를 저장하고 픽셀은 팔레트의 정보를 가지고 있음. 작은 용량.


## 칼라값 ffffff는 무슨 색인가요?
- **답은 흰색이다.**
- f는 16진수로 2의 4승으로 4비트이고 ff가 8비트가 되어 1바이트를 나타낸다.
  - ffffff는 3바이트로 3개의 채널로 구성되고 3 채널은 픽셀당 24비트로 변환된다.
  - 채널 당 8비트 이미지에서는 컬러 이미지의 RGB(빨강, 녹색, 파랑) 구성 요소 각각에 0(검정)에서 255(흰색)까지 강도 값이 할당된다. 그래서 3채널 모두 255라면 흰색이 된다.

- 참고 자료 : http://www.n2n.pe.kr/lev-1/color.htm 
  - https://helpx.adobe.com/kr/photoshop/using/color-modes.html


## \<a href\> 가 무슨 뜻인가요?
- a는 html \<a\>태그로 외부 문서나 내부 문서를 링크할 때 사용하는 태그이다. 그리고 href는 hypertext reference의 약자로 실제로 이동할 웹페이지의 주소를 뒤에 적는 속성이다. 그래서 \<a\> 태그와 href 속성이 서로 같이 사용되서 하이퍼링크를 만들 수 있게 된다.


## call by reference가 무슨 말인가요?
- 함수의 호출 방법은 대표적으로 Call by value(값에 의한 호출)와 Call by reference(참조에 의한 호출)가 있다.
- 함수 호출이란 말 그대로 정의된 함수를 호출하는 것으로 함수에 정의한 매개변수의 형태에 따라 Call by value 혹은 Call by reference인지 결정된다.
- **Call by value란, 함수 호출 시 넘기는 인자(함수가 호출될 때 매개변수에 실제로 담기는 값)의 값이 매개변수에 복사(Copy)돼서 함수 내에서 매개변수(매개변수란, 함수를 정의할 때 사용되는 변수)에 직접적인 데이터 조작을 가해도 인자에 전혀 영향을 주지 않는 것이다. 즉, 값을 복사를 하여 처리한다는 것이다.**
  - **매개변수는 그 값이 Stack에 할당**된다. Stack이란, 메모리의 스택(stack) 영역으로 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다.
  - **그래서 원래 값이 보존된다는 장점이 있다. 단, 복사하기 때문에 메모리 사용이 늘어난다.**

- **Call by reference란, 인자의 값이 매개변수에 복사(Copy)된다는 점은 동일하다. 다만 복사되는 값이 데이터의 주소 값이라는 차이점이 존재한다. 쉽게 말하면 Call by reference란, 말 그대로 참조값으로 함수를 호출했단 뜻이다. (여기서 참조라는 개념이 우리가 잘 알고 있는 포인터이다) 즉, 직접 참조를 하는 것이다.**
  - 중요한 차이점은 함수를 정의할 때 매개변수가 포인터 변수로 정의되었단 점이다. 즉, 변수의 주소를 인자로 받는 것이다. 그래서 주소에 저장된 값에 직접 접근할 수 있게 된다.
  - **그래서 직접 참조해 빠르다는 장점이 있다. 단, 원래 값에 영향을 받게 된다.**

- 참고 자료 : https://kangworld.tistory.com/64
  - https://bskyvision.com/795
  - https://codingplus.tistory.com/29


## Event Listener가 무슨말인가요?
- **이벤트 리스너란 이벤트가 발생했을 때 그 처리를 담당하는 함수를 가리키며, 이벤트 핸들러(event handler)라고도 한다.**
- DOM 객체에서 특정 이벤트가 발생하면 이벤트 리스너를 이용해서 특정 함수를 호출할 수 있다.
  - DOM은 Document Object Model의 약자로 document라는 변수로 html 문서를 객체로 인식하여 문서 내 모든 요소에 접근할 수 있도록 하는 방법을 의미한다.

- 참고 자료 : http://www.tcpschool.com/javascript/js_dom_concept
  - http://www.tcpschool.com/javascript/js_event_eventListenerRegister


## OOP에서 상속이 무슨말인가요?
- 일단 **OOP란, Object Oriented Programming의 약자로 객체지향 프로그래밍을 의미**한다. 객체 지향 프로그래밍은 클래스와 객체를 사용하여 프로그램을 설계하는 방법론으로 특징으로는 캡슐화, 추상화, 다형성, 상속성을 가진다.
- **그 중에서 상속이란, 기존 클래스의 속성과 메서드를 사용하여 새 클래스를 만드는 것으로 새롭게 만든 클래스에 기존 상위 클래스의 기능을 가져와서 재사용하거나 새로운 기능을 추가할 수 있게 만들어주는 개념이라고 볼 수 있다.**
  - 이러한 상속은 코드 재사용에 상당히 유용하다.

- 참고 자료 : https://limkydev.tistory.com/30
  - https://ko.strephonsays.com/polymorphism-and-vs-inheritance-in-oop-12018


## non-blocking call이 뭔가요?
- **non-blocking 방식은 I/O작업을 진행하는 동안 유저 프로세스의 작업을 중단시키지 않고, 유저 프로세스가 I/O를 처리하기 위해 커널에 함수를 호출하는 system call이 진행되면 커널에서 함수의 진행 상황과 상관없이 바로 결과를 반환하는 것을 의미한다.**
- 즉, 애플리케이션 실행 시 운영체제 대기 큐에 들어가지 않고 실행 여부와 관계없이 바로 응답을 보내는 경우를 의미한다. 
  - 다른말로 하면 호출된 함수가 바로 리턴해서 호출한 함수에게 제어권을 넘겨주고, 호출한 함수가 다른 일을 할 수 있는 기회를 줄 수 있다면 non-blocking 방식이다.

- **I/O란,** 입력(Input)/출력(Output)의 약자로 컴퓨터 및 주변장치에 데이터를 전송하는 프로그램, 운영 혹은 장치를 일컫는 말이다. 키보드와 마우스처럼 입력을 위한 기기, 프린터처럼 출력에만 사용되는 기기 등 다양하다.
- **커널이란,** 메모리에 상주하는 운영체제의 일부분을 의미.

- 참고 자료 : https://yoonucho.github.io/review/2019/02/26/sync_async_blocking_non-blocking.html
  - https://asfirstalways.tistory.com/348


## 버전관리에서 commit이 뭔가요?
- **commit은, 파일 및 폴더의 추가/변경 사항을 저장소에 기록하기 위해 commit이라는 버튼을 눌러서 변화에 대해 기록하는 것이다.** commit은 특정 소스가 변경된 이유를 메시지로 입력해 버전을 관리해 나갈 수 있다. 이러한 commit 기록을 관리하면 과거의 변경이력과 내용을 파악할 수 있다.

- 참고 자료 : https://steady-coding.tistory.com/277
  - https://backlog.com/git-tutorial/kr/intro/intro1_3.html
  - 해당 자료 꼭 다시 읽어보기 : https://sabarada.tistory.com/71


## try/catch는 무슨 뜻인가요?
- **try/catch문은 코드 상의 논리적인 문제가 있어 '예외'가 발생하는 경우, 이러한 예외 처리를 명시적으로 표현할 수 있게 해주는 코드이다.**
- 먼저 try 안의 코드가 실행되고 에러가 없다면 catch 블록을 건너뛰게 된다. 에러가 있다면 try안의 코드가 실행이 중단되고, catch 블록에서 해당 에러에 대한 처리를 진행해 나갈 수 있게 된다.
- 참고 자료 : https://ko.javascript.info/try-catch
  - https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=mdown&logNo=221347592097


## 디버깅할 때 breakpoint가 뭔가요?
- **breakpoint는 디버깅을 목적으로 실행중인 디버깅 대상 프로세스를 의도적으로 멈추게 하는 장소를 가리킨다.** 
- 프로세스가 멈추면 멈춘 시점의 변수나 스택 파라미터, 혹은 특정 메모리 지점의 값 등을 조사할 수 있다.

- 참고 자료 : https://to-paz.tistory.com/106


## 패스워드는 서버에 어떻게 보관되나요?
- **단방향 해시 함수를 사용하여 패스워드를 암호화해서 보관한다.**
- 단뱡향 해시 함수는 어떤 수학적 연산이나 알고리즘에 의해 원본 데이터를 매핑시켜 완전히 다른 암호화된 데이터로 변환시키는 것을 의미한다. 이 변환을 해시라고 하고, 해시에 의해 암호화된 데이터를 다이제스트(digest)라고 한다. 이렇게 DB에 저장된 다이제스트는 DB가 해킹당한다 하더라도 단방향으로 해싱된 문자이기 때문에 복호화를 할 수 없다.

- 참고 자료 : https://st-lab.tistory.com/100


## SSD가 HDD보다 빠른 이유가 뭔가요?
- **HDD는 데이터를 읽거나 쓸 때 스핀들 모터로 원판을 돌리고 헤드가 그 위를 헤집어야 하는 물리적 작동이 필요하지만, SSD는 그러한 과정이 생략되어 움직이는 부품이 없어 속도가 빠르고 전력 소모량이 적고 내구성과 신뢰성도 높다.**
- HDD는 하드디스크드라이브(Hard Disk Drive), SSD는 솔리드스테이트드라이브(Solid State Drive)를 의미.
- SSD는 컨트롤러가 낸드플래시 셀에서 정보를 바로 조회하기 때문에 속도가 빠름. 

- 참고 자료 : http://m.ddaily.co.kr/m/m_article/?no=125956
  - https://active12.tistory.com/15


## 쿠키와 세션
- **쿠키 : 방문자의 정보를 방문자 컴퓨터의 메모리에 저장하는 것 ex) ID나 비밀번호를 저장하거나 방문한 사이트를 저장하는 데 사용** 
- **세션 : 방문자의 요청에 따른 정보를 방문자 메모리에 저장하는 것이 아닌 웹 서버가 세션 아이디 파일을 만들어 서비스가 돌아가고 있는 서버에 저장을 하는 것**
  - 즉, 프로세스들 사이에서 통신을 하기 위해 메시지 교환을 통해 서로를 인식한 이후부터 통신을 마칠 때까지의 기간동안 서버에 잠시 방문자 정보를 저장한다는 것. 세션이란 일정 시간동안 같은 사용자(정확하게 브라우저를 말한다)로 부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 일정하게 유지시키는 기술이라고 한다. 또한 여기서 일정 시간이란 방문자가 웹 브라우저를 통해 웹 서버에 접속한 시점으로부터 웹 브라우저를 종료함으로써 연결을 끝내는 시점을 말하며 즉, 방문자가 웹서버에 접속해 있는 상태를 하나의 단위로 보고 세션이라고 칭한다는 것.
  - 그래서 쿠키와 달리 세션은 사용자들의 로그인 정보에 대한 보안을 한층 업그레이드 할 수 있어 웹사이트에 방문하여 계속 접속을 유지할 때 이전의 접속 정보를 이용할 수 있는 방법으로 많이들 사용하는 것이다.
  - HTTP Session 동작 순서 : 클라이언트(사용자)가 서버로 접속(http 요청)을 시도 --> 서버(웹)는 접근한 클라이언트의 request-header field인 cookie를 확인해 클라이언트가 해당 session-id를 보내왔는지 확인 --> 만약 클라이언트로 부터 발송된 session-id가 없다면, 서버는 session-id를 생성해 클라이언트에게 response-header field인 set-cookie 값으로 session-id(임의의 긴 문자열)를 발행(응답)

- 참고 자료 : https://88240.tistory.com/190
  - https://hoonihoon.tistory.com/entry/%EC%BF%A0%ED%82%A4Cookie-%EC%99%80-%EC%84%B8%EC%85%98Session-%EA%B0%9C%EB%85%90


## JWT 토큰이란?
- 세션과 JWT 토큰 둘 다 모두 "인증"이 아닌 "권한" / "인가"와 관련된 기술이다.

- **먼저 세션으로 권한 및 인가를 허용하는 과정은 다음과 같다.**
  - 사용자가 로그인에 성공하면 세션을 발행
  - 그 세션 id를 브라우저에 쿠키로 저장하고 서버 메모리 또는 데이터베이스에도 세션을 저장
  - 인가가 필요한 요청을 보낼 때 서버에 쿠키인 세션 id를 보냄 
  - 서버에서 메모리 또는 데이터베이스에 저장된 값과 쿠키인 세션 id와 비교해서 맞다면 권한 및 인가를 허용

- **반면에 JWT(JSON Web Token)이란,** 
  - 예를 들어, eyJhbGciOiJIUzI1NiIsIn 이러한 형식이다. 사용자가 로그인을 하면 서버에서 토큰을 발행해주는 것으로, 이 토큰을 서버가 기억하고 있지 않는다.
  - 이 토큰은 암호화된 3가지 데이터를 이어붙인 형태(aaa.bbb.ccc)로 구성되어 있다. 
  - 첫번째로는 헤더 : 세번째 서명 값을 만드는데 사용하는 알고리즘과 type이 들어간다. ex) HS256 / JWT
  - 두번째로는 페이로드 : 토큰이 갖는 데이터를 의미.
  - 세번째로는 서명 : 1번 헤더에 정의된 알고리즘을 통해 암호화한 비밀 값으로 서버만 알고 있음

- **JWT 단점**
  - 세션처럼 모든 사용자들의 상태를 기억하고 있지 않기 때문에 기억하는 대상들의 상태를 항상 제어할 수 없다.
  - 이미 발행한 토큰이 해커한테 넘어가도 토큰을 무효화할 방법이 없다.

- **해결책으로 로그인 시 accessToken / refreshToken 이렇게 2개의 토큰을 발행해준다.** 
  - accessToken은 매번 인가받을 때 사용하는 토큰(수명이 짧다)
  - refreshToken은 accessToken의 수명이 다했을 때 accessToken을 재발행 받기 위한 토큰(보통 2주 정도 유지)
  - 누군가를 로그아웃시키려면 refeshToken을 db에서 지워버리면 되는데 그래도 accessToken의 수명 동안은 바로 차단할 방법은 없음

- 참고 자료 : https://velog.io/@syoung125/JWT-%ED%86%A0%ED%81%B0%EC%9D%B4%EB%9E%80


## 프로세스와 쓰레드에 대해서 설명해주세요 
- https://brunch.co.kr/@kd4/3#comment
- 프로세스는 운영체제로부터 프로세서, 필요한 주소 공간, 메모리 등 자원을 할당받는 작업의 단위이고 / 쓰레드는 한 프로세스 내에서 동작되는 여러 실행 단위로 프로세스가 할당받은 자원을 이용하는 실행의 단위이다. 그래서 같은 프로세스 내의 스레드끼리 자원을 공유한다.
- 멀티 프로세스로 할 수 있는 작업들을 굳이 하나의 프로세스에서 스레드로 나눠서 일을 하는 이유는, 운영체제는 시스템 자원을 효율적으로 관리하기 위해서 스레드를 사용하기 때문이다.
  - 프로세스 간의 통신보다 스레드 간의 통신 비용이 적어 작업들 간의 통신 부담이 줄어들게 된다.


## 자료구조란?
- 자료구조는 "데이터를 조직하는 방법"이라고 할 수 있다. 또는 "데이터를 표현하고 관리하고 처리하기 위한 구조"를 의미한다.


## wsgi란? wsgi를 사용하는 이유?
- WSGI는 Web Server Gateway Interface의 약자로, nginx와 같은 web server와 django라는 프로그램이 서로 소통할 수 있게끔 해주는 인터페이스이다. 대표적으로 gunicorn이라는 프로그램이 있다. 
- django의 runserver는 공식문서에서도 개발 및 테스트가 목적이기 때문에, 배포 환경에서는 보안에 대한 문제가 있어 사용하지 말라고 나와있다. 그래서 배포 환경에서는 wsgi를 통해서 서비스하도록 권장하고 있다.
- **wsgi를 쓴다면 django 등의 웹 프레임워크 기능을 할 수 있게 되는데, 여기에 nginx를 앞에 붙이면 더 좋은 성능을 낼 수 있다.** 
  - 가장 큰 이유로, nginx는 한 번에 들어오는 많은 요청들을 처리하여 로드 밸런싱 및 캐싱 기능을 해줄 수 있다는 점이다.
  - 몇몇 wsgi는 정적 파일을 지원하지 않기 때문에, nginx가 없다면 정적 파일을 django까지 요청이 도착한 다음에야 처리할 수 있으므로 성능이 저하된다.

- 참고자료 : https://uiandwe.tistory.com/1268


## Nginx와 Gunicorn 둘 중 하나만 사용해도 될까
- 클라이언트로부터 오는 HTTP 요청을 파이썬 스크립트가 요구하는 데이터 형식으로 변환하고 응답을 돌려줄 때도 파이썬 데이터를 HTTP 형식으로 바꿔주는 작업이 필요한데, 이 때 파이썬 앱 서버가 동작하는 기본적인 방식이 CGI, Common Gateway Interface이다. 그런데 CGI는 한 가지 문제점이 있었는데, 바로 요청이 들어올 때마다 파이썬 스크립트를 처음부터 실행한다는 것이다.
  - 그래서 이러한 문제점을 보완한 것이 WSGI(Web Server Gateway Interface)이고 웹 서버가 클라이언트의 요청을 받아서 스크립트에 전달해주면 스크립트는 스크립트 전체를 실행시키는 게 아니라 필요한 로직 하나만 실행한 후 결과를 응답해주는 식으로 동작함으로써 동적인 콘텐츠에 대한 요청에 빠르게 응답할 수 있게 해주는 것이다.
- 즉, WSGI는 별도의 프레임워크 같은 게 아니라, 동적인 데이터에 대응하기 위해서 웹 서버와 파이썬 웹 앱이 어떻게 서로 동작해야 하는지에 대한 내용을 담고 있는 specification이다.

- **Nginx가 필요한 이유** -> 정적인 파일 요청을 처리하고 reverse proxy server, load balancer 등의 역할을 수행하기 위해서
- **Gunicorn이 필요한 이유** -> 웹 앱에 HTTP 요청을 전달하고 응답을 되돌려주는 일을 할 WSGI server의 역할을 하기 위해서
- **Gunicorn만 써도 된다** -> Gunicorn이 WSGI middleware로서 웹 서버의 역할을 수행하기 때문에 Gunicorn만 써도 된다. 다만, Nginx가 제공하는 추가적인 혜택을 받지 못할 뿐이다. 
- **Nginx만 써도 된다** -> Flask나 Django 같은 프레임워크는 WSGI interface를 이미 어느 정도 구현해놓았기 때문에 프레임워크를 사용한다면 Nginx만 써도 된다. 다만 session, cookie, routing, authentication 등의 기능을 수행해주는 middleware의 역할을 하는 애가 없기 때문에 이 부분은 자기가 하드 코딩해야 한다.

- 참고자료 : https://velog.io/@jimin_lee/Nginx%EC%99%80-Gunicorn-%EB%91%98-%EC%A4%91-%ED%95%98%EB%82%98%EB%A7%8C-%EC%8D%A8%EB%8F%84-%EB%90%A0%EA%B9%8C


* * *
## 추가로 알고있어야 할 개념들
- [디자인 패턴 개념](https://velog.io/@syoung125/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-13%EA%B0%80%EC%A7%80)
  - [디자인 패턴 유튜브](https://www.youtube.com/watch?v=lJES5TQTTWE)
  - [python 싱글턴 패턴](https://wikidocs.net/69361)
- [Jquery를 사용하는 이유](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=seonsin25&logNo=30154924257)
- [좋은 내용 블로그](https://uzleem.tistory.com/23)
- [자료구조란](https://andrew0409.tistory.com/148)
- [컴파일러 vs 인터프리터](https://coding-factory.tistory.com/303)
- [기술 면접 가이드라인 github 저장소](https://github.com/JaeYeopHan/Interview_Question_for_Beginner)
- [컴퓨터에서 실수를 부동소수점 방식으로 처리](https://velog.io/@hyungraelee/%EC%8B%A4%EC%88%98%EC%9D%98-%EB%B6%80%EB%8F%99-%EC%86%8C%EC%88%98%EC%A0%90-%EC%A0%80%EC%9E%A5-%EB%B0%A9%EC%8B%9D)
- [운영체제 관련 개념](https://goodmilktea.tistory.com/23)
- [웹에서 매핑이란](https://threeidiotscoding.tistory.com/26)
- [render의 HttpResponse 리턴 vs redirect의 HttpResponseRedirect 리턴](https://milooy.wordpress.com/2016/03/03/pass-data-through-redirect-in-django/)
- [유니코드란](https://sweetday-alice.tistory.com/179)
- [데몬(daemon) 프로세스란](https://blogger.pe.kr/770)
- 배포 관련 
  - [Deploy 1](https://github.com/tkdqor/TIL/blob/main/Django/Django%20CRUD/Deploy%20(1).md)
  - [Deploy 2](https://github.com/tkdqor/TIL/blob/main/Django/Django%20CRUD/Deploy%20(2).md)
  - [Deploy 3](https://github.com/tkdqor/TIL/blob/main/Django/Django%20CRUD/Deploy%20(3).md)
  - [site deployment](https://github.com/tkdqor/TIL/tree/main/Django/taling/site%20deployment)
- DRF(Django REST Framework) 관련 내용
  - [DRF 내용](https://url.kr/vl82fg)
- [데이터베이스 인덱싱에 사용되는 자료구조인 B-Tree](https://han.gl/gRfHZ)


* * * 
## Impact museum 관련 내용

### 인바운드 규칙
- 인터넷을 포함한 외부 네트워크에서 EC2 인스턴스 또는 RDS로 향하는 정책

### 아웃바운드 규칙
- EC2 인스턴스 또는 RDS에서 인터넷을 포함한 외부 네트워크로 향하는 정책

### SSH
- 원격지 호스트 컴퓨터에 접속하기 위해 사용되는 인터넷 프로토콜 / 기본포트는 22번
- 이 SSH가 있어야 우리가 터미널을 통해서 우리가 만든 가상 server에 접근할 수 있음
- https://velog.io/@hyeseong-dev/%EB%A6%AC%EB%88%85%EC%8A%A4-ssh%EB%9E%80

### 기본 포트
- HTTP의 기본 포트는 80번 / django의 기본포트는 8000번
- https://dailyheumsi.tistory.com/19

### IPv4 
- Internet Protocol version 4의 약자로, 전 세계적으로 사용된 첫번째 인터넷 프로토콜이다. 32비트 방식으로, 4개로 나눠진 최대 12자리 번호로 되어있다.
- ex) 123.123.123.123

### IPv6
- internet protocol version 6의 약자로, IPv4 주소의 고갈문제를 해결하기 위해서 128비트를 채택하여 2의 128승의 개수만큼 주소를 만들 수 있는 프로토콜을 의미. 아직 완전히 적용되지는 않았음.

### TCP
- Transmission Control Protocol의 약자로 서버와 클라이언트간에 데이터를 신뢰성 있게 전달하기 위해 만들어진 프로토콜이다.
- 데이터를 전송하기 전에 데이터 전송을 위한 연결을 만드는 연결지향 프로토콜로, 데이터는 네트워크 선로를 통해 전달되는 과정에서 손실되거나 순서가 뒤바뀌어서 전달될 수 있는데, TCP는 손실을 검색해내서 이를 교정하고 순서를 재조합할수 있도록 해준다. 
- https://musclebear.tistory.com/2

