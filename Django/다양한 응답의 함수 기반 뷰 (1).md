## View
- 1개의 HTTP 요청에 대해 1개의 view가 호출됨. 2개 이상의 view를 호출할 수 없지만, 여러 주소가 1개의 view에는 연결가능하다.
- urls.py의 urlpatterns 리스트에 view를 매핑하게 된다.
  - **view는 호출 가능한 객체이다.** 그래서 함수의 형태로 구현할 수도 있고, 클래스 등 다른 호출가능한 객체 형태로 구현을 할 수 있다.

- 웹 클라이언트로부터의 HTTP 요청을 처리하거나 또는 웹 API 서버를 구축했다면, 안드로이드나 iOS 앱으로부터 HTTP 요청을 처리.


### View의 형태
- Django에서는 크게 2가지 형태의 view를 정의해 놓았다. 
  - 함수기반 view(Function Based View) : FBV라고 하며 django view의 기본. 호출 가능한 객체이다.
  - 클래스기반 view(Class Based View) : CBV라고 하며 클래스.as_view() 라는 함수를 통해 호출가능한 객체를 생성/리턴


### View 호출 시, 인자
- **1번째 인자 : HttpRequest 객체**
  - 현재 요청에 대한 모든 내역을 담고 있다.

- **2번째 인자 : URL Captured Values**
  - 현재 요청의 URL로부터 Capture된 문자열들
  - **urls.py에서 re_path() 함수를 통한 처리에서는 -> 모든 인자는 str 타입으로 전달**
  - **urls.py에서 path() 함수를 통한 처리에서는 -> 매핑된 Converter의 to_python에 맞게 변환된 값이 인자로 전달 / <int:pk> 이 부분이 Converter이다.(Converter도 정규표현식에서 정의한 하나의 작은 클래스이고 to_python이라는 function이 수행된다.)**
    - 4자리 년도를 위한 FourDigitYearConverter에서는 int 변환 -> view의 인자로 int 타입의 년도가 전달.

- **즉, re_path() 함수로 url를 처리하게 되면 무조건 문자열로 변수를 view로 전달을 하게 되지만 / path() 함수의 <int:pk>와 같이 해당 타입에 맞춰서 변환을 해서 변수를 view로 전달하게 된다.**


```python
from django.urls import path
from . import views


urlpatterns = [
    path('', views.post_list),
    path('1/', views.post_list),
    path('2/', views.post_list),
]
```

- 앱 내부 urls.py에서 ~/1 또는 ~/2 이렇게 n번 포스팅을 보고 싶게 url을 설정한다면, 그걸 일일이 위의 코드처럼 urlpatterns에 기록할 수도 있겠지만 계속 많아진다면 힘들 것이다.

```python

urlpatterns = [
    path('', views.post_list),
    path('<int:pk>/', views.post_detail),
]
```

- 그래서, 다음과 같이 설정해주면 여러 번 url를 설정하지 않아도 된다. <int:pk> 이러한 표현은 정규표현식으로 처리가 된다. 여기서 앞에 int는 타입이고 / pk는 변수를 의미한다. 따라서, 숫자 패턴이 나오고 슬러쉬로 끝날 경우에 post_detail 함수를 호출하겠다는 것이다.
  - **<int:pk>는 결론적으로 -> int는 패턴이름이라 정수패턴이 있으면 pk라는 이름으로 view 쪽으로 넘기겠다는 의미이다.** 이렇게 설정한 다음, 이제 post_detail이라는 view 함수를 정의하자.


```python
def post_detail(request, pk):
    pass 
    
    
```

- 이 때, 두번째 인자로 url쪽에서 넘겨준 pk 변수를 인자로 입력해서 받아주자. 그리고 이 인자를 URL Captured Values라고 한다.

* * *

#### re_path() 함수
- 옛날에는 urlpatterns에서 url() 이라는 이름으로 되어있었는데, 지금은 django2부터 re_path()로 바뀌었다. 
- 사용하려면 urls.py 위에서 import를 해줘야 한다.

```python
from django.urls import path, re_path
from . import views


urlpatterns = [
    path('', views.post_list),
    path('<int:pk>/', views.post_detail),
    re_path(r'(?P<pk>\d+)/$', views.post_detail),
]
```

- re_path()를 사용해서 url에서 int 변수를 받게끔 하려면 위와 같이 작성하면 된다. 해당 코드는 <int:pk>와 동일한 의미를 가진다.
  - 하지만 re_path()로 전달한 pk값은 문자열로 전달이 되고 / path() 함수로 전달한 pk값은 지정한 타입인 int, 정수로 전달이 된다.

- urlpatterns 부분은 우리가 다양하게 url도 하나의 문자열이기 때문에 우리가 원하는대로 pattern를 지정해서 처리할 수 있다.


## View 호출에 대한 return 값
- HttpResponse 객체를 무조건 반환해야 한다.
  - django의 Middleware에서는 View에서 HttpResponse 객체를 리턴하기를 기대한다. -> 만약 다른 타입을 리턴하면, Middleware에서 처리 오류.
  - settings.py에 보면 MIDDLEWARE라는 리스트가 있다. 특정 View 함수를 감싸는 여러 function들인데, DJango는 http 요청이 들어오면 미들웨어를 거쳐서 해당 URL에 등록되어 있는 뷰로 연결해주고, http 응답 역시 미들웨어를 거쳐서 내보낸다.

- django.shortcuts.render 함수는 템플릿 응답을 위한 shortcut 함수.
  - django.shortcuts에는 여러 function들이 있는데 이것들은 가급적이면 최대한 활용해보자.

- 파일like객체 혹은 str/bytes 타입의 응답 지원
  - HttpResponse 자체는 파일과 유사한 인터페이스를 지원해준다. 만약 응답으로 어떤 내용을 읽어서 쓰는 역할을 해야된다면, 

```python
def post_detail(request, pk):
    response = HttpResponse()
    response.write("Hello World")
    response.write("Hello World")
    response.write("Hello World")
    return response
```

- 이렇게 view 함수를 구성하고 새로고침해서 보면, Hello World가 나온다. 3번 연달아 작성하면 웹 브라우저에 다 연결해서 나온다. 이러한 인터페이스를 지원해주는데 이런 것이 나중에 스트리밍 HttpResponse handler 같은 것을 구현할 때도 활용할 수 있다.


```python

MIDDLEWARE = [
    'debug_toolbar.middleware.DebugToolbarMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]
```

- 위의 리스트중에서 하나를 자세하게 알아보자. 'django.middleware.csrf.CsrfViewMiddleware' 이 middleware의 경로를 확인해보자.
  - https://github.com/django/django 여기 django github에 들어가서, django 디렉터리 -> middleware 디렉터리 -> csrf.py 모듈 -> 해당 모듈안에 있는 class CsrfViewMiddleware(MiddlewareMixin): 가 있는 것을 확인할 수 있다. -> 그리고 이 클래스안에 def process_request(self, request): 라는 함수가 정의되어있다. 그리고 def process_view(self, request, callback, callback_args, callback_kwargs): 라는 함수도 정의되어있다. 마지막으로는 def process_response(self, request, response): 라는 함수까지 정의되어 있다.
  - 그래서 이렇게 어떤 함수를 호출할 때, request가 처리될 때 호출되는 부분도 있고 / view가 처리될 때 호출되는 부분도 있다. 그리고 process_response 함수는 해당 View가 리턴되고 나서 처리되는 로직이 된다.

- 미들웨어는 View 함수를 여러층으로 계속 감싸게 된다. 그래서 실제로 View 함수가 호출이 되면 미들웨어에서 먼저 Request를 처리하고, 그 다음 넘어가서 다음 미들웨어가 처리하고, 감싼 미들웨어가 다 처리한 다음에야 view 함수가 호출된다. 
- 그리고 view 함수가 반환한 값을 그 위에서 감싸고 있는 미들웨어가 받아서 처리하고, 다시 그 위의 미들웨어가 받고 처리하고, 마지막 미들웨어가 return한 것을 최종 응답으로 주게 된다.
  - 그래서 def process_response(self, request, response):에서 response를 받게 되면 -> 이 response를 처리하게 될텐데, 이 때에는 response가 다들 HttpResponse의 객체이다 라고 가정하고 동작하도록 되어있다. 

* * *

- views.py에서 함수를 정의할 때, 함수정의 후, pass라고만 적고 실행시켜보면 ->

<img src="https://user-images.githubusercontent.com/95380638/153703740-be222a1a-3c3a-49c4-a558-254a028d4e43.png" width="70%" height="70%">

- 다음과 같은 오류가 발생하게 된다. 즉, instagram앱의 views.py의 post_detail함수인데 HttpResponse를 리턴하지 않았다고 한다. 대신에 None를 리턴했다고 나온다. python은 아무것도 return 하지 않으면 None를 return 하는 것과 같다. 
- 만약, return 1 이렇게해서 함수를 정의해도 'int' object has no attribute 'get' 이라는 오류를 반환하게 된다.

```python
def post_detail(request, pk):
    return render(request, 'instagram/post_list.html')
```

- 만약 view 함수의 return를 위와같이 render 함수를 이용해서 작성하면 웹브라우저에 뜨긴 뜬다. 그런데, 
```python
def post_detail(request, pk):
    return render(request, 'instagram/post_list.html'), {}
```

- 이렇게 하게 되면 오류가 난다. render 함수의 시작과 끝은 render(request, 'instagram/post_list.html') 이렇게이니까 render의 반환값인 HttpResponse의 인스턴스가 되고 그 인스턴스, {} 이렇게 딕셔너리를 콤마 다음에 추가하니까 render(request, 'instagram/post_list.html'), {} 이 전체가 튜플을 리턴하게 된다. 그래서 이렇게 쓰면 안되고
```python
def post_detail(request, pk):
    return render(request, 'instagram/post_list.html', {})
```

- 이렇게 작성해야 한다.
    

