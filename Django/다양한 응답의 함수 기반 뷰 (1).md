## View
- 1개의 HTTP 요청에 대해 1개의 view가 호출됨. 2개 이상의 view를 호출할 수 없지만, 여러 주소가 1개의 view에는 연결가능하다.
- urls.py의 urlpatterns 리스트에 view를 매핑하게 된다.
  - **view는 호출 가능한 객체이다.** 그래서 함수의 형태로 구현할 수도 있고, 클래스 등 다른 호출가능한 객체 형태로 구현을 할 수 있다.

- 웹 클라이언트로부터의 HTTP 요청을 처리하거나 또는 웹 API 서버를 구축했다면, 안드로이드나 iOS 앱으로부터 HTTP 요청을 처리.


### View의 형태
- Django에서는 크게 2가지 형태의 view를 정의해 놓았다. 
  - 함수기반 view(Function Based View) : FBV라고 하며 django view의 기본. 호출 가능한 객체이다.
  - 클래스기반 view(Class Based View) : CBV라고 하며 클래스.as_view() 라는 함수를 통해 호출가능한 객체를 생성/리턴


### View 호출 시, 인자
- **1번째 인자 : HttpRequest 객체**
  - 현재 요청에 대한 모든 내역을 담고 있다.

- **2번째 인자 : URL Captured Values**
  - 현재 요청의 URL로부터 Capture된 문자열들
  - **urls.py에서 re_path() 함수를 통한 처리에서는 -> 모든 인자는 str 타입으로 전달**
  - **urls.py에서 path() 함수를 통한 처리에서는 -> 매핑된 Converter의 to_python에 맞게 변환된 값이 인자로 전달 / <int:pk> 이 부분이 Converter이다.(Converter도 정규표현식에서 정의한 하나의 작은 클래스이고 to_python이라는 function이 수행된다.)**
    - 4자리 년도를 위한 FourDigitYearConverter에서는 int 변환 -> view의 인자로 int 타입의 년도가 전달.

- **즉, re_path() 함수로 url를 처리하게 되면 무조건 문자열로 변수를 view로 전달을 하게 되지만 / path() 함수의 <int:pk>와 같이 해당 타입에 맞춰서 변환을 해서 변수를 view로 전달하게 된다.**


```python
from django.urls import path
from . import views


urlpatterns = [
    path('', views.post_list),
    path('1/', views.post_list),
    path('2/', views.post_list),
]
```

- 앱 내부 urls.py에서 ~/1 또는 ~/2 이렇게 n번 포스팅을 보고 싶게 url을 설정한다면, 그걸 일일이 위의 코드처럼 urlpatterns에 기록할 수도 있겠지만 계속 많아진다면 힘들 것이다.

```python

urlpatterns = [
    path('', views.post_list),
    path('<int:pk>/', views.post_detail),
]
```

- 그래서, 다음과 같이 설정해주면 여러 번 url를 설정하지 않아도 된다. <int:pk> 이러한 표현은 정규표현식으로 처리가 된다. 여기서 앞에 int는 타입이고 / pk는 변수를 의미한다. 따라서, 숫자 패턴이 나오고 슬러쉬로 끝날 경우에 post_detail 함수를 호출하겠다는 것이다.
  - **<int:pk>는 결론적으로 -> int는 패턴이름이라 정수패턴이 있으면 pk라는 이름으로 view 쪽으로 넘기겠다는 의미이다.** 이렇게 설정한 다음, 이제 post_detail이라는 view 함수를 정의하자.


```python
def post_detail(request, pk):
    pass 
    
    
```

- 이 때, 두번째 인자로 url쪽에서 넘겨준 pk 변수를 인자로 입력해서 받아주자. 그리고 이 인자를 URL Captured Values라고 한다.

* * *

#### re_path() 함수
- 옛날에는 urlpatterns에서 url() 이라는 이름으로 되어있었는데, 지금은 django2부터 re_path()로 바뀌었다. 
- 사용하려면 urls.py 위에서 import를 해줘야 한다.

```python
from django.urls import path, re_path
from . import views


urlpatterns = [
    path('', views.post_list),
    path('<int:pk>/', views.post_detail),
    re_path(r'(?P<pk>\d+)/$', views.post_detail),
]
```

- re_path()를 사용해서 url에서 int 변수를 받게끔 하려면 위와 같이 작성하면 된다. 해당 코드는 <int:pk>와 동일한 의미를 가진다.
  - 하지만 re_path()로 전달한 pk값은 문자열로 전달이 되고 / path() 함수로 전달한 pk값은 지정한 타입인 int, 정수로 전달이 된다.

- urlpatterns 부분은 우리가 다양하게 url도 하나의 문자열이기 때문에 우리가 원하는대로 pattern를 지정해서 처리할 수 있다.


## View 호출에 대한 return 값
- HttpResponse 객체를 무조건 반환해야 한다.
  - django의 Middleware에서는 View에서 HttpResponse 객체를 리턴하기를 기대한다. -> 만약 다른 타입을 리턴하면, Middleware에서 처리 오류.
  - settings.py에 보면 MIDDLEWARE라는 리스트가 있다. 특정 View 함수를 감싸는 여러 function들인데, DJango는 http 요청이 들어오면 미들웨어를 거쳐서 해당 URL에 등록되어 있는 뷰로 연결해주고, http 응답 역시 미들웨어를 거쳐서 내보낸다.

```python

MIDDLEWARE = [
    'debug_toolbar.middleware.DebugToolbarMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]
```

- 위의 
