## 트랜잭션과 락


### 결제 수행 과정
1. 고객이 원하는 일자와 시간을 선택
2. 예약정보입력 페이지로 이동 후 예약자명, 전달사항을 적는 폼 페이지에서 관련 정보를 입력
3. 예약 보증금 결제 처리 -> 이 때 결제처리과정을 거치게 됨
   - **a) PG사에 결제 요청** / PG사는 Pay Gateway의 약자로 여러가지 결제 인증 업체들이 있다. 우리가 계죄이체할 때, 한국에 있는 20개가 되는 은행들과 연동을 해야 계좌이체가 발생한다. 카드결제 시, 카드사 같은 경우도 
     10개가 넘어간다. 이렇게 많은 결제 업체들, 즉 결제 수단을 제공하는 그런 회사들이 있다. 이 회사들에 있는 정보랑 통신들을 전부 다 매핑을 해서 우리가 이커머스 사이트를 운영할 때 결제 모듈을 불러와서 
     쓸 수 있게 해주는 게 바로 PG사의 역할이다. 따라서 PG사의 경우에는, 우리가 그냥 PG사에 연동만 해놓으면 그러한 다양한 결제 수단 업체들에 대한 요청을 보낼수가 있고, 인증도 걸쳐서 결제를 진행할 수
     있게 되는 것이다. 그래서 이 a 단계는 결제창을 여는것부터 시작한다. 그래서 우리가 상품을 구매할 때 --> 결제 화면이 열리면서 거기서 카드를 선택하거나 은행을 선택하거나 했을 것이다. 그렇듯이 그렇게
     창을 여는 단계라고 생각하면 된다. 
   - **b) 다음으로는 카드 결제의 경우 카드 인증 단계가 있다. 또한, 계좌이체의 경우 공인인증서를 인증하는 단계가 있을 수 있다. 휴대폰 결제는 휴대폰 인증이 있고 상품권 결제는 상품권 인증이 있다.** 
     가상계좌의 경우에만, 한번에 끝나기 때문에 가상계좌는 별도의 인증 단계를 거치지 않는다. 보통 이러한 인증수단들은, 예를 들어 카드 결제를 할 경우에는 현대카드이면 현대카드, 삼성카드면 삼성카드, 
     롯데카드면 롯데카드, 이런식으로 해당 카드 업체에 서버를 통해서 인증이 이루어지게 된다. 
   - **c) 다음으로는 데이터베이스에 예약 내역을 입력하는 단계이다. 해당 DB는 우리쪽 DB를 의미한다.** 인증된 값을 우리의 웹 서비스에서 실제로 결제할 금액과 매핑을 해서 검사를 한 뒤에, 이 데이터가 
     유효하게 완성이 되어있으면,
   - **d) 최종적으로 결제 승인 요청을 PG사한테 보내면, 그 PG사가 위에서 인증한 카드사나 은행들한테 인출을 해달라고 연락을 하는 단계가 된다.** 
   - **정리해보면 a 단계는 결제에 필요한 값들을 입력받는 단계 / b 단계는 결제 수단에 대해서 내가 실제로 소유자인지 아닌지를 인증하는 인증단계 / c 단계는 우리쪽에서 데이터베이스에 데이터를 입력하는 단계 / d 단계는 모든 조건이 만족하고 유효성이 검증되면 마지막으로 우리 서버에서 PG사한테 연락을 해서 결제를 해줘 라고 연락하는 단계이다. 그러면 PG사가 알아서 결제를 처리하게 된다.**
     - 여기서 말하는 c와 d단계는 순서가 바뀌어도 무방한 단계이다.  


### 결제 수행 과정 시, 문제 발생
- **유저 여러 명이 하나의 남은 좌석을 가지고 결제하는 경우, 먼저 결제가 끝난 유저 외의 다른 유저는 위의 단계를 동시에 거치고 있다면 d 단계까지 왔을 때, 오버 부킹이 되는 이슈가 있다.**
- 이런식으로 제한된 자원을 가지고 여러 사람들이 경쟁하는 상황을 **Race Condition**이라고도 한다. **특히 최종 결제 승인이 처리될 때, 실패하는 경우가 있을 수 있다. 이럴 경우에는 c 단계를 어떻게 돌아갈 것이냐, 즉 예약 내역 입력을 어떻게 해야하지? 이러한 생각이 들게 된다. 결제 발생이 실패를 했는데, 우리의 DB에는 예약이 된 것으로 입력이 되어있는 그런 상황이 발생할 수 있다는 것이다.**


### 개선된 예약 수행 과정
- 위의 문제들을 조금 개선해보자면,      
**1. 처음에 우리 DB에 예약 내역을 먼저 입력한다.(우리 서버)** 그래서 우리 서버에 먼저 기록을 해둔다.     
**2. 고객이 그 다음에 결제창을 띄워서 PG 결제를 요청한다.(PG사 서버)**      
**3. 카드 결제의 경우, 카드 인증을 하고 다른 수단도 인증을 거친다.(카드사 또는 은행 서버 등등)**      
**4. 최종 결제 승인을 거치고(실 결제 발생)(우리 서버)**     
**5. 승인이 끝나고 나면 우리 서버 DB에 있는 예약 내역을 성공으로 업데이트를 하는 것이다.**      
- 여기서 2번과 3번은 우리 서버에서 일어나는 이벤트가 아니다. 그러다보니까 이 2번과 3번을 거치기 전에 우리쪽에 먼저 1번으로 누군가가 찜해놓았다 라는 표식을 남겨둬야 다른 사람이 여기서 들어올 때 이걸 보고 아직 내가 들어올 차례가 아니구나 라고 대기를 탈 수 있게 된다. 
- **그 다음 4,5번에서 마무리를 짓는 것이다. 그런데 이러한 수행 과정도 사실 중간에 하나라도 실패한다면, 전체가 실패 해야하는 그런 조건을 가지고 있다. 이렇게 수행되는 시간이 다르지만, 한 번에 묶음처리 되어야 하는 것을 트랜잭션이라고 부르게 된다.** 
  - 여기서 말하는 결제 요청과 카드 인증은 사용자 입력이 필요하고 그리고 우리 서버에서 일시적으로 이루어질수는 없기 때문에 코드상으로는 하나의 트랜잭션 구현이 불가능하지만, 이렇게 앞에 1번 단계를 둠으로서 비슷한 효과를 줄 수 있게 되는 것이다.
  - 그래서 1번에서 데이터를 선점 입력하는 것에 실패한다면, 결제를 진행하지 않게 된다. 하지만, 코드상에 트랜잭션으로 실제 구현하려면 하나의 메소드내에 연달아 로직이 수행되어야 하므로 **코드 상 트랜잭션은 1번 그리고 4,5번이 된다.** 2,3번은 각각 우리 사이트에서 벗어나서 다른 사이트로 이동하는 과정이므로 우리가 트랜잭션을 유지할 수는 없어서 1번에서 선점하는 식으로 보완을 하는 것이다. 


### 트랜잭션의 정의
- **트랜잭션을 명확하게 정의하자면, 처리과정 이라고 할 수 있다. 그리고 컴퓨터 사이언스 분야에서 트랜잭션은 "쪼개질 수 없는 업무처리의 단위"를 의미한다.**
- **그 외에도 데이터베이스 충돌을 해결하기 위해서 둘 또는 그 이상의 데이터베이스 업데이트를 단일화된 작업으로 처리하는 기법을 의미한다. 작업을 모두 완료하면 그 때서야 최종적으로 적용을 시키게 된다. 이 과정을 "커밋"이라고 한다.**
- **하나라도 내부에 있는 작업이 실패하게 되면, (하나의 수정작업 update가 실패하면) 트랜젝션 상의 모든 업데이트가 취소가 된다. 즉, 모든 업데이트가 실패 이전 상태로 복구된다. 이것을 "롤백"이라고 부른다.**

- 그래서 우리가 "데이터베이스의 트랜잭션" 이라고 한다면 -> 우리 DB에 데이터를 업데이트 치고 그 과정이 한 묶음으로 떨어져서 중간에 하나라도 실패하면 돌아가는, 그 하나의 실행단위를 트랜잭션이라고 부르기도 한다.
  - 그런데 조금 더 폭 넓게 보자면 -> 데이터베이스 뿐만 아니라 결제 과정 / 송금 과정 이런식으로 어떤 자금 흐름의 하나의 인출 단위도 트랜잭션이라고 부르기도 한다. 컴퓨터 프로그래밍에서도 굳이 DB에 데이터 처리를 직접적으로 하지 않더라도 **"코드를 한 단위로 수행하는 것"**을 트랜잭션이라고 보면 된다.** 예를 들어, **API가 호출이 되서 응답까지 나가는 하나의 처리 단위**도 트랜잭션이라고 부르기도 한다. 


### TPS(초당 트랜잭션)
- **그래서 TPS라는 개념이 존재 : Transaction Per Second의 약자로서, 1초 당 처리할 수 있는 트랜잭션의 개수를 의미한다.** 
- 예를 들어, 실제로 API가 호출이 되서 응답이 될 때 그 하나의 단위를 트랜잭션이라고 보고, 1초 당 API가 호출되는 카운트를 의미하기도 한다.
- 대신에 TPS를 DB에 다시 대입해서 생각해보면, DB가 동시에 처리가능한 트랜잭션의 수가 될 수도 있다.
  - **우리가 이번에 배울 내용은 데이터베이스에 한정해서 그리고 django에서 데이터베이스 작업을 하나로 묶어서 처리하는 그 단위를 일컬어서 트랜잭션을 설명하려고 한다. 나중에는 더 공부하면 TPS가 다양한 개념과 함께 넓은 의미로 쓰이게 된다.**


### 트랜잭션 규칙 - ACID
- 트랜잭션은 이러한 규칙을 준수해야 된다는 것이 있다. 많은 데이터베이스가 백엔드 프레임워크가 이런 특성을 고려해서 구현하거나 설계되어 있다. 이걸 앞 글자를 따서 ACID라고 한다.
**1. Atomicity(원자성)** : 트랙잭션의 작업이 모두 수행되거나 혹은 모두 수행이 안되거나 이다. 하나의 트랜잭션 안에 여러가지 코드가 들어가 있고 여러가지 오퍼레이션이 수행되더라도 그 중 하나라도 실패한다면 아무것도 실행이 안되는 상태가 보장이 되어야 한다는 것이다.
**2. Consistency(일관성)** : 트랜잭션이 수행되는 순간에는 여러번 읽더라도 데이터베이스의 상태가 똑같해야 한다는 것이다. 예를 들어, 내가 트랜잭션을 시작했는데 거기있는 값이 일관성없이 이리저리 바뀌게 된다면 트랜잭션이 수행되는 동안에 내가 보고있는 데이터가 변질이 계속 되는 것이다. 그러면 일관성이 없다고 볼 수 있다.
**3. Isolation(독립성, 고립성)** : 하나의 트랜잭션이 수행되고 데이터를 갱신하는 동안에는 이 트랜잭션이 완료되기 전에 갱신중인 데이터에 다른 트랜잭션이 접근하지 못하게 해야한다는 것이다. 내가 어떤 데이터를 막 수정하고 있는데 다른 애가 와서 덮어쓰고 내가 수정하려고 하면 내껄 날려버리고 이러면 안될 것이다.
**4. Durability(지속성)** : 트랜잭션이 끝나고 나면 커밋이 마무리가 되고 그 갱신 사항이 이후에도 계속 유지되고 적용되어야 한다는 것이다. 


### django의 트랜잭션
**1) 함수 선언에 transaction.atomic 어노테이션을 사용하는 경우**

```python
from django.db import transaction

@transaction.atomic
def transaction_test1(arg1, arg2):
   # start transaction
   a.save()

   b.save()
   # end transaction
```

- 이런식으로 함수 단위로 묶을 수 있다. 

**2) 또한, 코드 블록(코드 안에)에 with transaction.atomic() 사용**

```python
with transaction.atomic():
     # start transaction
     b.save()
     c.save()
     # end transaction
```

- 이렇게 코드 중간에 with transaction.atomic():를 사용해서 이 안에 있는 블록을 하나의 트랜잭션으로 묶을수도 있다.


### 잠금(Lock)과 잠금 단위
- **그러면 이제 이러한 개념들이 실제 DB에서 어떤식으로 관리되고 처리될 수 있는지를 보자. DB에서는 이를 위해서 Lock이라는 개념을 제공하고 있다.** 
- Lock은 공유 Lock과 배타 Lock 2가지로 볼 수 있다.
  - **Share Lock(공유 잠금)** : Lock를 잡더라도 다른 트랜잭션에서 읽을 수가 있다. 하지만 쓰는 것은 불가능하다.
  - **Exclusive Lock(배타 잠금)** : 이러한 배타 잠금이 한 번 잠기면, 다른 트랜잭션에서 이 데이터를 읽을 수가 없고 쓰는 것도 불가능하다. 이 배타 잠금이 풀릴때까지 기다려야 한다.

- **다음으로 Lock를 잠글 때, 어떤 단위로 Lock를 잠글 것인지를 결정하는 "잠금 단위"가 있다.**
- 데이터베이스 / 테이블 / 레코드 범위(Gap Lock) / 레코드 / 필드 (왼쪽이 크고 로직이 간단한 것부터 시작해서 오른쪽으로 갈 수록 작고 동시성이 확보가 된다)
  - 이렇게 잠금 단위가 클수록 "무결성"이 더 보장되는 특징이 있다. 
  - **데이터베이스는 sqlite가 비슷한 형태가 된다. 우리가 프로덕션 서비스를 운영하게 될 때는 sqlite를 사용하기에는 어렵다고 얘기했는데, 하나의 파일을 여러 요청이 공유하기 때문이다.** 그래서 내가 어떤 요청을 데이터베이스에 보내게 되면 하나의 요청만 동시에 처리할 수 있고 다른 요청을 동시에 처리할 수가 없어서 다른 요청이 들어오게 되면 sqlite는 하나의 파일로 이루어져 있다 보니까 파일 잠금 현상이 일어나서 하나의 파일에 대해서 여러 요청이 동시에 처리될 수 없는 그런 단점을 가지고 있는 것이다. 대신 이 경우에는 무결성이 보장될 것이다. 그리고 구현도 간단할 것이다. 
  - **필드로 가게 되면, 레코드를 가로로 1개 그려봤을 때 -> 하나의 레코드는 여러 필드를 가질 수가 있는데(캡처 참고), A라는 요청이 들어와서 하나의 필드값을 수정했으나 동시에 또다른 B라는 요청이 들어와서 다른 필드값을 수정할 수도 있는 것이다. 그러다보니까 동시에 여러 요청을 처리할 수 있다 해서 "동시성이 높다"는 표현을 할 수 있는 것이다.**


### 데이터베이스 락
- 데이터베이스에 대한 락을 조금 더 자세하게 살펴보자. **이 데이터베이스가 락을 잡을 때, 어떤 모드로 락을 잡는지 단계별로 설명이 필요하다.** 우리가 사용하고 있는 RDBMS인 MySQL 기준으로 설명을 이해해보자. 다른 DB들도 비슷한 형태의 레벨을 가지고 있다. **그래서 MySQL의 Isolation level, 격리 수준에 대해서 이해를 하고 있다면 나중에 다른 DB를 공부할 때도 이해할 수 있을 것이다.**

- 각 레벨을 Isolation level, 격리 수준(레벨)이라고 한다. 아래로 갈수록 더 강한 격리 보장성을 가지고 있다.

**1. READ UNCOMMITTED** : commit이 아직 안되었는데 다른 트랜잭션에서 접근이 가능한 경우이다. 그래서 Lock이 없다. (Dirty Read 발생) 
- ex) 트랜잭션이 발생해서 어떤 레코드가 가로 1줄로 있는데, 여기에 처음에는 0이 있었다. T1인 트랜잭션 첫번째가 여기에 들어와서 트랜잭션을 시작하고 1로 수정했다. 그리고 아직 트랜잭션을 진행하고 있다. 이 과정에서 갑자기 T2인 트랜잭션 2번이 들어온다. 이 T2가 이 값을 읽어온다. 그러면 1을 가지고 온다. 근데 여기서 T1 트랜잭션이 실패를 한다. 그러면 롤백이 되서 값이 0으로 돌아가게 된다. 이 때 T2가 수행중에도 다시 접근했을 때 0이라는 값으로 다시 불러오게 된다. 
  - **이 예시에서는 Dirty Read 개념을 볼 수 있다.** 
    - 이건 T1에서 트랜잭션을 수행중인 경우, 아직 commit이 끝나지 않은 중간 데이터를 다른 트랜잭션이 멋대로 가져다가 쓸 수도 있고 멋대로 덮어쓰기를 할 수도 있다, 그래서 트랜잭션이 전혀 보장이 되지 않는다는 것이다. 즉, Dirty Read는 다른 트랜잭션이 수행중인 아직 커밋이 되지 않은, 아직 완성되지 않은 중산 산출물을 다른 트랜잭션이 맘대로 가져갈 수 있고 이 값이 변할 수 있다는 것이다.


**2. READ COMMITED** : 이제 위와같은 문제를 보완하고자 나온 것이다. 여기서는 인덱스만 Lock를 건다.
- 위에서 T2가 처음에는 1로 읽었다가 T1이 롤백된 이후에 읽었을 때는 0으로 읽었다고 했다. 이렇게 반복적으로 읽을 때, 다른 값이 나오게 되는 것을 **Non Repeatable Read**라고 한다. / Dirty Read는 다른 트랜잭션이 변경하기 전에 예비 단계에 있는 데이터를 내가 읽어버리는 걸 뜻한다.
   - **즉, 어떤 트랙잭션이 하나의 데이터를 이전에 읽었을 때랑 그 이후에 읽었을 때, 하나의 트랙잭션내에서 자꾸 이 값이 변경되는 것을 Non Repetable Read라고 한다는 것이다.**

- **다시 READ COMMITED는 commit이 끝난 데이터만 볼 수 있는 것을 의미한다. 그래서 Dirty Read를 방지한다.** 
  - ex) T1이 1번을 입력할 예정이지만 아직 commit를 안했다면, 그 때 T2가 읽는 시점에서는 값이 0이 된다. 그래서 dirty read가 발생하지 않았다. 그리고나서 commit한 다음에 값을 1로 바꿔놓았을 때는 아직 T2 트랜잭션은 실행이 되고 있고, 마지막 단계에 와서 그 데이터를 다시 읽어보면 1로 바꾸어져 있는 것이다. **그래서 여전히 Non Repetable Read는 발생하게 된다.**

- **추가로 Phantom Read라는 개념이 있다.** 
  - 트랜잭션 1인 T1이 있는데, 레코드를 가로 1줄 새롭게 생성하려고 한다. 근데 아직 생성은 안했다. 커밋이 끝나지 않았기 때문이다. 이 상황에서 T2가 등장한다. 그래서 T2가 처음에 읽었을 때는 레코드가 1개였다. count 메소드를 사용했을 때도 이 테이블의 가짓수가 1개라고 나왔다. 레코드의 개수가 1개라고 알고 있었다. 그래서 T2가 진행하고 있는데, T1의 commit이 발생했다. 그러면 테이블의 레코드 개수가 2개가 된다. 그래서 T1이 커밋이 끝난다음에 T2가 count를 다시 하면 2로 바뀌어있다. 이렇게 T2의 생성시점과 끝시점에서 같은 트랜잭션인데도 모르는 데이터가 갑자기 생겨있는 상황을 Phantom Read라고 한다. 
  - 이러한 Phantom Read는 데이터의 추가인 insert뿐만 아니라 delete로 인해 갑자기 레코드가 사라지는 것도 포함되는 개념이다. 


**3. REPEATABLE READ (MySQL 기본값)
- **이걸 또 보완해서 REPEATABLE READ가 등장한다. SELECT시 현재 시점의 스냅샷을 만들고, 그 스냅샷을 조회해서 Non Repeatable Read를 방지하는 방법이다. 그래서 동일 트랜잭션 내에서 일관성을 보장해준다.**
- **Record Lock이 발생한다는 게 주요 차이점**이다. 
  - READ COMMITED는 commited 이후에는 다른 트랜잭션이 조회할 수 있게 하기 위해서 단순히 index만 Lock를 거는 특징이 있다. 그래서 변경이 일어나거나 insert가 일어나거나 이럴 때 그 Lock를 다른 얘들이 insert등을 하지 못하도록 그냥 인덱스만 Lock를 걸고 있다. 
  - 반면에 REPEATABLE READ는 직접적으로 하나의 레코드에 대해서 Lock를 잡는 Record Lock를 진행해서 내가 어떤 레코드에 대해서 Lock를 잡아버리면, 다른 트랜잭션에서는 첫번째 트랜잭션이 끝나기 전까지는 아무것도 못하는 그런 상황이 생기게 된다.

- **그리고 Non Repeatable Read를 방지하는 방법이 있다.** 트랜잭션 1인 T1이 있다고 하자. T1이 데이터를 가져가면서 복사본을 하나 더 만든다. 그리고 T1이 write를 친다고 하면 그 데이터까지 잡을 수 있게 되는데, 이 상태에서 스냅샷을 하나 찍게 된다. 둘다 값이 1이면 1인 상태로 가지고 있는 것이다. 이 때, T2가 온다. 그 사이에 T1은 값을 2로 업데이트를 쳤다. 이 상태에서 T2가 해당 데이터를 읽을 때 Record Lock이 걸려있기 때문에(만약 배타 Lock이면 대기를 타고 있을 것이고, 쉐어 Lock이면 읽을수는 있지만 업데이트를 할 수는 없다) 값이 1번인 상태를 그대로 보존하고 있게 된다. 그리고 이제 T1에서 커밋이 끝났다. 그럼 이제 값들이 2번으로 업데이트가 된다. 이 때, T2에서 다시 읽어보면 값이 1번으로 보장(고정??)되어 있다. 그러니까 내가 읽는 시점의 데이터 값이 그대로 보존되어 있는 것이다. 그래서 T1에서 커밋을 치더라도 T2에서는 스냅샷이 있으니까 계속 똑같은 데이터를 읽게 되는 것이다. 대신에 내가 Lock인 상태에서 데이터를 가져왔기 때문에, Record Lock에 걸려있는 상태이기 때문에 일단 업데이트는 놓치제 되는 것이다.(데이터 최신값을 모르게 된다) 이렇게 Non Repetable Read를 방지하게 된다. 

- **하지만 여전히 Phantom Read는 발생한다. 다만, MySQL에서는 Next Key Lock 이라는 것을 통해 다음 키의 행이 생기는 걸 미리 Lock으로 잡아줄 수 있다.**
  - 예를 들어 1개 테이블의 레코드가 3개가 있다면, 그 다음에 어떤 데이터가 추가되거나 아니면 내가 어떤 데이터까지만 읽겠다라고 정의를 해놓고 Lock를 잡아놓을 수 있다. 4번 레코드는 Next Key로 Lock를 잡아두는 것으로 T1이 4번을 잠그고 있다면, T2에서 데이터 insert를 넣더라도 5번으로 넣게 되는 것이다. T1의 key lock이 풀려야지 T2의 insert가 수행이 되므로서 자동적으로 데이터가 3개일 때, 트랜잭션이 양쪽에서 수행이 되었어도 T1이 먼저 수행이 되고 T2가 그 다음에 수행이 되는 이런식의 Next Key Lock이 가능하다는 것이다. 
  - 즉, Next Key Lock은 insert, update 등을 위해 조회하려는 범위를 다음 인덱스 위치까지 락을 잡아서 읽는 동안의 팬텀리드를 방지하는 것이다.


**4. SERIALIZE**
- **가장 강력한 격리 레벨이다. 일단 SELECT 구문이 실행이 되자마자 해당 테이블이 전부 다 잠겨버린다. 즉, SELECT 문에 사용하는 모든 테이블에 베타 Lock이 발생한다.**
- 그래서 다른 트랜잭션인 T2가 들어오더라도 T1의 작업이 끝날때까지 T2는 계속 기다리고 있어야 한다. 그래서 해당 데이터 테이블에 접근조차 하지 못한다. 그리고 T1의 작업이 끝나고나서야 T2도 똑같이 베타 Lock으로 잠궈서 작업을 할 수 있게 된다. 
- 이 경우에는 동시성이 엄청 많이 떨어지게 된다.

- 이러한 격리 수준에 따라서, 위쪽으로 갈수록 성능과 동시성이 늘어나고 / 아래쪽으로 갈수록 고립성과 무결성이 늘어난다. 

* * *

### 데이터베이스 트랜잭션 무효화 Case (갱신 분실)
- 이제는 데이터베이스의 몇몇 문제들에 대해서 알아보고, 그것의 해결책을 어떻게 데이터베이스에서 구현을 했는지 알아보기
- **갱신 분실(캡처 참고)**
  - 첫번쨰는 갱신 분실이라는 개념이다. 먼저 DB에 좌석이 8개이고 총 매출이 1000인 레코드가 1개 있다고 하자. 그리고 첫번째 트랜잭션인 T1이 read를 한다. 그리고 좌석 8개에서 2개를 뺀다. 그러면 값이 6이 된다. 근데 그게 끝나지 않았을 때, T2가 8을 읽어오게 되고 좌석 8개에서 +1을 해서 값이 9가 된다. 근데, T2가 update를 치기전에 T1의 update가 먼저 발생하게 된다. 그리고나서 T2가 update를 하게 된다. 그러면 좌석의 값은 9가 되어버린다. 
  - 동일하게 밑에 있는 가격도 T1은 +1000을 해주고 update를 먼저해서 2000이 되고 T2가 T1이 끝나지 않았을 때 read를 해서 -500을 하고 update를 하면 총 매출은 500이 된다. 여기서 T1의 update가 먼저 발생하게 되서 그 때는 2000이지만, 그리고나서 T2의 update가 발생해서 총 매출은 500이 되어버린다. **즉, 우리가 원하는 결과와는 다른 상황이 되어버려서 마지막에 수행된 겹치는 T2 트랜잭션이 최종 결과를 다 덮어씌워 버린다.**
  - 이 경우에 만약 롤백이 발생하면 더 골치아파진다. ex) 만약 T1에서 총 매출 +1000이 중간에 실패를 했다면, 근데 이 타이밍이 살짝 어긋나서 T2가 발생이 끝났는데 갑자기 T1에서 롤백이 발생해서 처음으로 돌아가게 되어버리면 -> DB 데이터 1개에 연결된 모든 트랜잭션인 T1,T2 전부 다 롤백이 되어버린다. **이렇게 롤백이 이루어질 때 모든 트랜잭션이 롤백되는 경우를 "연쇄 복귀"라고 한다.**
  - **아니면 T1의 +1000에서 실패해서 롤백을 했는데, 도중에 T2 트랜잭션이 commit를 쳐버려서 뭔가 좌석은 8개인데 총 매출은 500이 되는 꼬여있는 상태가 될 수도 있다. 이런 상황을 "회복 불가능" 상태라고 한다.**
  - 이렇게 트랜잭션끼리의 관계에서 롤백이 되고, 커밋이 되고 이게 꼬이게 되는 이런 상황이 발생할 수 있다는 말이다. 


- **갱신 분실 해결 과정 - 데이터베이스 락 사용**
  - **그래서 이 문제를 해결하기 위해 락이 등장한다.** T1이 처음에 DB 데이터를 read하면서 Lock를 잡는다. 좌석 8개를 가지고 와서 -2를 하는 순간에 T2가 접근을 한다. 근데 Lock를 잡고 있으니까 waiting으로 T2는 기다리게 된다. 그래서 T1이 update를 하고 unlock 이렇게 lock를 풀면, 그제서야 T2가 read를 하고 +1를 하고 lock를 잡을 수 있게 되는 것이다. 이 때 읽어오는 값이 6이 되니까 결과는 +1해서 7이 되는 것이다. 
  - 그리고 T1도 T2가 lock를 잡고 있으니까 한번 더 waiting으로 기다려야 한다. T1이 총 매출에 +1000을 하려면 lock를 잡아야 하는데 지금은 T2가 잡고 있기 때문이다. 그래서 T2가 좌석값을 7로 바꾸는 update를 한 다음에 unlock를 한다. 그러면 그 때 다시 T1이 read를 하고 lock를 잡을 수 있게 되는 것이다. 그리고나서 T2가 다시 총 매출을 -500하려고 접근하면 waiting를 하게 된다. 그러면 T1이 +1000을 하고 update를 하고 unlock를 하면, T2가 그제서야 read한 다음에 -500를 하고 update를 할 수 있게 된다. **그래서 최종 결과가 좌석은 7개 / 총 매출은 1500으로 알맞게 나오게 된다.**
  

- **이렇게 되면 정말 이상적이지만, 여기서 문제가 발생할 여지가 1개 더 있다. DB에 있는 좌석: 8 / 총 매출: 1000이 서로 다른 A 레코드 / B 레코드라고 가정해보는 것이다. 그리고 T2의 로직 순서가 바뀐다고 생각해보자. 총 매출 -500이 먼저고 / 좌석 +1이 그 다음이다.**
  - 이 상태에서 T1이 먼저 좌석-2를 해야되니까 A를 read하고 lock를 한다. 그리고나서 T2에서 총매출-500를 해야되니까 B를 잡아서 read하고 lock를 한다. 그리고나서 T1에서 update/unlock를 하는 게 아니라 바로 총매출+1000를 하게 된다고 생각해보자. 그래서 lock를 풀지않고 바로 +1000를 하고자한다. 그래서 T1에서 B를 read하고 lock를 잡으려고 했는데 -> T2가 이미 B를 잡고있으니까 못잡게 된다. 그래서 B에대한 waiting이 된다. 그래서 B에 대한 lock이 실패하게 되고 기다리는 상태가 된다. 이어서 T2가 총매출-500에 이어서 바로 좌석+1를 하려고 A를 read/lock하려고 한다. 근데 이미 T1이 A를 read/lock를 잡고있기 때문에 그래서 T2가 실패하게 된다. T2도 waiting상태가 된다. 
  - 이렇게 되면, 이 상태에서 끝나게 된다. 더 이상 진행이 되지 않는다. 왜냐면, 선결조건이 하나도 만족하지 않는다. 도중에 lock를 풀었으면 괜찮았을텐데 T1/T2 둘 다 lock를 안풀고 T1에서는 A lock를 먼저 잡고 B lock를 잡으려고 했고, T2에서는 B lock를 먼저 잡고 A lock를 잡으려고 했다. 그래서 순서가 2개가 엇갈린 상태로 수행이 되서 A랑 B는 성공적으로 잡혔지만, 각각 다음 B랑 A를 잡으려고 할 때 코드들이 멈추게 된다. 그래서 둘다 멈춤상태가 된다. T2에서 트랜잭션을 끝내려면, A를 lock으로 잡아야지 나중에 B도 풀고 A도 풀게 되는데, A가 안 잡히니까 그냥 그 상태로 기다리고 있는 것이다. T1도 마찬가지이다. 
  - **그래서 이런식으로 교착 상태에 빠지는 것을 데드락 (Deadlock)이라고 한다.** 즉, 락 실행 타이밍이 맞지 않을 경우 무한 교착상태에 빠져 트랜잭션이 수행되지 않을 수 있는 상황이다.
  - **요새 많은 DB들은 MySQL를 포함해서 데드락을 타임아웃으로 거는 게 가능하다. 그래서, 위와같은 데드락 조건이 되었을 때, 내부적으로 돌고있는 시스템이 있어서 데드락을 감시할 수가 있다. 어떤 커넥션이 오랫동안 락을 서로 잡고 있는 그런 상황이 된다면, 그리고 이 상황이 몇 초 이상 교착상태가 된다면 --> 타임아웃이 되면서 강제로 2개를 롤백시켜 버리는 그런 설정도 있다. 그래서 요새는 이러한 설정이 잘 되어있기 때문에 데드락에 빠져도 영원히 빠져서 DB가 멈추는 경우는 잘 없다.** 


- **2단계 잠금 규약 락의 처리 과정**
  - **이제 앞서 언급된 데드락을 해결하기 위해서 2단계 잠금 규약이라는 2 Phase Locking이라는 개념이 등장한다.** 이 부분도 완벽하게 데드락을 막을수는 없다. 하지만, 적어도 lock를 수행하는 타이밍인 확장단계와 unlock를 수행하는 타이밍인 축소단계를 지정함으로써 처음에는 lock를 잡는 연산만 하고, 아래쪽 단계에서는 unlock를 하는 식으로 단계를 나눠서 2단계 잠금 규약을 완성하는 것이다. 이런식으로 하면 데드락을 조금 더 많이 방지할 수 있다.
  - ex) 처음에 T1이 A를 잡고 lock를 걸고, 그 다음에 T2가 B를 잡고 lock를 건다. 그리고 T2가 B를 update하고 A를 잡으면 waiting상태가 된다. 그리고 T1에서도 A를 update하고 B를 잡으면 waiting상태가 된다. 여기까지가 확장단계이고, 중요한 건 각각의 트랜잭션에서 잡은 lock를 확장단계에서 update를 미리 해놓는다는 것이다. --> 이제 축소단계가 시작되면 내가 update한 건 unlock를 해주는 것이다. 그래서 이 때부터 T1에서 A를 unlock 해준다. 똑같이 T2에서도 B를 unlock 해준다. 이렇게 서로 해주면, T1도 B를 획득해서 update할 수 있고 / T2도 A를 획득해서 update를 할 수 있게 된다. 그래서 이런식으로 데드락을 회피할 수 있다는 것이다. 
  - 사실은 이 2 Phase Locking도 약간의 이슈는 있을 수 있다. 3 Phase Locking도 나오고 이것 저것 나왔는데, 엄밀하게 그리고 딥하게 보면 이런 장치들이 대부분의 데드락을 막아주기는 하지만 실제로 서비스 운영을 해보면 완벽하게 방어는 못하는 것을 볼 수가 있다. 그래서 데드락 timeout이라는 값 설정이 있는 것이다.


### 추가적인 개념 - Select For Update
- **DB단에서 하나의 레코드를 조회와 동시에 트랜잭션이 시작하게 해서, 게다가 lock까지 배타 lock를 잡는 것을 명시적으로 선언하는 그런 개념이 있다. 이걸 통용하는 단어가 있는데 "Select For Update"라고 한다. django ORM에서도 아래처럼 사용할 수 있다.**

```python
Bookings.objects.get(pk=id).select_for_update()
```

- **이렇게 select_for_update()라는 구문을 제공하고 있다. 그래서 이렇게해서 데이터를 가지고 오게 되면 --> 데이터를 읽음과 동시에 바로 배타 lock이 걸리기 때문에, 나중에 다른 트랜잭션이 같은 pk로 접근하더라도 내 트랜잭션이 끝나기 전까지는 이 데이터에 접근해서 읽는 것이 방지가 된다. 그래서 내 트랜잭션이 끝나고 나서야, 그 다음 이어서 데이터를 가지고 오고 쓸 수 있게 되는 것이다. 이런식으로 하나의 레코드 또는 복수의 레코드를 완벽하게 가져오는 것이다. 즉, 내가 가져오는 데이터를 스냅샷을 뜸과 동시에 바로 배타 lock를 잡는, 조금 더 일관성과 격리성을 쎄게할 수 있는 방법이 있다는 것을 알아두자.**


### 예약시스템 프로세스 3가지 구현 방안
- 우리가 진행하는 서비스에서는 남은 예약 가능 건수를 처리하기 위해서 여러 방안들을 구현할 수 있다. 

**1. 미리 모든 테이블의 좌석 개수 만큼 레코드 생성되고 점유할 좌석 만큼 행들을 select for udpate로 배타 lock 행 별로 잡아서 처리**
- 우리가 timetable을 만들 때, 8개의 좌석을 만들어놨다. 8개를 하나의 컬럼에 8이라는 숫자를 넣었지만, 지금 1번 방안은 --> 진짜 8개의 가로로된 레코드를 만드는 것이다. 그렇게 해서 만약에, 어떤 사람이 와서 내가 좌석을 예약하겠다고 하면 --> 하나의 레코드를 바로 read를 해가지고 바로 배타 lock를 거는, 즉 select for udpate를 수행해서 바로 1개의 행을 잠궈버리는 것이다. 그리고 그 다음 사람이 와서 2번째 레코드를 read하고 또 배타 lock를 걸어서 잠궈버리는 것이다. 이런식으로 select for udpate를 계속 사용하게 되면 순서대로 계속 잠글 수 있다.
- 만약에 첫번째 있는 사람이 이걸 취소하고 가게 되도, 이 때는 lock이 풀리니까 새로운 요청이 들어와서 이걸 다시 lock를 잡을 수가 있다. 그래서 이런식으로 신뢰성이 높고, 속도가 높다는 장점이 있다. 
  - 대신에, 미리 생성해야 할 레코드의 수가 많아야 한다. 
  - 그리고 예약 가능 좌석 수가 변경 시, 작업이 어렵다. 그리고 버그가 있을 수 있다. 
  - **만약에 좌석이 고정된 인기 있는 공연 티켓 예매 시, 메모리 DB등을 이용해서 비슷한 방법으로 구현하거나 RDB에서 레코드를 생성하는 식으로 구현하는 경우가 많다. 그래서 좌석이 1번부터 10번까지 있다면 얘네들을 다 레코드로 만들어두고, 내가 1번 좌석을 예약하겠다 그러면 그 좌석을 잠궈버리는 것이다.**

**2. 미리 예약 가능 날짜에 대해 잔여자리를 가진 레코드를 생성. 이 데이터를 계속해서 차감해서 처리함(우리는 이 방법으로 구현)**
- 지금 우리가 timetable 만든 것과 같이, 8을 넣어두고 이 레코드에 대해서 하나씩 잠궜다가 풀면서, lock를 걸면서 진행하는 것이다. 그래서 하나의 요청이 실행되고 있을때는 다른 요청이 가디라고 있어야 하기 때문에 동시에 하나씩밖에 처리를 못하게 된다. 
  - 이 방법은 하나의 레코드에 경합이 발생하게 된다. (락으로 대기 시간이 있다)
  - 경합이 자주 발생하지 않는다면 비교적 1번보다 구현이 쉽다.
  - 우리는 이 2번을 사용해서 구현 할 예정이다. 

**3. 예약 테이블에 정상 결제된 레코드 수가 예약 가능 수 보다 작을 때만 추가 예약 받도록 처리**
- 예약 테이블이 있다고 가정할 때, 해당 테이블에 예약 대상 레스토랑이 있고 해당 시간에 8개의 좌석이 있다. 그런데 예약 내역은 3개가 있는 것이다. 그러면 8 - 3이 되니까 예약가능좌석은 5가 된다. 이럴 때는 남은 좌석이 5이니까 예약이 가능할 것이다. 이 경우에 테이블 전체를 lock를 잡으면 8 -3 = 5 이 무결성이 보장된다. 근데 그렇게 하지 않는 이상은, 내가 트랜잭션을 시작하고 있는데 새로운 데이터가 추가되게 되면 데이터 개수가 4로 바뀌게 되면서, 나는 3으로 알고 있어서 5자리가 여유로운줄 알고 5명을 예약하려고 봤더니, 내가 다시 트랜잭션을 끝낼 때 쯤에는 4로 바뀌어있다 보니까 트랜잭션이 실패하게 되는 상황이 생기게 된다. 그러니까 Phantom Read가 발생하게 된다. 그래서 실시간성이 높다면 오버 부킹 발생 가능성이 있다. 
- 즉, 테이블 전체 락(또는 갭락, 또는 격리수준이 높아야함)을 잡지 않는 이상 예약된 데이터 수가 트랜잭션 와중에 변화할 수 있다.(팬텀리드)
- 이 방법은 데이터를 사전에 생성하지 않아도 되고 구현이 비교적 쉽다는 장점이 있다. 


* * *

### PG 결제와 연동 시 프로세스
- 우리가 실제로 결제를 구현할 때 유의점은, 우리가 PG사에 요청을 의존해야 된다는 점이다. 그래서 어쩔 수 없이 결제사에서 제공하는, PG사에서 제공하는 결제 flow를 한 번 살펴봐야 한다.
- 자세한 내용은 [토스 관련 내용](https://docs.tosspayments.com/guides/windows/card)에 정리가 되어있으니 참고해보자. PG사에서 카드 결제 시 제공하는 프로세스이다. 
- 그리고 우리는 "카드 결제"를 할 것이기 때문에, 카드와 관련된 프로세스만 먼저 보도록 하자.

**1. 결제창 호출 단계에서 미리 잔여 좌석을 차감한다. 이 때, 우리 DB의 예약 내역을 READY로 미리 저장한다. (트랜잭션)**
- 이 때, 트랜잭션으로 저장하게 되면 -> 동시에 이 데이터를 선점하려고 다른 요청이 들어올 때, 일단 lock이 걸리기 때문에 첫번째 트랜잭션이 끝나야 그 다음 트랜잭션이 잡히는 이런식의 구조가 된다. (그럼 여기서 소비자 1명이 결제창을 보고 있으면, 다른 1명은 결제창에 호출이 안되는 건가..?)
- 그래서 이후 들어오는 트랜잭션은 commit 이후에 잔여 좌석이 0이 되면 더 이상 유입되지 않고 좌석이 없다고 튕겨나가게 된다. 

**2. 우리가 PG사 쪽에 요청하는 결제 승인 API 호출 결과가 성공이면 예약 내역을 PAID로 확정한다.(트랜잭션)**
- 만약 실패하면 잔여 좌석을 반납하고 예약 내역을 FAILED로 확정한다. 

**3. 만약에 결제 도중에 웹 사이트를 나가서 2번 단계에 제대로 수행되지 않는 경우를 위해 상세조회 뷰가 실행될 때마다 (유저가 식당상세화면에 접근할 때마다) 10분이 지난 READY인 예약 건을 CANCELED로 바꾼 뒤 잔여 좌석을 반납하는 로직을 수행한다.(트랜잭션)**
- 여기서 "유저"는 다른 아무 사용자가 우리의 상세 조회 화면이 조회될때마다 10분이 지난 READY건을 CANCELED로 바꾼다는 것이다. 
- 3번 과정이 있는 이유는, 2번 과정에서 카드사도 갔다와야하고, PG사도 갔다와야하고 화면이 계속 왔다갔다 해야 한다. 그래서 되게 오래 걸린다. 우리가 처음에 "결제" 버튼을 누르고 카드 인증을 하고 "결제가 완료 되었습니다." 라는 화면을 볼 때까지 실제로 평균적으로 거의 5초에서 8초 정도 걸리는 경우가 많다. 이 기간동안 트랜잭션을 잡고 있을 수는 없다. 그러면 당연히 다른 요청이 들어와서 8초 동안 기다리게 할 수는 없을 것이다. 온라인 사이트들을 줄 세우기처럼 기다리게 할 수는 없으니까, 중간에 트랜잭션을 열어줘야 한다.
  - 그래서 1번에서 트랜잭션을 한 번 끝내고, 2번은 일단 페이지가 왔다갔다해서 몇 초를 보낸뒤에 마지막으로 이게 성공했는지 아닌지가 PG사에서 오게 된다. 그래서 성공이면 예약 내역을 PAID로 확정을 하면 된다. 실패라는 결과가 오게되면 그냥 FAILED로 만들어버리고 다시 1번에서 가져온 좌석을 반납해버리면 된다. 이것도 하나의 트랜잭션으로 처리해주면 된다. 
  - 근데 2번 자체가 오류가 있어서 트랜잭션이 잘못되어 있거나, 문제가 되는 경우가 있을 수 있다. 그래서 그럴 경우에는 3번을 진행해주는 것이다. 
  - 또는 2번에서 PAID나 FAILED가 오지 않고 결제창에서 사용자가 그냥 나가버릴 수도 있다. 그럴 경우에도 3번이 유효하다. 1번에서 그냥 사용자가 나가버리면 계속 READY로 남아있게 되고, 3번에서 10분이 지난 건들을 CANCELED로 바꾸고 잔여 좌석을 반납하기 때문에, 만약 2번이 수행되지 않더라도 자동으로 시간이 지나면 돌려받게 된다. 
  - 만약, 최악의 경우 2번에서 결제가 성공을 했는데 과정 자체가 10분이 걸렸다고 해보자. (보통 10분 이상이 걸리면 세션이 취소되기 때문에 이런일은 거의 없다고 한다) 그러면, 2번 트랜잭션이 먼저 수행되었다면 2번 트랜잭션이 먼저 끝나야지 3번 트랜잭션이 수행되기 때문에(lock이 있기 때문에) 결제가 보장될 것이다. 만약, 운이 나빠서 3번 트랜잭션이 먼저 실행되서 캔슬이 된다면, 2번 트랜잭션에서 강제로 취소처리를 해주면 된다. 
  - 2번 같은 경우, 조금 더 경쟁률이 굉장히 치열한 시스템을 만든다고 한다면, 실시간성 서비스를 운영한다고 하면 --> 결제호출 결과가 성공이긴 하지만, 내가 select for udpate를 했을 때 이미 CANCELED로 바뀌어져 있으면 잔여좌석이 반납이 된 것이니까 --> 사용자한테 이거 이미 세션이 끝났다고 얘기를 하고 다시 PG사한테 취소를 강제로 처리하는 그런 로직을 구성하는 것이 더 완벽한 로직이 될 수 있다. 그래서 항공사나 좀 더 복잡한 오버 부킹이 발생하기 쉬운 그런 곳에서는, 내가 결제 호출이 성공하더라도 select for udpate를 할 때, 갑자기 CANCELED로 바뀌어져 있으면 이건 이미 세션이 끝났구나 해서, 즉 이미 timeout이 난 것이구나 해서 바로 결제사한테 이거 그냥 취소해줘 라고 던져버리고 우리 데이터도 그냥 CANCELED로 나둬버린다. 
  - **그래서 일단 위와 같은 이러한 프로세스를 구성할 수 있게 된다. (바탕화면 캡처 참고)**
