## 트랜잭션과 락


### 결제 수행 과정
1. 고객이 원하는 일자와 시간을 선택
2. 예약정보입력 페이지로 이동 후 예약자명, 전달사항을 적는 폼 페이지에서 관련 정보를 입력
3. 예약 보증금 결제 처리 -> 이 때 결제처리과정을 거치게 됨
   - **a) PG사에 결제 요청** / PG사는 Pay Gateway의 약자로 여러가지 결제 인증 업체들이 있다. 우리가 계죄이체할 때, 한국에 있는 20개가 되는 은행들과 연동을 해야 계좌이체가 발생한다. 카드결제 시, 카드사 같은 경우도 
     10개가 넘어간다. 이렇게 많은 결제 업체들, 즉 결제 수단을 제공하는 그런 회사들이 있다. 이 회사들에 있는 정보랑 통신들을 전부 다 매핑을 해서 우리가 이커머스 사이트를 운영할 때 결제 모듈을 불러와서 
     쓸 수 있게 해주는 게 바로 PG사의 역할이다. 따라서 PG사의 경우에는, 우리가 그냥 PG사에 연동만 해놓으면 그러한 다양한 결제 수단 업체들에 대한 요청을 보낼수가 있고, 인증도 걸쳐서 결제를 진행할 수
     있게 되는 것이다. 그래서 이 a 단계는 결제창을 여는것부터 시작한다. 그래서 우리가 상품을 구매할 때 --> 결제 화면이 열리면서 거기서 카드를 선택하거나 은행을 선택하거나 했을 것이다. 그렇듯이 그렇게
     창을 여는 단계라고 생각하면 된다. 
   - **b) 다음으로는 카드 결제의 경우 카드 인증 단계가 있다. 또한, 계좌이체의 경우 공인인증서를 인증하는 단계가 있을 수 있다. 휴대폰 결제는 휴대폰 인증이 있고 상품권 결제는 상품권 인증이 있다.** 
     가상계좌의 경우에만, 한번에 끝나기 때문에 가상계좌는 별도의 인증 단계를 거치지 않는다. 보통 이러한 인증수단들은, 예를 들어 카드 결제를 할 경우에는 현대카드이면 현대카드, 삼성카드면 삼성카드, 
     롯데카드면 롯데카드, 이런식으로 해당 카드 업체에 서버를 통해서 인증이 이루어지게 된다. 
   - **c) 다음으로는 데이터베이스에 예약 내역을 입력하는 단계이다. 해당 DB는 우리쪽 DB를 의미한다.** 인증된 값을 우리의 웹 서비스에서 실제로 결제할 금액과 매핑을 해서 검사를 한 뒤에, 이 데이터가 
     유효하게 완성이 되어있으면,
   - **d) 최종적으로 결제 승인 요청을 PG사한테 보내면, 그 PG사가 위에서 인증한 카드사나 은행들한테 인출을 해달라고 연락을 하는 단계가 된다.** 
   - **정리해보면 a 단계는 결제에 필요한 값들을 입력받는 단계 / b 단계는 결제 수단에 대해서 내가 실제로 소유자인지 아닌지를 인증하는 인증단계 / c 단계는 우리쪽에서 데이터베이스에 데이터를 입력하는 단계 / d 단계는 모든 조건이 만족하고 유효성이 검증되면 마지막으로 우리 서버에서 PG사한테 연락을 해서 결제를 해줘 라고 연락하는 단계이다. 그러면 PG사가 알아서 결제를 처리하게 된다.**
     - 여기서 말하는 c와 d단계는 순서가 바뀌어도 무방한 단계이다.  


### 결제 수행 과정 시, 문제 발생
- **유저 여러 명이 하나의 남은 좌석을 가지고 결제하는 경우, 먼저 결제가 끝난 유저 외의 다른 유저는 위의 단계를 동시에 거치고 있다면 d 단계까지 왔을 때, 오버 부킹이 되는 이슈가 있다.**
- 이런식으로 제한된 자원을 가지고 여러 사람들이 경쟁하는 상황을 **Race Condition**이라고도 한다. **특히 최종 결제 승인이 처리될 때, 실패하는 경우가 있을 수 있다. 이럴 경우에는 c 단계를 어떻게 돌아갈 것이냐, 즉 예약 내역 입력을 어떻게 해야하지? 이러한 생각이 들게 된다. 결제 발생이 실패를 했는데, 우리의 DB에는 예약이 된 것으로 입력이 되어있는 그런 상황이 발생할 수 있다는 것이다.**


### 개선된 예약 수행 과정
- 위의 문제들을 조금 개선해보자면,      
**1. 처음에 우리 DB에 예약 내역을 먼저 입력한다.(우리 서버)** 그래서 우리 서버에 먼저 기록을 해둔다.     
**2. 고객이 그 다음에 결제창을 띄워서 PG 결제를 요청한다.(PG사 서버)**      
**3. 카드 결제의 경우, 카드 인증을 하고 다른 수단도 인증을 거친다.(카드사 또는 은행 서버 등등)**      
**4. 최종 결제 승인을 거치고(실 결제 발생)(우리 서버)**     
**5. 승인이 끝나고 나면 우리 서버 DB에 있는 예약 내역을 성공으로 업데이트를 하는 것이다.**      
- 여기서 2번과 3번은 우리 서버에서 일어나는 이벤트가 아니다. 그러다보니까 이 2번과 3번을 거치기 전에 우리쪽에 먼저 1번으로 누군가가 찜해놓았다 라는 표식을 남겨둬야 다른 사람이 여기서 들어올 때 이걸 보고 아직 내가 들어올 차례가 아니구나 라고 대기를 탈 수 있게 된다. 
- **그 다음 4,5번에서 마무리를 짓는 것이다. 그런데 이러한 수행 과정도 사실 중간에 하나라도 실패한다면, 전체가 실패 해야하는 그런 조건을 가지고 있다. 이렇게 수행되는 시간이 다르지만, 한 번에 묶음처리 되어야 하는 것을 트랜잭션이라고 부르게 된다.** 
  - 여기서 말하는 결제 요청과 카드 인증은 사용자 입력이 필요하고 그리고 우리 서버에서 일시적으로 이루어질수는 없기 때문에 코드상으로는 하나의 트랜잭션 구현이 불가능하지만, 이렇게 앞에 1번 단계를 둠으로서 비슷한 효과를 줄 수 있게 되는 것이다.
  - 그래서 1번에서 데이터를 선점 입력하는 것에 실패한다면, 결제를 진행하지 않게 된다. 하지만, 코드상에 트랜잭션으로 실제 구현하려면 하나의 메소드내에 연달아 로직이 수행되어야 하므로 **코드 상 트랜잭션은 1번 그리고 4,5번이 된다.** 2,3번은 각각 우리 사이트에서 벗어나서 다른 사이트로 이동하는 과정이므로 우리가 트랜잭션을 유지할 수는 없어서 1번에서 선점하는 식으로 보완을 하는 것이다. 


### 트랜잭션의 정의
- **트랜잭션을 명확하게 정의하자면, 처리과정 이라고 할 수 있다. 그리고 컴퓨터 사이언스 분야에서 트랜잭션은 "쪼개질 수 없는 업무처리의 단위"를 의미한다.**
- **그 외에도 데이터베이스 충돌을 해결하기 위해서 둘 또는 그 이상의 데이터베이스 업데이트를 단일화된 작업으로 처리하는 기법을 의미한다. 작업을 모두 완료하면 그 때서야 최종적으로 적용을 시키게 된다. 이 과정을 "커밋"이라고 한다.**
- **하나라도 내부에 있는 작업이 실패하게 되면, (하나의 수정작업 update가 실패하면) 트랜젝션 상의 모든 업데이트가 취소가 된다. 즉, 모든 업데이트가 실패 이전 상태로 복구된다. 이것을 "롤백"이라고 부른다.**

- 그래서 우리가 "데이터베이스의 트랜잭션" 이라고 한다면 -> 우리 DB에 데이터를 업데이트 치고 그 과정이 한 묶음으로 떨어져서 중간에 하나라도 실패하면 돌아가는, 그 하나의 실행단위를 트랜잭션이라고 부르기도 한다.
  - 그런데 조금 더 폭 넓게 보자면 -> 데이터베이스 뿐만 아니라 결제 과정 / 송금 과정 이런식으로 어떤 자금 흐름의 하나의 인출 단위도 트랜잭션이라고 부르기도 한다. 컴퓨터 프로그래밍에서도 굳이 DB에 데이터 처리를 직접적으로 하지 않더라도 **"코드를 한 단위로 수행하는 것"**을 트랜잭션이라고 보면 된다.** 예를 들어, **API가 호출이 되서 응답까지 나가는 하나의 처리 단위**도 트랜잭션이라고 부르기도 한다. 


### TPS(초당 트랜잭션)
- **그래서 TPS라는 개념이 존재 : Transaction Per Second의 약자로서, 1초 당 처리할 수 있는 트랜잭션의 개수를 의미한다.** 
- 예를 들어, 실제로 API가 호출이 되서 응답이 될 때 그 하나의 단위를 트랜잭션이라고 보고, 1초 당 API가 호출되는 카운트를 의미하기도 한다.
- 대신에 TPS를 DB에 다시 대입해서 생각해보면, DB가 동시에 처리가능한 트랜잭션의 수가 될 수도 있다.
  - **우리가 이번에 배울 내용은 데이터베이스에 한정해서 그리고 django에서 데이터베이스 작업을 하나로 묶어서 처리하는 그 단위를 일컬어서 트랜잭션을 설명하려고 한다. 나중에는 더 공부하면 TPS가 다양한 개념과 함께 넓은 의미로 쓰이게 된다.**


### 트랜잭션 규칙 - ACID
- 트랜잭션은 이러한 규칙을 준수해야 된다는 것이 있다. 많은 데이터베이스가 백엔드 프레임워크가 이런 특성을 고려해서 구현하거나 설계되어 있다. 이걸 앞 글자를 따서 ACID라고 한다.
**1. Atomicity(원자성)** : 트랙잭션의 작업이 모두 수행되거나 혹은 모두 수행이 안되거나 이다. 하나의 트랜잭션 안에 여러가지 코드가 들어가 있고 여러가지 오퍼레이션이 수행되더라도 그 중 하나라도 실패한다면 아무것도 실행이 안되는 상태가 보장이 되어야 한다는 것이다.
**2. Consistency(일관성)** : 트랜잭션이 수행되는 순간에는 여러번 읽더라도 데이터베이스의 상태가 똑같해야 한다는 것이다. 예를 들어, 내가 트랜잭션을 시작했는데 거기있는 값이 일관성없이 이리저리 바뀌게 된다면 트랜잭션이 수행되는 동안에 내가 보고있는 데이터가 변질이 계속 되는 것이다. 그러면 일관성이 없다고 볼 수 있다.
**3. Isolation(독립성, 고립성)** : 하나의 트랜잭션이 수행되고 데이터를 갱신하는 동안에는 이 트랜잭션이 완료되기 전에 갱신중인 데이터에 다른 트랜잭션이 접근하지 못하게 해야한다는 것이다. 내가 어떤 데이터를 막 수정하고 있는데 다른 애가 와서 덮어쓰고 내가 수정하려고 하면 내껄 날려버리고 이러면 안될 것이다.
**4. Durability(지속성)** : 트랜잭션이 끝나고 나면 커밋이 마무리가 되고 그 갱신 사항이 이후에도 계속 유지되고 적용되어야 한다는 것이다. 


### django의 트랜잭션
**1) 함수 선언에 transaction.atomic 어노테이션을 사용하는 경우**

```python
from django.db import transaction

@transaction.atomic
def transaction_test1(arg1, arg2):
   # start transaction
   a.save()

   b.save()
   # end transaction
```

- 이런식으로 함수 단위로 묶을 수 있다. 

**2) 또한, 코드 블록(코드 안에)에 with transaction.atomic() 사용**

```python
with transaction.atomic():
     # start transaction
     b.save()
     c.save()
     # end transaction
```

- 이렇게 코드 중간에 with transaction.atomic():를 사용해서 이 안에 있는 블록을 하나의 트랜잭션으로 묶을수도 있다.


### 잠금(Lock)과 잠금 단위
- **그러면 이제 이러한 개념들이 실제 DB에서 어떤식으로 관리되고 처리될 수 있는지를 보자. DB에서는 이를 위해서 Lock이라는 개념을 제공하고 있다.** 
- Lock은 공유 Lock과 배타 Lock 2가지로 볼 수 있다.
  - **Share Lock(공유 잠금)** : Lock를 잡더라도 다른 트랜잭션에서 읽을 수가 있다. 하지만 쓰는 것은 불가능하다.
  - **Exclusive Lock(배타 잠금)** : 이러한 배타 잠금이 한 번 잠기면, 다른 트랜잭션에서 이 데이터를 읽을 수가 없고 쓰는 것도 불가능하다. 이 배타 잠금이 풀릴때까지 기다려야 한다.

- **다음으로 Lock를 잠글 때, 어떤 단위로 Lock를 잠글 것인지를 결정하는 "잠금 단위"가 있다.**
- 데이터베이스 / 테이블 / 레코드 범위(Gap Lock) / 레코드 / 필드 (왼쪽이 크고 로직이 간단한 것부터 시작해서 오른쪽으로 갈 수록 작고 동시성이 확보가 된다)
  - 이렇게 잠금 단위가 클수록 "무결성"이 더 보장되는 특징이 있다. 
  - **데이터베이스는 sqlite가 비슷한 형태가 된다. 우리가 프로덕션 서비스를 운영하게 될 때는 sqlite를 사용하기에는 어렵다고 얘기했는데, 하나의 파일을 여러 요청이 공유하기 때문이다.** 그래서 내가 어떤 요청을 데이터베이스에 보내게 되면 하나의 요청만 동시에 처리할 수 있고 다른 요청을 동시에 처리할 수가 없어서 다른 요청이 들어오게 되면 sqlite는 하나의 파일로 이루어져 있다 보니까 파일 잠금 현상이 일어나서 하나의 파일에 대해서 여러 요청이 동시에 처리될 수 없는 그런 단점을 가지고 있는 것이다. 대신 이 경우에는 무결성이 보장될 것이다. 그리고 구현도 간단할 것이다. 
  - **필드로 가게 되면, 레코드를 가로로 1개 그려봤을 때 -> 하나의 레코드는 여러 필드를 가질 수가 있는데(캡처 참고), A라는 요청이 들어와서 하나의 필드값을 수정했으나 동시에 또다른 B라는 요청이 들어와서 다른 필드값을 수정할 수도 있는 것이다. 그러다보니까 동시에 여러 요청을 처리할 수 있다 해서 "동시성이 높다"는 표현을 할 수 있는 것이다.**


### 데이터베이스 락
- 데이터베이스에 대한 락을 조금 더 자세하게 살펴보자. **이 데이터베이스가 락을 잡을 때, 어떤 모드로 락을 잡는지 단계별로 설명이 필요하다.** 우리가 사용하고 있는 RDBMS인 MySQL 기준으로 설명을 이해해보자. 다른 DB들도 비슷한 형태의 레벨을 가지고 있다. **그래서 MySQL의 Isolation level, 격리 수준에 대해서 이해를 하고 있다면 나중에 다른 DB를 공부할 때도 이해할 수 있을 것이다.**


16:41




