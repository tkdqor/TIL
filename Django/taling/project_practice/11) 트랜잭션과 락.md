## 트랜잭션과 락


### 결제 수행 과정
1. 고객이 원하는 일자와 시간을 선택
2. 예약정보입력 페이지로 이동 후 예약자명, 전달사항을 적는 폼 페이지에서 관련 정보를 입력
3. 예약 보증금 결제 처리 -> 이 때 결제처리과정을 거치게 됨
   - **a) PG사에 결제 요청** / PG사는 Pay Gateway의 약자로 여러가지 결제 인증 업체들이 있다. 우리가 계죄이체할 때, 한국에 있는 20개가 되는 은행들과 연동을 해야 계좌이체가 발생한다. 카드결제 시, 카드사 같은 경우도 
     10개가 넘어간다. 이렇게 많은 결제 업체들, 즉 결제 수단을 제공하는 그런 회사들이 있다. 이 회사들에 있는 정보랑 통신들을 전부 다 매핑을 해서 우리가 이커머스 사이트를 운영할 때 결제 모듈을 불러와서 
     쓸 수 있게 해주는 게 바로 PG사의 역할이다. 따라서 PG사의 경우에는, 우리가 그냥 PG사에 연동만 해놓으면 그러한 다양한 결제 수단 업체들에 대한 요청을 보낼수가 있고, 인증도 걸쳐서 결제를 진행할 수
     있게 되는 것이다. 그래서 이 a 단계는 결제창을 여는것부터 시작한다. 그래서 우리가 상품을 구매할 때 --> 결제 화면이 열리면서 거기서 카드를 선택하거나 은행을 선택하거나 했을 것이다. 그렇듯이 그렇게
     창을 여는 단계라고 생각하면 된다. 
   - **b) 다음으로는 카드 결제의 경우 카드 인증 단계가 있다. 또한, 계좌이체의 경우 공인인증서를 인증하는 단계가 있을 수 있다. 휴대폰 결제는 휴대폰 인증이 있고 상품권 결제는 상품권 인증이 있다.** 
     가상계좌의 경우에만, 한번에 끝나기 때문에 가상계좌는 별도의 인증 단계를 거치지 않는다. 보통 이러한 인증수단들은, 예를 들어 카드 결제를 할 경우에는 현대카드이면 현대카드, 삼성카드면 삼성카드, 
     롯데카드면 롯데카드, 이런식으로 해당 카드 업체에 서버를 통해서 인증이 이루어지게 된다. 
   - **c) 다음으로는 데이터베이스에 예약 내역을 입력하는 단계이다. 해당 DB는 우리쪽 DB를 의미한다.** 인증된 값을 우리의 웹 서비스에서 실제로 결제할 금액과 매핑을 해서 검사를 한 뒤에, 이 데이터가 
     유효하게 완성이 되어있으면,
   - **d) 최종적으로 결제 승인 요청을 PG사한테 보내면, 그 PG사가 위에서 인증한 카드사나 은행들한테 인출을 해달라고 연락을 하는 단계가 된다.** 
   - **정리해보면 a 단계는 결제에 필요한 값들을 입력받는 단계 / b 단계는 결제 수단에 대해서 내가 실제로 소유자인지 아닌지를 인증하는 인증단계 / c 단계는 우리쪽에서 데이터베이스에 데이터를 입력하는 단계 / d 단계는 모든 조건이 만족하고 유효성이 검증되면 마지막으로 우리 서버에서 PG사한테 연락을 해서 결제를 해줘 라고 연락하는 단계이다. 그러면 PG사가 알아서 결제를 처리하게 된다.**
     - 여기서 말하는 c와 d단계는 순서가 바뀌어도 무방한 단계이다.  


### 결제 수행 과정 시, 문제 발생
- **유저 여러 명이 하나의 남은 좌석을 가지고 결제하는 경우, 먼저 결제가 끝난 유저 외의 다른 유저는 위의 단계를 동시에 거치고 있다면 d 단계까지 왔을 때, 오버 부킹이 되는 이슈가 있다.**
- 이런식으로 제한된 자원을 가지고 여러 사람들이 경쟁하는 상황을 **Race Condition**이라고도 한다. **특히 최종 결제 승인이 처리될 때, 실패하는 경우가 있을 수 있다. 이럴 경우에는 c 단계를 어떻게 돌아갈 것이냐, 즉 예약 내역 입력을 어떻게 해야하지? 이러한 생각이 들게 된다. 결제 발생이 실패를 했는데, 우리의 DB에는 예약이 된 것으로 입력이 되어있는 그런 상황이 발생할 수 있다는 것이다.**


### 개선된 예약 수행 과정
- 위의 문제들을 조금 개선해보자면,      
**1. 처음에 우리 DB에 예약 내역을 먼저 입력한다.(우리 서버)** 그래서 우리 서버에 먼저 기록을 해둔다.     
**2. 고객이 그 다음에 결제창을 띄워서 PG 결제를 요청한다.(PG사 서버)**      
**3. 카드 결제의 경우, 카드 인증을 하고 다른 수단도 인증을 거친다.(카드사 또는 은행 서버 등등)**      
**4. 최종 결제 승인을 거치고(실 결제 발생)(우리 서버)**     
**5. 승인이 끝나고 나면 우리 서버 DB에 있는 예약 내역을 성공으로 업데이트를 하는 것이다.**      
- 여기서 2번과 3번은 우리 서버에서 일어나는 이벤트가 아니다. 그러다보니까 이 2번과 3번을 거치기 전에 우리쪽에 먼저 1번으로 누군가가 찜해놓았다 라는 표식을 남겨둬야 다른 사람이 여기서 들어올 때 이걸 보고 아직 내가 들어올 차례가 아니구나 라고 대기를 탈 수 있게 된다. 
- **그 다음 4,5번에서 마무리를 짓는 것이다. 그런데 이러한 수행 과정도 사실 중간에 하나라도 실패한다면, 전체가 실패 해야하는 그런 조건을 가지고 있다. 이렇게 수행되는 시간이 다르지만, 한 번에 묶음처리 되어야 하는 것을 트랜잭션이라고 부르게 된다.** 
  - 여기서 말하는 결제 요청과 카드 인증은 사용자 입력이 필요하고 그리고 우리 서버에서 일시적으로 이루어질수는 없기 때문에 코드상으로는 하나의 트랜잭션 구현이 불가능하지만, 이렇게 앞에 1번 단계를 둠으로서 비슷한 효과를 줄 수 있게 되는 것이다.
  - 그래서 1번에서 데이터를 선점 입력하는 것에 실패한다면, 결제를 진행하지 않게 된다. 하지만, 코드상에 트랜잭션으로 실제 구현하려면 하나의 메소드내에 연달아 로직이 수행되어야 하므로 **코드 상 트랜잭션은 1번 그리고 4,5번이 된다.** 2,3번은 각각 우리 사이트에서 벗어나서 다른 사이트로 이동하는 과정이므로 우리가 트랜잭션을 유지할 수는 없어서 1번에서 선점하는 식으로 보완을 하는 것이다. 


### 트랜잭션의 정의
- **트랜잭션을 명확하게 정의하자면, 처리과정 이라고 할 수 있다. 그리고 컴퓨터 사이언스 분야에서 트랜잭션은 "쪼개질 수 없는 업무처리의 단위"를 의미한다.**
- **그 외에도 데이터베이스 충돌을 해결하기 위해서 둘 또는 그 이상의 데이터베이스 업데이트를 단일화된 작업으로 처리하는 기법을 의미한다. 작업을 모두 완료하면 그 때서야 최종적으로 적용을 시키게 된다. 이 과정을 "커밋"이라고 한다.**
- **하나라도 내부에 있는 작업이 실패하게 되면, (하나의 수정작업 update가 실패하면) 트랜젝션 상의 모든 업데이트가 취소가 된다. 즉, 모든 업데이트가 실패 이전 상태로 복구된다. 이것을 "롤백"이라고 부른다.**

- 그래서 우리가 "데이터베이스의 트랜잭션" 이라고 한다면 -> 우리 DB에 데이터를 업데이트 치고 그 과정이 한 묶음으로 떨어져서 중간에 하나라도 실패하면 돌아가는, 그 하나의 실행단위를 트랜잭션이라고 부르기도 한다.
  - 그런데 조금 더 폭 넓게 보자면 -> 데이터베이스 뿐만 아니라 결제 과정 / 송금 과정 이런식으로 어떤 자금 흐름의 하나의 인출 단위도 트랜잭션이라고 부르기도 한다. 컴퓨터 프로그래밍에서도 굳이 DB에 데이터 처리를 직접적으로 하지 않더라도 **"코드를 한 단위로 수행하는 것"**을 트랜잭션이라고 보면 된다.** 예를 들어, **API가 호출이 되서 응답까지 나가는 하나의 처리 단위**도 트랜잭션이라고 부르기도 한다. 


### TPS(초당 트랜잭션)
- **그래서 TPS라는 개념이 존재 : Transaction Per Second의 약자로서, 1초 당 처리할 수 있는 트랜잭션의 개수를 의미한다.** 
- 예를 들어, 실제로 API가 호출이 되서 응답이 될 때 그 하나의 단위를 트랜잭션이라고 보고, 1초 당 API가 호출되는 카운트를 의미하기도 한다.
- 대신에 TPS를 DB에 다시 대입해서 생각해보면, DB가 동시에 처리가능한 트랜잭션의 수가 될 수도 있다.
  - **우리가 이번에 배울 내용은 데이터베이스에 한정해서 그리고 django에서 데이터베이스 작업을 하나로 묶어서 처리하는 그 단위를 일컬어서 트랜잭션을 설명하려고 한다. 나중에는 더 공부하면 TPS가 다양한 개념과 함께 넓은 의미로 쓰이게 된다.**


### 트랜잭션 규칙 - ACID
- 트랜잭션은 이러한 규칙을 준수해야 된다는 것이 있다. 많은 데이터베이스가 백엔드 프레임워크가 이런 특성을 고려해서 구현하거나 설계되어 있다. 이걸 앞 글자를 따서 ACID라고 한다.
**1. Atomicity(원자성)** : 트랙잭션의 작업이 모두 수행되거나 혹은 모두 수행이 안되거나 이다. 하나의 트랜잭션 안에 여러가지 코드가 들어가 있고 여러가지 오퍼레이션이 수행되더라도 그 중 하나라도 실패한다면 아무것도 실행이 안되는 상태가 보장이 되어야 한다는 것이다.
**2. Consistency(일관성)** : 트랜잭션이 수행되는 순간에는 여러번 읽더라도 데이터베이스의 상태가 똑같해야 한다는 것이다. 예를 들어, 내가 트랜잭션을 시작했는데 거기있는 값이 일관성없이 이리저리 바뀌게 된다면 트랜잭션이 수행되는 동안에 내가 보고있는 데이터가 변질이 계속 되는 것이다. 그러면 일관성이 없다고 볼 수 있다.
**3. Isolation(독립성, 고립성)** : 하나의 트랜잭션이 수행되고 데이터를 갱신하는 동안에는 이 트랜잭션이 완료되기 전에 갱신중인 데이터에 다른 트랜잭션이 접근하지 못하게 해야한다는 것이다. 내가 어떤 데이터를 막 수정하고 있는데 다른 애가 와서 덮어쓰고 내가 수정하려고 하면 내껄 날려버리고 이러면 안될 것이다.
**4. Durability(지속성)** : 트랜잭션이 끝나고 나면 커밋이 마무리가 되고 그 갱신 사항이 이후에도 계속 유지되고 적용되어야 한다는 것이다. 


### django의 트랜잭션
**1) 함수 선언에 transaction.atomic 어노테이션을 사용하는 경우**

```python
from django.db import transaction

@transaction.atomic
def transaction_test1(arg1, arg2):
   # start transaction
   a.save()

   b.save()
   # end transaction
```

- 이런식으로 함수 단위로 묶을 수 있다. 

**2) 또한, 코드 블록(코드 안에)에 with transaction.atomic() 사용**

```python
with transaction.atomic():
     # start transaction
     b.save()
     c.save()
     # end transaction
```

- 이렇게 코드 중간에 with transaction.atomic():를 사용해서 이 안에 있는 블록을 하나의 트랜잭션으로 묶을수도 있다.


### 잠금(Lock)과 잠금 단위
- **그러면 이제 이러한 개념들이 실제 DB에서 어떤식으로 관리되고 처리될 수 있는지를 보자. DB에서는 이를 위해서 Lock이라는 개념을 제공하고 있다.** 
- Lock은 공유 Lock과 배타 Lock 2가지로 볼 수 있다.
  - **Share Lock(공유 잠금)** : Lock를 잡더라도 다른 트랜잭션에서 읽을 수가 있다. 하지만 쓰는 것은 불가능하다.
  - **Exclusive Lock(배타 잠금)** : 이러한 배타 잠금이 한 번 잠기면, 다른 트랜잭션에서 이 데이터를 읽을 수가 없고 쓰는 것도 불가능하다. 이 배타 잠금이 풀릴때까지 기다려야 한다.

- **다음으로 Lock를 잠글 때, 어떤 단위로 Lock를 잠글 것인지를 결정하는 "잠금 단위"가 있다.**
- 데이터베이스 / 테이블 / 레코드 범위(Gap Lock) / 레코드 / 필드 (왼쪽이 크고 로직이 간단한 것부터 시작해서 오른쪽으로 갈 수록 작고 동시성이 확보가 된다)
  - 이렇게 잠금 단위가 클수록 "무결성"이 더 보장되는 특징이 있다. 
  - **데이터베이스는 sqlite가 비슷한 형태가 된다. 우리가 프로덕션 서비스를 운영하게 될 때는 sqlite를 사용하기에는 어렵다고 얘기했는데, 하나의 파일을 여러 요청이 공유하기 때문이다.** 그래서 내가 어떤 요청을 데이터베이스에 보내게 되면 하나의 요청만 동시에 처리할 수 있고 다른 요청을 동시에 처리할 수가 없어서 다른 요청이 들어오게 되면 sqlite는 하나의 파일로 이루어져 있다 보니까 파일 잠금 현상이 일어나서 하나의 파일에 대해서 여러 요청이 동시에 처리될 수 없는 그런 단점을 가지고 있는 것이다. 대신 이 경우에는 무결성이 보장될 것이다. 그리고 구현도 간단할 것이다. 
  - **필드로 가게 되면, 레코드를 가로로 1개 그려봤을 때 -> 하나의 레코드는 여러 필드를 가질 수가 있는데(캡처 참고), A라는 요청이 들어와서 하나의 필드값을 수정했으나 동시에 또다른 B라는 요청이 들어와서 다른 필드값을 수정할 수도 있는 것이다. 그러다보니까 동시에 여러 요청을 처리할 수 있다 해서 "동시성이 높다"는 표현을 할 수 있는 것이다.**


### 데이터베이스 락
- 데이터베이스에 대한 락을 조금 더 자세하게 살펴보자. **이 데이터베이스가 락을 잡을 때, 어떤 모드로 락을 잡는지 단계별로 설명이 필요하다.** 우리가 사용하고 있는 RDBMS인 MySQL 기준으로 설명을 이해해보자. 다른 DB들도 비슷한 형태의 레벨을 가지고 있다. **그래서 MySQL의 Isolation level, 격리 수준에 대해서 이해를 하고 있다면 나중에 다른 DB를 공부할 때도 이해할 수 있을 것이다.**

- 각 레벨을 Isolation level, 격리 수준(레벨)이라고 한다. 아래로 갈수록 더 강한 격리 보장성을 가지고 있다.

**1. READ UNCOMMITTED** : commit이 아직 안되었는데 다른 트랜잭션에서 접근이 가능한 경우이다. 그래서 Lock이 없다. (Dirty Read 발생) 
- ex) 트랜잭션이 발생해서 어떤 레코드가 가로 1줄로 있는데, 여기에 처음에는 0이 있었다. T1인 트랜잭션 첫번째가 여기에 들어와서 트랜잭션을 시작하고 1로 수정했다. 그리고 아직 트랜잭션을 진행하고 있다. 이 과정에서 갑자기 T2인 트랜잭션 2번이 들어온다. 이 T2가 이 값을 읽어온다. 그러면 1을 가지고 온다. 근데 여기서 T1 트랜잭션이 실패를 한다. 그러면 롤백이 되서 값이 0으로 돌아가게 된다. 이 때 T2가 수행중에도 다시 접근했을 때 0이라는 값으로 다시 불러오게 된다. 
  - **이 예시에서는 Dirty Read 개념을 볼 수 있다.** 
    - 이건 T1에서 트랜잭션을 수행중인 경우, 아직 commit이 끝나지 않은 중간 데이터를 다른 트랜잭션이 멋대로 가져다가 쓸 수도 있고 멋대로 덮어쓰기를 할 수도 있다, 그래서 트랜잭션이 전혀 보장이 되지 않는다는 것이다. 즉, Dirty Read는 다른 트랜잭션이 수행중인 아직 커밋이 되지 않은, 아직 완성되지 않은 중산 산출물을 다른 트랜잭션이 맘대로 가져갈 수 있고 이 값이 변할 수 있다는 것이다.


**2. READ COMMITED** : 이제 위와같은 문제를 보완하고자 나온 것이다. 여기서는 인덱스만 Lock를 건다.
- 위에서 T2가 처음에는 1로 읽었다가 T1이 롤백된 이후에 읽었을 때는 0으로 읽었다고 했다. 이렇게 반복적으로 읽을 때, 다른 값이 나오게 되는 것을 **Non Repeatable Read**라고 한다. / Dirty Read는 다른 트랜잭션이 변경하기 전에 예비 단계에 있는 데이터를 내가 읽어버리는 걸 뜻한다.
   - **즉, 어떤 트랙잭션이 하나의 데이터를 이전에 읽었을 때랑 그 이후에 읽었을 때, 하나의 트랙잭션내에서 자꾸 이 값이 변경되는 것을 Non Repetable Read라고 한다는 것이다.**

- **다시 READ COMMITED는 commit이 끝난 데이터만 볼 수 있는 것을 의미한다. 그래서 Dirty Read를 방지한다.** 
  - ex) T1이 1번을 입력할 예정이지만 아직 commit를 안했다면, 그 때 T2가 읽는 시점에서는 값이 0이 된다. 그래서 dirty read가 발생하지 않았다. 그리고나서 commit한 다음에 값을 1로 바꿔놓았을 때는 아직 T2 트랜잭션은 실행이 되고 있고, 마지막 단계에 와서 그 데이터를 다시 읽어보면 1로 바꾸어져 있는 것이다. **그래서 여전히 Non Repetable Read는 발생하게 된다.**

- **추가로 Phantom Read라는 개념이 있다.** 
  - 트랜잭션 1인 T1이 있는데, 레코드를 가로 1줄 새롭게 생성하려고 한다. 근데 아직 생성은 안했다. 커밋이 끝나지 않았기 때문이다. 이 상황에서 T2가 등장한다. 그래서 T2가 처음에 읽었을 때는 레코드가 1개였다. count 메소드를 사용했을 때도 이 테이블의 가짓수가 1개라고 나왔다. 레코드의 개수가 1개라고 알고 있었다. 그래서 T2가 진행하고 있는데, T1의 commit이 발생했다. 그러면 테이블의 레코드 개수가 2개가 된다. 그래서 T1이 커밋이 끝난다음에 T2가 count를 다시 하면 2로 바뀌어있다. 이렇게 T2의 생성시점과 끝시점에서 같은 트랜잭션인데도 모르는 데이터가 갑자기 생겨있는 상황을 Phantom Read라고 한다. 
  - 이러한 Phantom Read는 데이터의 추가인 insert뿐만 아니라 delete로 인해 갑자기 레코드가 사라지는 것도 포함되는 개념이다. 


**3. REPEATABLE READ (MySQL 기본값)
- **이걸 또 보완해서 REPEATABLE READ가 등장한다. SELECT시 현재 시점의 스냅샷을 만들고, 그 스냅샷을 조회해서 Non Repeatable Read를 방지하는 방법이다. 그래서 동일 트랜잭션 내에서 일관성을 보장해준다.**
- **Record Lock이 발생한다는 게 주요 차이점**이다. 
  - READ COMMITED는 commited 이후에는 다른 트랜잭션이 조회할 수 있게 하기 위해서 단순히 index만 Lock를 거는 특징이 있다. 그래서 변경이 일어나거나 insert가 일어나거나 이럴 때 그 Lock를 다른 얘들이 insert등을 하지 못하도록 그냥 인덱스만 Lock를 걸고 있다. 
  - 반면에 REPEATABLE READ는 직접적으로 하나의 레코드에 대해서 Lock를 잡는 Record Lock를 진행해서 내가 어떤 레코드에 대해서 Lock를 잡아버리면, 다른 트랜잭션에서는 첫번째 트랜잭션이 끝나기 전까지는 아무것도 못하는 그런 상황이 생기게 된다.

- **그리고 Non Repeatable Read를 방지하는 방법이 있다.** 트랜잭션 1인 T1이 있다고 하자. T1이 데이터를 가져가면서 복사본을 하나 더 만든다. 그리고 T1이 write를 친다고 하면 그 데이터까지 잡을 수 있게 되는데, 이 상태에서 스냅샷을 하나 찍게 된다. 둘다 값이 1이면 1인 상태로 가지고 있는 것이다. 이 때, T2가 온다. 그 사이에 T1은 값을 2로 업데이트를 쳤다. 이 상태에서 T2가 해당 데이터를 읽을 때 Record Lock이 걸려있기 때문에(만약 배타 Lock이면 대기를 타고 있을 것이고, 쉐어 Lock이면 읽을수는 있지만 업데이트를 할 수는 없다) 값이 1번인 상태를 그대로 보존하고 있게 된다. 그리고 이제 T1에서 커밋이 끝났다. 그럼 이제 값들이 2번으로 업데이트가 된다. 이 때, T2에서 다시 읽어보면 값이 1번으로 보장(고정??)되어 있다. 그러니까 내가 읽는 시점의 데이터 값이 그대로 보존되어 있는 것이다. 그래서 T1에서 커밋을 치더라도 T2에서는 스냅샷이 있으니까 계속 똑같은 데이터를 읽게 되는 것이다. 대신에 내가 Lock인 상태에서 데이터를 가져왔기 때문에, Record Lock에 걸려있는 상태이기 때문에 일단 업데이트는 놓치제 되는 것이다.(데이터 최신값을 모르게 된다) 이렇게 Non Repetable Read를 방지하게 된다. 

- **하지만 여전히 Phantom Read는 발생한다. 다만, MySQL에서는 Next Key Lock 이라는 것을 통해 다음 키의 행이 생기는 걸 미리 Lock으로 잡아줄 수 있다.**
  - 예를 들어 1개 테이블의 레코드가 3개가 있다면, 그 다음에 어떤 데이터가 추가되거나 아니면 내가 어떤 데이터까지만 읽겠다라고 정의를 해놓고 Lock를 잡아놓을 수 있다. 4번 레코드는 Next Key로 Lock를 잡아두는 것으로 T1이 4번을 잠그고 있다면, T2에서 데이터 insert를 넣더라도 5번으로 넣게 되는 것이다. T1의 key lock이 풀려야지 T2의 insert가 수행이 되므로서 자동적으로 데이터가 3개일 때, 트랜잭션이 양쪽에서 수행이 되었어도 T1이 먼저 수행이 되고 T2가 그 다음에 수행이 되는 이런식의 Next Key Lock이 가능하다는 것이다. 
  - 즉, Next Key Lock은 insert, update 등을 위해 조회하려는 범위를 다음 인덱스 위치까지 락을 잡아서 읽는 동안의 팬텀리드를 방지하는 것이다.


**4. SERIALIZE**
- **가장 강력한 격리 레벨이다. 일단 SELECT 구문이 실행이 되자마자 해당 테이블이 전부 다 잠겨버린다. 즉, SELECT 문에 사용하는 모든 테이블에 베타 Lock이 발생한다.**
- 그래서 다른 트랜잭션인 T2가 들어오더라도 T1의 작업이 끝날때까지 T2는 계속 기다리고 있어야 한다. 그래서 해당 데이터 테이블에 접근조차 하지 못한다. 그리고 T1의 작업이 끝나고나서야 T2도 똑같이 베타 Lock으로 잠궈서 작업을 할 수 있게 된다. 
- 이 경우에는 동시성이 엄청 많이 떨어지게 된다.

- 이러한 격리 수준에 따라서, 위쪽으로 갈수록 성능과 동시성이 늘어나고 / 아래쪽으로 갈수록 고립성과 무결성이 늘어난다. 

* * *

### 데이터베이스 트랜잭션 무효화 Case (갱신 분실)
- 이제는 데이터베이스의 몇몇 문제들에 대해서 알아보고, 그것의 해결책을 어떻게 데이터베이스에서 구현을 했는지 알아보기
- **갱신 분실(캡처 참고)**
  - 첫번쨰는 갱신 분실이라는 개념이다. 먼저 DB에 좌석이 8개이고 총 매출이 1000인 레코드가 1개 있다고 하자. 그리고 첫번째 트랜잭션인 T1이 read를 한다. 그리고 좌석 8개에서 2개를 뺀다. 그러면 값이 6이 된다. 근데 그게 끝나지 않았을 때, T2가 8을 읽어오게 되고 좌석 8개에서 +1을 해서 값이 9가 된다. 근데, T2가 update를 치기전에 T1의 update가 먼저 발생하게 된다. 그리고나서 T2가 update를 하게 된다. 그러면 좌석의 값은 9가 되어버린다. 
  - 동일하게 밑에 있는 가격도 T1은 +1000을 해주고 update를 먼저해서 2000이 되고 T2가 T1이 끝나지 않았을 때 read를 해서 -500을 하고 update를 하면 총 매출은 500이 된다. 여기서 T1의 update가 먼저 발생하게 되서 그 때는 2000이지만, 그리고나서 T2의 update가 발생해서 총 매출은 500이 되어버린다. **즉, 우리가 원하는 결과와는 다른 상황이 되어버려서 마지막에 수행된 겹치는 T2 트랜잭션이 최종 결과를 다 덮어씌워 버린다.**
  - 이 경우에 만약 롤백이 발생하면 더 골치아파진다. ex) 만약 T1에서 총 매출 +1000이 중간에 실패를 했다면, 근데 이 타이밍이 살짝 어긋나서 T2가 발생이 끝났는데 갑자기 T1에서 롤백이 발생해서 처음으로 돌아가게 되어버리면 -> DB 데이터 1개에 연결된 모든 트랜잭션인 T1,T2 전부 다 롤백이 되어버린다. **이렇게 롤백이 이루어질 때 모든 트랜잭션이 롤백되는 경우를 "연쇄 복귀"라고 한다.**
  - **아니면 T1의 +1000에서 실패해서 롤백을 했는데, 도중에 T2 트랜잭션이 commit를 쳐버려서 뭔가 좌석은 8개인데 총 매출은 500이 되는 꼬여있는 상태가 될 수도 있다. 이런 상황을 "회복 불가능" 상태라고 한다.**
  - 이렇게 트랜잭션끼리의 관계에서 롤백이 되고, 커밋이 되고 이게 꼬이게 되는 이런 상황이 발생할 수 있다는 말이다. 


- **갱신 분실 해결 과정 - 데이터베이스 락 사용**
  - **그래서 이 문제를 해결하기 위해 락이 등장한다.** T1이 처음에 DB 데이터를 read하면서 Lock를 잡는다. 좌석 8개를 가지고 와서 -2를 하는 순간에 T2가 접근을 한다. 근데 Lock를 잡고 있으니까 waiting으로 T2는 기다리게 된다. 그래서 T1이 update를 하고 unlock 이렇게 lock를 풀면, 그제서야 T2가 read를 하고 +1를 하고 lock를 잡을 수 있게 되는 것이다. 이 때 읽어오는 값이 6이 되니까 결과는 +1해서 7이 되는 것이다. 
  - 그리고 T1도 T2가 lock를 잡고 있으니까 한번 더 waiting으로 기다려야 한다. T1이 총 매출에 +1000을 하려면 lock를 잡아야 하는데 지금은 T2가 잡고 있기 때문이다. 그래서 T2가 좌석값을 7로 바꾸는 update를 한 다음에 unlock를 한다. 그러면 그 때 다시 T1이 read를 하고 lock를 잡을 수 있게 되는 것이다. 그리고나서 T2가 다시 총 매출을 -500하려고 접근하면 waiting를 하게 된다. 그러면 T1이 +1000을 하고 update를 하고 unlock를 하면, T2가 그제서야 read한 다음에 -500를 하고 update를 할 수 있게 된다. **그래서 최종 결과가 좌석은 7개 / 총 매출은 1500으로 알맞게 나오게 된다.**
  

- **이렇게 되면 정말 이상적이지만, 여기서 문제가 발생할 여지가 1개 더 있다. DB에 있는 좌석: 8 / 총 매출: 1000이 서로 다른 A 레코드 / B 레코드라고 가정해보는 것이다. 그리고 T2의 로직 순서가 바뀐다고 생각해보자. 총 매출 -500이 먼저고 / 좌석 +1이 그 다음이다.**
  - 이 상태에서 T1이 먼저 좌석-2를 해야되니까 A를 read하고 lock를 한다. 그리고나서 T2에서 총매출-500를 해야되니까 B를 잡아서 read하고 lock를 한다. 그리고나서 T1에서 update/unlock를 하는 게 아니라 바로 총매출+1000를 하게 된다고 생각해보자. 그래서 lock를 풀지않고 바로 +1000를 하고자한다. 그래서 T1에서 B를 read하고 lock를 잡으려고 했는데 -> T2가 이미 B를 잡고있으니까 못잡게 된다. 그래서 B에대한 waiting이 된다. 그래서 B에 대한 lock이 실패하게 되고 기다리는 상태가 된다. 이어서 T2가 총매출-500에 이어서 바로 좌석+1를 하려고 A를 read/lock하려고 한다. 근데 이미 T1이 A를 read/lock를 잡고있기 때문에 그래서 T2가 실패하게 된다. T2도 waiting상태가 된다. 
  - 이렇게 되면, 이 상태에서 끝나게 된다. 더 이상 진행이 되지 않는다. 왜냐면, 선결조건이 하나도 만족하지 않는다. 도중에 lock를 풀었으면 괜찮았을텐데 T1/T2 둘 다 lock를 안풀고 T1에서는 A lock를 먼저 잡고 B lock를 잡으려고 했고, T2에서는 B lock를 먼저 잡고 A lock를 잡으려고 했다. 그래서 순서가 2개가 엇갈린 상태로 수행이 되서 A랑 B는 성공적으로 잡혔지만, 각각 다음 B랑 A를 잡으려고 할 때 코드들이 멈추게 된다. 그래서 둘다 멈춤상태가 된다. T2에서 트랜잭션을 끝내려면, A를 lock으로 잡아야지 나중에 B도 풀고 A도 풀게 되는데, A가 안 잡히니까 그냥 그 상태로 기다리고 있는 것이다. T1도 마찬가지이다. 
  - **그래서 이런식으로 교착 상태에 빠지는 것을 데드락 (Deadlock)이라고 한다.** 즉, 락 실행 타이밍이 맞지 않을 경우 무한 교착상태에 빠져 트랜잭션이 수행되지 않을 수 있는 상황이다.
  - **요새 많은 DB들은 MySQL를 포함해서 데드락을 타임아웃으로 거는 게 가능하다. 그래서, 위와같은 데드락 조건이 되었을 때, 내부적으로 돌고있는 시스템이 있어서 데드락을 감시할 수가 있다. 어떤 커넥션이 오랫동안 락을 서로 잡고 있는 그런 상황이 된다면, 그리고 이 상황이 몇 초 이상 교착상태가 된다면 --> 타임아웃이 되면서 강제로 2개를 롤백시켜 버리는 그런 설정도 있다. 그래서 요새는 이러한 설정이 잘 되어있기 때문에 데드락에 빠져도 영원히 빠져서 DB가 멈추는 경우는 잘 없다.** 


- **2단계 잠금 규약 락의 처리 과정**
  - 이제 앞서 언급된 데드락을 해결하기 위해서 2단계 잠금 규약이라는 2 Phase Locking이라는 개념이 등장한다.

34:35
