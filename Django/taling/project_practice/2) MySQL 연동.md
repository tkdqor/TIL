## SQLite
- **django에서는 우리가 별도로 설정하지 않으면, 기본 데이터베이스로 SQLite라는 파일 형태로 데이터가 저장된다. SQLite는 django 프로그램 내부에 SQLite 모듈과 같이 실행되어서 데이터를 처리할 때 그 모듈이 SQLite라는
  확장자를 가진 파일을 열고 수정하는 작업들을 해준다. 우리가 만든 웹어플리케이션의 포함되어있는 파일의 형태이다.**
- 그래서 1분에 1,2명 들어올 정도의 간단한 테스트 위주의 서비스라면 문제가 생길 정도는 아니다. 하지만, 실제 사용자에게 보여줄 제대로된 서비스라면 다른 데이터베이스를 사용해야 한다. SQLite는 파일이기 때문에 
  한 번에 1,2명 밖에 접속을 하지 못한다. 그래서 진짜 제대로된 웹 서비스라면 DBMS로 SQLite를 쓰는 경우는 거의 없다고 보면 된다. 
  - **동시에 여러 요청을 처리하게 되면 파일 잠금 현상이 발생한다.** 실제 WSGI를 써서 어플리케이션을 배포하게 되면, 다중 프로세스, 즉 우리가 만든 웹 어플리케이션이 마치 워드 프로세서 프로그램을 여러 개 띄운 것처럼 
    여러개가 실행되어서 사용자의 요청을 동시에 처리할 수 있게 되는 구조가 된다. 이러한 워드 프로세서가 하나의 파일이 사용하고 있는 상태에서 같은 문서를 또 열어보면 파일이 사용중이라고 열리지 않을 것이다. 이처럼 
    SQLite도 다른 요청이 데이터를 처리하고 있다면, 그 파일을 수정하고 있기 때문에 다른 사용자는 데이터에 접근하지 못하게 되는 큰 문제가 있다.
    - 그래서, 친구가 게시물을 올리는 0.0001초 내외에 그 짧은 시간에 내가 사이트에 접속을 하게 되면 데이터가 아예 뜨지 않는 문제가 발생할 수 있다. 
  - **2번째로 확장성도 떨어진다.** SQLite는 파일 형태이기 때문에 하나의 컴퓨터내에서 그 안에 프로그램만이 접근가능하다. django를 구현해서 서버를 띄운다면, django가 자신이 실행되고 있는 컴퓨터내에 SQLite파일에 
    접근하는 구조이다. 하지만 실제로 시스템을 구축해보면 웹서버를 여러 개 띄워놓고 서비스를 하게 된다. 그래서 하나의 컴퓨터내에 django 서버 프로세스를 여러개 띄워놓는 것 뿐만 아니라, 그런 컴퓨터를 계속 복제해서
    실제로 하나의 웹 서비스나 웹 사이트는 여러 개의 서버, 많게는 몇천 개의 서버가 동시에 들어오면서 다양한 요청을 처리하는 그런 형태가 된다. 그러다가 하나의 서버가 어떤 문제가 생겨 하드에 이슈가 생긴다던가,
    네트워크 장애 혹은 CPU 등 프로세스 자원에 문제가 생겨 종료되는 현상이 발생하는 경우도 생긴다. 그럴때는 요청들이 다른 서버로 전달이 분산되어서 실제 사용자는 오류없이 서비스를 경험할 수 있게 된다. SQLite를
    사용하면 이러한 구조 또한 만들 수 없다.
    
## MySQL
- 그래서, 일반적인 DBMS 데이터베이스 시스템이라는 것은 웹 서버와 별도의 서버 컴퓨터에서 동작할 수 있게 -> SQLite와 같이 소프트웨어에 내장되어있는 형태가 아니라, 그냥 하나의 프로그램처럼 제공되는 경우가 많다. 
  - 그 중 대표적으로 RDBMS에서 유명한 게 MySQL이다. AWS에서는 RDS라는 서비스를 통해서 클라우드 기반 서버 컴퓨터 형태로 MySQL 엔진을 제공한다. 우리가 만든 django 서버에서 이 RDBMS 서버를 사용하기 위해서 DB(데이터베이스)서버를 받아 연결해보자.

- **우리가 지금까지 개발한 것은 django 서버에 해당하고 - 데이터베이스 서버는 따로 존재한다.**
  - **사용자 여러명 -> 웹 앱 서버(django) / 웹 앱 서버(django) / 웹 앱 서버(django) ... -> 데이터베이스 서버**


### MySQL 실습 진행
- 실습을 하기 위해 AWS 웹사이트에 들어가서 로그인을 하자. 그래서 AWS 관리 콘솔 화면이 나오고 RDS를 클릭해주자.

1) 그 다음은, 데이터베이스 생성을 클릭. 뜨는 화면에서 표준 생성을 선택하고 엔진 유형은 MySQL를 선택하기.
   - Maria DB는 MySQL을 만든 초기 개발자가 다시 오픈 소스로 만든 DB. MySQL은 지금은 유료버전이 사용화되고 있다.
2) MySQL Community 에디션을 선택. 버전은 선택되어있는 버전 그대로 진행하기. 템플릿에서는 나중에 실제로 운영할 때는 프로덕션을 선택하는 게 맞으나, 비싸다. 우리는 프리 티어를 선택해서 무료로 사용하자. MySQL 라이센스는 애초부터 무료이기 때문에 우리가 프로그램 자체를 사용하는데는 돈이 안들지만, 이 프로그램이 뜨는 서버를 받는 것은 실제로 컴퓨터를 1대 받는 것이랑 똑같다. 그래서 돈을 원래 내야하는데 프리 티어로 무료로 12개월 동안 사용할 수 있는 것이다.
3) 설정부분에서는, DB인스턴스 식별자(이름)을 적는다. ex)tablebookings 그리고 마스터 사용자 이름과 비밀번호를 설정한다.
4) 그 다음, DB 인스턴스 클래스 부분은 프리 티어에 맞춰져 있어 건드릴 필요가 없다. 스토리지와 가용성 및 내구성 부분도 그대로 두자.        
   - DB 인스턴스 클래스는 CPU를 의미한다. AWS에서는 자원들에게 라벨링을 해놓았다. 그래서 T는 버스터블 클래스라고 해서 아마존에서는 CPU가 1이지만 CPU가 1보다 조금 넘게 사용되었을 때, 임계치를 넘어갔을 때 0.몇 단위로 조금 더 CPU자원을 끌어쓸 수 있는 클래스이다. 그렇게 버스터블한 상황이 됬을 때, 크레딧이 있어서 그 크레딧이 타입별로 한정이 되어있다. 비싼 타입일수록 더 많은 크레딧을 제공해서 평소에는 1 CPU 기본으로 돈을 내다가 갑자기 용량이 커졌을 때 30 CPU까지 늘어난다거나 이런게 가능한 가변적인 클래스이다. 항상 버스터블한 상태라면, 오히려 비싸지기 때문에 다른 스탠다드 클래스나 메모리 최적화 클래스를 사용할수도 있다. 
5) 연결 부분에서는, 퍼블릭 엑세스 라는 선택 항목이 있다. 이걸 '예'로 바꿔주자.
6) 마지막으로 데이터베이스 생성 버튼을 누르고 생성한다.
7) 이제 생성된 DB 식별자를 클릭해보면 상세화면이 보인다. -> 여기서 연결&보안 탭을 보면 **엔드포인트** 라고 해서 이 데이터베이스에 접속가능한 주소가 표시된다. 우리가 이 주소로 접속을 해서 데이터베이스를 내부에 하나 만들어놔야 한다.
   - 지금 우리가 AWS에 만든 tablebookings 데이터베이스는 개념상으로 데이터베이스 서버를 의미하는 것이다. (데이터베이스만을 담당하는 새로운 컴퓨터 1대 생성) -> 이 데이터베이스 서버안에 들어가서 개념 단위로 물리적인 단위가 아니라, 논리적인 단위의 데이터베이스를 하나 더 생성을 해놔야 한다. **그래서 하나의 "데이터베이스 서버"라는 것은 그 안에 여러개의 논리적인 형태의 데이터베이스 폴더같은 구조를 가지고 있다고 보면 된다.**  
8) 구글에 **dbeaver**를 검색하고 사이트에 들어가보자. https://dbeaver.io/ -> 이건 데이터베이스 관리를 UI로 엑셀을 다루듯이 해주는 툴이라고 보면 된다. 이 dbeaver 말고도 회사에 가면 **datagrip**이라는 툴이 많이 사용한다고 한다. 이 툴은 개발을 한다면 놓칠수가 없는 그런 회사 중 하나인 **jetbrains**라는 회사에서 만든 DB 관리 툴이라고 보면 된다. 이 툴은 trial 버전밖에 되지 않고 유료로 진행해야 한다. 그래서 일단 우리는 dbeaver 무료버전을 다운로드하고 사용해보자.
9) AWS에서 생성된 엔드포인트 주소를 복사하고, DBeaver에서 왼쪽 상단 플러그 버튼을 누르고 MySQL를 선택해주면 -> Connect to a database라는 창이 뜨게 된다.

<img width="895" alt="image" src="https://user-images.githubusercontent.com/95380638/158723708-8932e067-7a1f-402a-a9e9-364f0ec77b33.png">

10) 위의 화면에서 Server Host라는 부분에다가 복사한 엔드포인트 주소를 넣어준다. 포트는 AWS와 DBeaver모두 MySQL인 3306으로 일치되어있다. 그리고 Username에는 우리가 아까 설정한 마스터 사용자 이름을 적고 Password에는 비밀번호를 적는다.
11) 그런 다음, 좌측 하단에 Test Connection를 클릭하면 연결이 아직 되지 않는다..
12) AWS에 다시 가서 연결&보안 탭 -> VPC 보안 그룹 부분을 클릭해서 들어가보자. 아까전에 우리가 퍼블릭으로 인터넷 연결이 외부에서 되도록 퍼블릭 엑세스를 설정했지만 추가로 설정해야 할 것들이 있다.
    - 보안 그룹 부분이 방화벽 역할을 하게 된다. **방화벽이란, 어떤 데이터가 오고갈 때 어떤 포트만 열겠다 또는 어떤 주소만 열겠다, 어떤 데이터만 받겠다는 것처럼 벽을 세워놓는 것이다.** 그런데 기본적으로는 지금은 다 막혀있다. 
    - 그래서 인바운드 규칙 클릭 -> 인바운드 규칙 편집을 클릭하면 설정해줄 수 있다. 첫번째 줄은 사용자 지정 TCP / 22번 포트 / 내 IP로 설정하기. 22번 포트는 ssh 접근용이니까 내 IP만 허용하는 것이다. 두번째 줄은 MySQL 관련해서 사용자 지정 TCP / 3306 포트 / 내 IP로 설정하기. 세번째 줄은 HTTPS / Anywhere-IPv4 이렇게 설정. 네번째 줄은 HTTP / Anywhere-IPv4 설정. 이렇게 설정하고 저장을 누르자.

<img width="577" alt="image" src="https://user-images.githubusercontent.com/95380638/158738036-a01f6b5d-7e5b-4338-aabf-3ced5e1346bf.png">

13) 그리고 위와 같은 화면에서 다른 보안 그룹과 헷갈리지 않도록 이름을 설정하기.
14) 이 상태에서 다시 DBeaver 연결 화면으로 돌아가서 Test Connection를 클릭해보자. 그러면 Connection Test라는 창이 뜨면서 통과하게 되고 연결이 되었다는 의미이다. 그러면 이제 DBeaver의 좌측에 Database Navigator가 뜬다.
15) 그리고 아까 말했듯이 이 데이터베이스 서버안에 개념상으로 데이터베이스를 하나 만들어줘야 한다. 그래서 좌측 Navigator안에 Databases를 우클릭하고 Create New Database를 클릭하자. 데이터베이스 이름은 tablebooking이라고 해놓고 Charset은 어떤 언어를 지원할 것이냐의 문제인데, 기본적으로 되어있는 것처럼 utf8를 써야한다. utf8이 글로벌용이기 때문에 한국어, 일본어, 중국어 등 모든 언어를 지원하는 Charset이다. 그리고 뒤에 mb4라고 붙어있는데, 이건 이모지까지 포함한 특수문자들도 다 들어가 있는 Charset이라고 보면 된다. 그래서 그냥 디폴트로 되어있는 **utf8mb4**를 사용하면 된다.
    - 그리고 아래쪽에는 Collation이라고 나와있는데, 여기서는 **utf8mb4_unicode_ci** 를 선택하자. 이렇게 해줘야 문제가 없다. 이렇게 설정하고 확인하면 새로운 데이터베이스가 생성된다.

16) 그래서 좌측 Navigator에 생성된 tablebooking이라는 데이터베이스를 클릭해보면 Tables 라는 게 있는데, 여기에 이제 우리가 만들 모델과 하나씩 매핑이 되는 것이다. 

* * *
### django에서 데이터베이스 설정 수정하기
- 위의 과정을 모두 거친 다음, 이제 다시 django로 돌아와서 데이터베이스 설정을 바꿔보자. settings.py로 가서 DATABASES라는 항목이 있다. 여기에 있는 default라는 딕셔너리를 수정하면 되는데, 원래 sqlite3라고 되어있는 ENGINE 부분을 mysql로 수정하자.

```python

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'HOST': 'tablebookings.c1uzjwt0ilcb.ap-northeast-2.rds.amazonaws.com',
        'PORT': 3306,
        'NAME': 'tablebooking',
        'USER': 'tablebookings',
        'PASSWORD': 'qwaszxqwer1!',
    }
}
```

- 그리고 default라는 key의 value로 'HOST'를 추가하고 AWS에서 확인가능한 엔드포인트를 복사해서 붙여넣기를 한다.
- 그 다음에는 'PORT'를 추가하고 3306으로 설정한다. 
- 그리고 이미 있었던 'NAME' 이라는 부분은 값을 수정해주자. 우리가 만들어준 논리적 개념의 DB이름을 적는다. 여기서는 'tablebooking' 이라고 하자. (DBeaver에서 만든 이름)
- 마지막으로 'USER'를 추가하고 우리가 만든 마스터 사용자 이름을 적고 'PASSWORD'를 추가해서 비밀번호를 적어준다.

- **이 상태에서 추가로 또 진행해야 할 것이 있는데, django에서 해당 DB를 연결하려면 DB에 붙는 것을 도와주는 어댑터 역할, 콘센트 역할을 하는 무언가를 다운받아줘야 한다. 그걸 보통 클라이언트라고 한다.**
  - **우리가 생각하는 웹 브라우저도 클라이언트고, DB에 붙으려고 하는 콘센트 역할을 하는 것도 클라이언트의 입장이다. DB는 서버 입장이라고 볼 수 있다. 그래서 우리가 DB에 접속하는 입장에서는 클라이언트이기도 하지만, 이 클라이언트의 중간 단계에서 우리가 쉽게 통신할 수 있도록 도와주는 그런 모듈이 필요하다. 그래서 pip로 mysqlclient를 설치해야 한다.**

```terminal
pip install mysqlclient
```

- DBeaver에 나는 없지만, 원래 생성되는 information_schema나 performance_schema 같은 것들은 mysql 엔진에서의 메타 데이터들이 담겨있는 테이블들도 있고 환경변수들도 들어가 있다. 그래서 기본 테이블의 정체에 대해서도 한 번 살펴보자. 물론 우리처럼 서비스를 개발하는 입장에서는 우리가 아까 만들어둔 tablebooking안에 있는 테이블만 접근하게 되지만 다른 부분들도 확인해보자.

- mysqlclient가 다 설치된 이후에 이제 다시 python manage.py migrate 명령어를 입력하면 다시 진행이 된다.
  - migrate가 진행되고 나서 다시 DBeaver에 가서 tablebooking 데이터베이스를 새로 고침하면 

<img width="379" alt="image" src="https://user-images.githubusercontent.com/95380638/158742754-020eb1e5-63d1-40e8-a9cd-fef6e230d462.png">

- 이렇게 django 자체에 있는 모델 테이블들이 업데이트 된다. **django 자체에서 그냥 migrate만 해도 10개 정도의 테이블이 생겨있다. 이걸로 봐서 우리가 유추를 해보자면, 10개 테이블이 생겼다는 것은 django에서 미리 구현이 되어있는 모델이 10개라는 의미가 된다.** 
- 안에 있는 (auth앱의 user모델) auth_user 모델 테이블을 클릭해보면, 그 안에 column들이 어떤게 있는지 다 뜨게 된다.
