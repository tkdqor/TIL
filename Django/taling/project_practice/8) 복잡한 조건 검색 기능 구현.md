## 복잡한 조건 검색 기능 구현
- 식당별로 예약 슬롯에 따라서 조건을 추가해보기 
- 먼저 DBeaver에서 restauranttable 모델을 클릭하고 데이터들을 추가해주자. 데이터를 6개만 넣어준다.


### SearchView 수정
- **그리고 main.py에 있는 SearchView를 수정해주자. get_context_data 메소드 내부에 우리가 검색 받은 항목을 추가해준다.**

```python
import datetime

# 검색기능을 위한 View
class SearchView(TemplateView):
    template_name = 'main/search.html'

    def get_context_data(self, **kwargs):
        page_number = self.request.GET.get('page', '1')
        keyword = self.request.GET.get('keyword')
        category_id = self.request.GET.get('category')

        weekday = self.request.GET.get('weekday')
        start_time = self.request.GET.get('start')
        end_time = self.request.GET.get('end')

        category = None

        query_sets = Restaurant.objects.filter(visible=True).order_by('-created_at') 
        if keyword:
            query_sets = query_sets.filter(Q(name__istartswith=keyword) | Q(address__istartswith=keyword))   # Q 오퍼레이터로 or 조건해주기
        if category_id:
            # category = Category.objects.get(pk=int(category_id))   기존의 방식
            category = get_object_or_404(Category, id=int(category_id))    # get_object_or_404를 활용한 방식
            query_sets = query_sets.filter(category=category)
            
        relation_conditions = None
        
        if weekday:
            # SELECT * FROM Restaurant r INNER JOIN RestaurantTable rt ON rt.restaurant_id = r.id
            # WHERE rt.weekday = :weekday
            relation_conditions = Q(restauranttable__weekday=weekday)
            
        if start_time:
            start_time = datetime.time.fromisoformat(start_time) # 12:00:00
            if relation_conditions:
                relation_conditions = relation_conditions & Q(restauranttable__time__gte=start_time)
            else:
                relation_conditions = Q(restauranttable__time__gte=start_time)
        
        if end_time:
            end_time = datetime.time.fromisoformat(end_time) # 12:00:00
            if relation_conditions:
                relation_conditions = relation_conditions & Q(restauranttable__time__lte=end_time)
            else:
                relation_conditions = Q(restauranttable__time__gte=end_time)
        
        if relation_conditions:
            query_sets = query_sets.filter(relation_conditions)
        
        
        restaurants = query_sets.all()
        paginator = Paginator(restaurants, 12)

        paging = paginator.get_page(page_number)

        # include한 search_bar.html를 위해 변수 생성
        # categories = Category.objects.all()

        return {
            'paging': paging,
            'selected_keyword': keyword,
            'selected_category': category,
            # 'categories': categories, 
            'selected_weekday': weekday,
            'selected_start': start_time if start_time else '',
            'selected_end': end_time if end_time else '',
        }
```


- 요일과 시작시간, 그리고 종료시간을 추가로 선택할 수 있게 해준다. 그리고 카테고리 if문 밑에다가 relation_conditions라는 변수를 None으로 만들어준다. 이건 우리가 검색 조건을 설정할 때, 
  restaurantTable 모델은 restaurant 모델과 1:N관계이기 때문에 JOIN를 사용해서 조건을 구성해야 한다. 어떤 테이블과 테이블을 연결지어서 가져오는 것이다.   
  - 이 JOIN를 장고 ORM에서는 다른 식으로 표현한다. 
- **그 밑에는 if문을 사용해서 weekday가 있을 경우를 설정한다.**
  - 기본적으로 1:N관계로 모델의 관계를 설정했다면, 만약 restaurant 모델과 restaurantTable 모델이 그렇다면 --> restaurantTable 모델에서 related_name를 설정하지 않았다면, 
    restaurant 모델에서는 restaurantTable이라는 필드가 생성이 되어있는 것처럼 구성이 되어있다. 그래서 JOIN를 걸 때는, 즉 Q를 사용할 때 restauranttable 이라고 필드를 사용할 수 있다. 
    그리고 언더바 2개를 사용해서 restaurantTable 모델에 있는 필드에도 접근할 수 있게 된다. ex) relation_conditions = Q(restauranttable__weekday)
- **그 다음에는 start_time이 있을 경우를 if문으로 작성한다.**  
  - 먼저 받은 시작시간을 실제 시간으로 바꿔줘야 하기 때문에 datetime를 import 하자. 그리고 if문에서는 datetime 안에 time이라는 패키지가 있고 그 안에는 fromisoformat()이라는 함수가 있다. 이 함수 인자로 우리가 받은 시작시간을 넣어주면, iso 포맷에 맞게 time 형태로 바꿔주게 된다. 즉, 시간 데이터 타입으로 바꿔준다. python에 있는 내장 메소드이다. 
  - **iso 포맷은, 8601이라는 표준이 있다. ISO라는 국제 표준을 정하는 기구가 있고, 그 기구가 만드는 표준의 리스트들이 숫자로 넘버링이 되어있다. 그 중 하나가 8601인데, datetime의 표현 형식이다. 이 형식을 따라서 생성된 문자열이면 숫자나 date로 쉽게 변환할 수 있다.** 그래서 fromisoformat은 그런 형태와 표준을 지켜서 오는 문자열일 경우에는 --> time으로 잘 변환을 해주겠다 라는 것이다. 보통 넣으면 12:00:00 이런식으로 time만 온다. 만약, datetime.datetime.fromisoformat(start_time) --> 이런식으로 datetime 패키지 안으로 할 경우에는 2022-04-20 12:00:00 이렇게 연월일이 와야 한다. 그리고 마찬가지로 datetime.date... 는 2022-04-20 이런식의 형태일 것이다. 

- **그리고 start_time if문 안에 relation에 관련된 if문을 추가한다. relation_conditions이 있으면 기존 relation_conditions 조건에 and 조건으로 Q를 묶어서 붙여준다.**
  relation_conditions = relation_conditions & Q(restauranttable__time__gte=start_time) 이렇게 설정해서 Q로 restauranttable 모델의 시간 필드보다 클 때 시작시간을 저장한다. 
  - 만약 weekday가 없어 relation_conditions이 None일 경우에는, 조합이 아니니까 Q만 넣어주면 된다. 

- **end_time if문도 비슷하게 작성한다. 다만 Q 조건에서 greather then이 아닌, less then으로 수정해준다.**

- **지금까지 과정을 거치고 if문으로 relation_conditions이 있을 경우에는, 현재 쿼리셋에다가 filter를 사용해서 relation_conditions를 그대로 넣어주면 된다.**
  - 마지막으로 return 딕셔너리에 우리가 선택한 사항들을 보여줘야 하니까 변수들을 추가한다.
  - start_time의 경우는 있을 경우에만 넣고 없으면 공백 문자열을 넣어준다. 이렇게 안하면 없으면 None이기 때문에 문자열로 None으로 변환되서 나온다. 이걸 막기 위해 이렇게 한다. end_time도 마찬가지이다. 



