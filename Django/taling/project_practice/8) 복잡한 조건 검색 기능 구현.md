## 복잡한 조건 검색 기능 구현
- 식당별로 예약 슬롯에 따라서 조건을 추가해보기 
- 먼저 DBeaver에서 restauranttable 모델을 클릭하고 데이터들을 추가해주자. 데이터를 6개만 넣어준다.


### SearchView 수정
- **그리고 main.py에 있는 SearchView를 수정해주자. get_context_data 메소드 내부에 우리가 검색 받은 항목을 추가해준다.**

```python
# 검색기능을 위한 View
class SearchView(TemplateView):
    template_name = 'main/search.html'

    def get_context_data(self, **kwargs):
        page_number = self.request.GET.get('page', '1')
        keyword = self.request.GET.get('keyword')
        category_id = self.request.GET.get('category')

        weekday = self.request.GET.get('weekday')
        start_time = self.request.GET.get('start')
        end_time = self.request.GET.get('end')

        category = None

        query_sets = Restaurant.objects.filter(visible=True).order_by('-created_at') 
        if keyword:
            query_sets = query_sets.filter(Q(name__istartswith=keyword) | Q(address__istartswith=keyword))   # Q 오퍼레이터로 or 조건해주기
        if category_id:
            # category = Category.objects.get(pk=int(category_id))   기존의 방식
            category = get_object_or_404(Category, id=int(category_id))    # get_object_or_404를 활용한 방식
            query_sets = query_sets.filter(category=category)
            
        relation_conditions = None
        
        if weekday:
            relation_conditions = Q(restauranttable__weekday)
        
        restaurants = query_sets.all()
        paginator = Paginator(restaurants, 12)

        paging = paginator.get_page(page_number)

        # include한 search_bar.html를 위해 변수 생성
        # categories = Category.objects.all()

        return {
            'paging': paging,
            'selected_keyword': keyword,
            'selected_category': category,
            # 'categories': categories, 
        }
```


- 요일과 시작시간, 그리고 종료시간을 추가로 선택할 수 있게 해준다. 그리고 카테고리 if문 밑에다가 relation_conditions라는 변수를 None으로 만들어준다. 이건 우리가 검색 조건을 설정할 때, 
  restaurantTable 모델은 restaurant 모델과 1:N관계이기 때문에 JOIN를 사용해서 조건을 구성해야 한다. 어떤 테이블과 테이블을 연결지어서 가져오는 것이다.   
  - 이 JOIN를 장고 ORM에서는 다른 식으로 표현한다. 
- 그 밑에는 if문을 사용해서 
  - 기본적으로 1:N관계로 모델의 관계를 설정했다면, 만약 restaurant 모델과 restaurantTable 모델이 그렇다면 --> restaurantTable 모델에서 related_name를 설정하지 않았다면, 
    restaurant 모델에서는 restaurantTable이라는 필드가 생성이 되어있는 것처럼 구성이 되어있다. 그래서 JOIN를 걸 때는, 즉 Q를 사용할 때 restauranttable 이라고 필드를 사용할 수 있다. 
    그리고 언더바 2개를 사용해서 restaurantTable 모델에 있는 필드에도 접근할 수 있게 된다. ex) relation_conditions = Q(restauranttable__weekday)
