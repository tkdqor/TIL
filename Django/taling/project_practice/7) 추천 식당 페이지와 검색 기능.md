## 추천 식당 페이지와 검색 기능

### 키워드 검색 기능
- https://docs.djangoproject.com/en/4.0/ref/models/querysets/ 해당 django 공식 문서를 보면, Field lookup이라는 것이 있다. 여기서 여러가지가 있지만, 키워드 검색의 경우
  contains라는 조건이 있고 startswith이라는 조건과 endswith이라는 조건이 있다. 이 때, 이 조건들 앞에 i라는 것이 붙어있으면 --> 대소문자를 무시하는 조건이 되기도 한다. 우리가 앞서 배웠던 
  B Tree를 고려하면 startswith이 조금 더 제대로된 인덱스를 탈 것이라고 유추할 수 있다. 
- 검색은 카테고리를 조건으로 걸 수도 있고 키워드나 둘 다 가능하다. 그래서 search View 라는 걸 만들어서 이걸 조건으로 받도록 구현을 해보자.


### Search View 생성
- views 디렉터리 - main.py에서 코드를 생성하자.

```python
from django.core.paginator import Paginator
from django.shortcuts import get_object_or_404
from ..models import Recommendation, Restaurant, Category
...

# 검색기능을 위한 View
class SearchView(TemplateView):
    template_name = 'main/search.html'

    def get_context_data(self, **kwargs):
        page_number = self.request.GET.get('page', '1')
        keyword = self.request.GET.get('keyword')
        category_id = self.request.GET.get('category')
        
        query_sets = Restaurant.objects.filter(visible=True).order_by('-created_at')
        if keyword:
            query_sets = query_sets.filter(name__istartswith=keyword)
        if category_id:
            # category = Category.objects.get(pk=int(category_id))   기존의 방식
            category = get_object_or_404(Category, id=int(category_id))    # get_object_or_404를 활용한 방식
        
        restaurants = query_sets.all()
        paginator = Paginator(restaurants, 12)
        
        paging = paginator.get_page(page_number)
        
        return {
            'paging': paging,
        }
```


- TemplateView를 상속받는 SearchView를 만들어주고 template이름을 정해주자. 그리고 get_context_data 메서드 내부에는 검색결과의 페이지네이션을 적용하기 위해서 page_number 변수를 request에서 GET 파라미터로
  page 값을 받고, 없을 경우에는 1페이지부터 시작하도록 설정해준다.
- 그 다음에는 keyword 값도 받는다. 기본적으로 검색결과 라는 건, GET으로 받게 된다. 보통 POST로 받지 않는데 그 이유는, 검색결과 화면을 우리가 url를 그대로 복사해서 보존하거나 공유하는 경우가 많기 때문이다.    
  또한 즐겨찾기에 추가하는 경우도 있다. 그래서 특정 검색 결과는, POST처럼 일시적으로 데이터가 전달되고 끝나는 그런 형태가 아니라 --> 쿼리 내용들이 url에 보존이 되야되는 경우이기 때문에 GET를 사용해서   
  페이지를 띄우게 된다. 그래서 우리도 GET 파라미터를 활용하자.
- keyword는 검색할 키워드 값을 받는 것이다. / category_id도 받는다. 어떤 카테고리에 속해있는지 그 pk값을 GET으로 받는다. 
- 그 다음에는 이제 queryset를 작성하자. Restaurant 모델을 import하고 visible 조건으로 필터하고 생성일 내림차순으로 조건문을 만들어준다. 아직 DB에 실행은 안된 것이다.    
  - 그리고 if문으로 keyword 변수에 값이 있을 때, 즉 none이 아닐 때는 filter를 한번 더 걸어서 keyword로 시작하는 이름을 가져와준다.
  - 또한, if문으로 category가 있을 때도 해준다. 받은 category_id로 Category 모델에서 해당 인스턴스를 찾아준다. 그리고 그 찾은 인스턴스를 Restaurant 모델에서 필터로 찾아주는 것이다.
- 그리고 마지막으로 restaurants = query_sets.all() 이 코드를 입력해서 해당 조건에 있는 query_set를 전부 가져오는 식으로 마무리 한다.  
  - 추가로, import로 Paginator 객체를 불러오자. 그리고 Paginator 객체를 사용하여 쿼리셋을 집어넣고 paginator = Paginator(restaurants, 12) 이렇게 입력하면 한 페이지에 12개를 보여주겠다는 의미이다.
  - 그 다음에는 paging변수를 사용해 객체를 가져오고 우리가 받은 page_number를 띄울 수 있도록 get_page 메서드를 사용해준다.

- **지금까지의 과정처럼, filter 메소드를 중첩하게 되면 --> and 조건으로 중첩이 된다.**

- **추가로, category = Category.objects.get(pk=int(category_id)) 해당 코드에서 카테고리가 없는 경우에는 오류가 발생하게 된다. 카테고리가 5개까지 밖에 없는데 6번째가 들어가면 정상적인 접근이 아니라는 것을 사용자한테 알려줘야 한다. 그래서 오류를 띄우는 건 맞는데 --> 오류가 뜰 때의 페이지가 너무 별로라는 문제가 있다.**
  - 그래서 우리가 실제로 라이브로 배포할 때는 --> settings.py에서 기존의 장고 오류 페이지를 꺼줘야 한다. DEBUG = True라고 되어있는 부분을 False로 바꿔주고 배포를 해야 오류성 페이지가 그대로 사용자한테 노출되지 않도록 하게 된다. 
  - **지금은 일단 View에서 데이터가 없다는 의미의 404에러를 띄워주자. 그게 바로 django의 shortcuts에 get_object_or_404 라는 것이다.** 이걸 사용하기 위해서 오류 처리인 try-except를 사용할 수도 있지만, get_object_or_404 함수를 직접 사용하는 게 훨씬 깔끔하다.
    - get_object_or_404 다음에 모델명을 넣어주고, 우리가 받은 id만 넣어주면 오류 처리를 할 수 있다.
    - 404 에러는 HttpResponse의 응답 코드가 된다. 이러한 응답의 경우 --> 웹 표준상으로 응답 코드라는 것을 만들어서 응답 코드가 웹의 응답이 정상인지 뭐가 잘못됬는지를 함축적으로 나타낼 수 있게 표준에서 정의해두고 있다. 


### HTTP Response Status
- HTTP 요청이 정상적으로 처리되었는지 혹은 어떤 문제가 발생했는지 의미를 파악할 수 있게 해주는 표준 코드이다. 백엔드를 구현할 때 직접 의미를 알고 맞게 응답을 내려주는 것이 권장된다.
  - 200~ : 정상
  - 400~ : 클라이언트 요청의 잘못 / 기본적으로 없는 데이터에 접근했을 때 넘겨주는 코드. 그 데이터가 우리쪽에 없다고 알려주는 것이다. 또한 다른 401은, 인증되지 않고 허가받지 않은 요청을 의미. 403은 아예 막혀져 있는 요청 값을 보낸 경우를 의미. 400은 요청 형식이 잘못되었을 때를 의미. 
  - 500~ : 서버 오류 

- 관련 문서도 있다. https://developer.mozilla.org/ko/docs/Web/HTTP/Status
  - 100번대의 Information responses는 보통 어떤 정보를 알려주기만 할 때 호출이 되는 경우이다. 하지만 우리가 실질적으로 많이 사용하지는 않는다. 
  - 우리가 많이 사용하는 건, 200 / 400(서버가 a,b,c 받기로 했는데 d를 보내주는 경우) / 401(클라이언트가 인증절차를 거치지 않고 서버에 접근했을 때, 로그인 안한 경우) / 403(나는 로그인을 했는데, 그 로그인된 사용자가 접근할 수 있는 권한이 없는 경우) / 404(어떤 리소스에 접근했는데 그 리소스가 없는 경우) / 405(어떤 POST를 지원하지 않는 View를 만들었는데 사용자가 POST로 접근하는 경우)
  - 500번대는 서버와 관련된 오류이다. 500 / 501 이 2개가 어플리케이션 서버에서 발생할 수 있는 오류. 그리고 우리가 나중에 서버 확장하면서 load balancer나 nginx를 이용해서 분산 처리를 할 때, 내부에 있는 어플리케이션 서버가 죽어있거나 문제가 있으면 502 또는 503 에러를 발생시킨다. 또는 504가 날 때도 있다. --> **이 3가지가 보통 웹서버 즉, django의 앱서버가 아니라 그 앞단에서 요청을 분산처리 시켜줄 때 게이트웨이 역할을 해주는 그런 서버에서 발생할 수 있는 코드들이 된다.**






* * *

### url 및 template 설정
- 이제 table_bookings 디렉터리 내부에 있는 urls.py에다가 코드 추가해주기

```python
from web.views.main import IndexView, SearchView
...

urlpatterns = [
    ...
    # 검색 기능 URL
    path('search/', SearchView.as_view(), name='search'),
]
```
