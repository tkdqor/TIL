## 마이 페이지
- django의 기본 유저를 사용하면 username 필드가 unique여야 한다. 
- 소셜 로그인을 하면 username에 소셜 계정의 닉네임이 들어가는 이슈가 발생한다. 
  - 이러한 문제를 해결하기 위해 abstractuser 라는 걸 상속받아 새로운 모델로 사용할 수도 있고, all auth의 어댑터를 재구현해서 username을 이메일로 업데이트 하는 방법도 있다. 전자는 너무 많은 부분을 
    수정해야 되니까 후자로 해보자.
    
- **models.py로 가서 새로운 모델을 추가해준다.**

```python
from allauth.socialaccount.adapter import DefaultSocialAccountAdapter
from allauth.socialaccount.models import SocialAccount
import uuid
...

class CustomSocialAccountAdapter(DefaultSocialAccountAdapter):
    def populate_user(self, request, sociallogin, data):
        user = super().populate_user(request, sociallogin, data)
        user.username = user.email[:30]
        if User.objects.filter(username=user.username).exists():
            user.username = str(uuid.uuid4())
        return user

```

- 이렇게 DefaultSocialAccountAdapter를 상속받는 클래스를 정의한다. **from allauth.socialaccount.adapter import DefaultSocialAccountAdapter 이렇게 import를 해주면 된다. 
  이건 소셜 account가 우리쪽 DB에 입력될 때 실제 기존 User 모델과 어떻게 데이터를 저장하고 처리할지 정하는 어댑터라고 보면 된다.** 우리가 이걸 재구현해서 소셜 데이터가 들어올 때, 우리쪽에 User 
  데이터를 넣는 과정에서 변환하는 과정을 수정하는 것이다. 
- 그리고 SocialAccount 모델도 가져오고, 우리가 겹치지 않는 username을 만들기 위해서 uuid도 import를 해주자. 

- CustomSocialAccountAdapter 클래스에서는 populate_user라는 걸 오버라이드 한다. 이게 user를 처리하는 메소드가 된다. 일단 super클래스에 있는 걸 그대로 호출하고, 그 user의 username 값을
  user.email 이렇게 이메일로 넣어주는 것이다. 그리고 필드자체가 30자까지만 들어가니까 30자로 짤라서 넣어준다.
  - 그 다음에는 user의 username이 동일한 게 있다면, uuid로 교체해서 겹치지 않도록 설정해준다. 
  - 그리고 이렇게 populating이 될 때 이메일이 겹칠 경우에는, 중간에 우리가 all auth를 디폴트로 쓰게 되면 이메일을 확인하는 페이지가 뜨게 되는데 이걸 안 뜨게 하기 위해서 처리를 한 것이고, 마지막에는 return user를 해준다.


- **그 다음으로는 settings.py로 가서 맨 밑에다가 

```python
SOCIALACCOUNT_ADAPTER = 'web.models.CustomSocialAccountAdapter'
ACCOUNT_UNIQUE_EMAIL = False
```

- **우리가 방금 추가한 모델을 이렇게 설정을 해줘야 설정값을 보고 우리가 생성한 모델을 Adapter로 사용하게 된다.** 그리고 ACCOUNT_UNIQUE_EMAIL = False 이렇게 해줘야 중복 이메일이 허용된다.

- 이후에는, 이렇게 세팅된 DB 중, 그러니까 DBeaver에서 account_emailaddress 모델을 클릭하고 -> Properties를 클릭하고 -> Constraints를 클릭하면 email unique Key가 있다. 이것을 삭제해준다. 그래서 기존에 생성된 스키마에 이메일 조건이 지금 Constraints가 unique로 되어있어서 이걸 수동으로 삭제해줘야 정상적으로 동작을 하게 된다. 

* * *

### django signal 스펙
- **그리고 이제 사용자가 생성될 때, 사용자가 없으면 자동으로 user 프로필을 생성할 수 있게 하기 위해서, django의 시그널이라는 스펙을 사용해볼 것이다.**
  - 이 기능의 목적은 django에서 관리하는 특정 이벤트가 발생하기 직전 혹은 이후에 특징 로직을 발견해서 추가하게 해주는 것이다. 그러니까 시그널이라고 하면 '신호'라는 의미이니까 그렇게 생각하자.         **django에는 어떤 DB 이벤트나 아니면 django에서 정의하는 여러가지 시스템 이벤트라고 할 만한 것들이 있는데, 그래서 이런 이벤트가 발생했을 때 -> 우리가 중간에 캐치를 해서 그 이벤트가 발생한 시점에 '뭔가 처리를 하고 싶다' 라는 코드를 작성해두면, django가 그걸 기억해두었다가 그 이벤트가 발생하는 전이나 후에 처리를 해주는 것이다.** 
  - 우리는 DB의 사용자 데이터가 추가된 직후에 유저 프로필을 생성하도록 post_save 라는 시그널을 받도록 구현해보자. 다시 models.py로 돌아가서 추가하자.

```python
from django.db.models.signals import post_save
from django.dispatch import receiver
...

@receiver(post_save, sender=User)
def on_save_user(sender, instance, **kwargs):
    profile = UserProfile.objects.filter(user=instance).first()
    social_account = SocialAccount.objects.filter(user=instance).first()
    if profile is None and social_account is not None:
        nickname = instance.email.split('@')[0]
        UserProfile.objects.create(
            user = instance,
            nickname = nickname,
            profile_image = None,
            verified = True,
        )

```

- from django.db.models.signals import post_save 이렇게 먼저 django db에 있는 정의된 시그널 중 하나가 post_save라는 걸 import한다. **signals 패키지를 command로 들어가보면, 시그널이 여러개가 있다는 것을 확인할 수 있다.**
  - DB가 init 되었을 때(pre_init - DB init 전 / post_init - DB init 후) 
  - 특정 데이터가 저장되기 직전은 pre_save / 직후는 post_save
  - 특정 데이터가 삭제되기 직전은 pre_delete / 직후는 post_delete
  - **이런식으로 정해져 있다. 우리는 User 데이터가 추가된 직후이니까 post_save를 import 해야된다.**

- **그리고 또 from django.dispatch import receiver 이렇게 import를 해준다. 이건 우리가 receiver 데코레이터 패턴을 사용할 수 있기 위해 import 하는 것이다.**

- models.py 맨 밑에 receiver를 사용해서 코드를 추가한다. @receiver(post_save, sender=User) 이렇게 하면 'User 모델에서 post_save가 발생하면' 이라는 의미가 되고 실제로 발생하면 이 함수가 실행된다는 의미이다. 그래서 그 밑에 on_save_user라는 함수를 정의해준다. 그리고 profile = UserProfile.objects.filter(user=instance).first() 이 코드는 데이터가 저장될 때, 기존에 UserProfile 데이터가 있는지 검사하는 것이다. 또한, social_account 데이터도 가져온다.
  - 그 다음 중요한 건, profile이 없을 때 라는 if문 조건이다. if profile is None and social_account is not None: 이렇게 profile 데이터는 없고 social_account는 있을 때 라는 것이다. 이 social_account는 SocialAccount 모델에 현재 유저가 매핑되어 있다면, 이 유저는 소셜 로그인으로 로그인한 유저이다. 그래서 profile이 생성이 안 되어있다면, nickname = instance.email.split('@')[0] 이렇게 nickname 필드를 생성해준다. 0번을 가지고 온다. 그리고나서 UserProfile 모델에 create ORM으로 데이터를 생성한다. 
  - **이렇게 하면, 이제 시그널을 받아서 사용자가 생성될 때는 알아서 프로필도 생성되게끔 해준다. 지금까지의 로직은 우리가 소셜 로그인을 할 경우, 이런식으로 따로 강제로 default 프로필을 생성하는 로직을 넣어준 것이다.** 


* * *

### 화면 구성
- **이제는 화면을 구성해야 되기 때문에 web이라는 앱의 내부에 forms.py에 코드를 추가해주자.**


migration 안함?





