## 결제 기능
- **결제 기능은 결제 모듈을 제공하는 PG의 모듈이나 API를 연동하면서 이루어지게 된다.** PG사는 이니시스, KCP, 토스페이먼츠 등이 있다. 이러한 PG사 모듈을 쉽게 연동하게 해주는 회사들도 있다. 
- **우리는 테스트 결제를 할 수 있는 토스페이먼츠를 통해서 테스트 결제까지만 해보자. 우리가 나중에 실 결제가 될 수 있도록 해보려면, 보통은 사업자 등록을 해야되고 PG사에게 운영 라이브 신청을 하고 
  그 뒤에는 카드사 심사 과정을 다 거친 다음에야 실제 결제를 발생시킬 수 있다. 그전까지는 테스트 결제밖에 안 된다.**
  
- restaurant.py의 BookingView를 다시 보자. 여기서 예약을 먼저 하게 되는데, 일단 명시적으로 초기 데이터의 결제상태를 READY로 정해주자.

```python
# 결제기능을 위한 View
class BookingView(LoginRequiredMixin, TemplateView):
    template_name = 'restaurant/book.html'
    login_url = reverse_lazy('login')

    def create_order_number(self, seat_id):
        now = datetime.datetime.now().strftime("%Y%m%d%H%M%S") 
        return now + str(seat_id) + str(random.randrange(1000, 10000))

    def get_context_data(self, restaurant_id, seat_id):
        # get의 경우, 좌석을 사전에 확보 + 폼 그리기 
        # post의 경우, 주문 정보 업데이트 

        with transaction.atomic():
            new_order_number = self.create_order_number(seat_id)
            seat = get_object_or_404(AvailableSeat, id=seat_id)
            if seat.remain <= 0:
                messages.warning(self.request, '잔여 좌석이 없습니다.')
                return redirect('restaurant-view', restaurant_id)
            
            booking, created = Booking.objects.get_or_create(
                user = self.request.user,
                restaurant = seat.restaurant,
                table = seat.table,
                seat = seat,
                status = Booking.PayStatus.READY,   # 새로 추가한 코드
                defaults = {
                    'price': seat.table.price,
                    'order_number': new_order_number,  
                } 
            )

            # if new_order_number == booking.order_number:
            if created:
                seat.remain = seat.remain - 1
                seat.save()
            
            booking.save()

            return {
                'seat': seat,
                'booking': booking,
            }
    
    def post(self, request, *args, **kwargs):
    ...
```


- status = Booking.PayStatus.READY,  이렇게 추가하는 이유는 우리가 결제대기 중인 데이터들만 재활용을 하도록 할 것이다. 만약에 캔슬이 되거나 혹은 페이드가 되거나 하는 경우에는 재활용을 하면
  안 될 것이다. 그래서 사용자가 처음에 특정시간에, 예로 20일 12시에 결제를 1자리 한 다음에 1명이 더 온다고 그래가지고 이후에 좌석을 하나 더 예약 할 수도 있을 것이다. 그래서 동일한 유저인 경우에도,
  동일한 날짜에 여러 번 결제를 할 수 있다 라는 가정을 깔고 있어야 한다. 그래서 READY인 경우만 booking, created = Booking.objects.get_or_create 이렇게 가지고 오게 되는 것이다. 
  그리고 혹시나 없으면 READY인 상태로 데이터를 생성하게 된다. 
  
  
* * *

- 이어서 아래에 결제를 처리하는 화면을 만들 것이다. BookingView 아래에 코드를 추가해주자.

```python
...
class PayView(TemplateView):
    template_name = 'restaurant/confirm.html'

    def get_context_data(self, status):
        pg_key = self.request.GET.get('paymentKey')
        order_number = self.request.GET.get('orderId')
        amount = self.request.GET.get('amount')
        
        booking = get_object_or_404(Booking, order_number=order_number)
        
        if booking.price != int(amount) or booking.status != Booking.PayStatus.READY:
            raise PermissionDenied()
        
        
        # 결제 최종 승인으로 우리가 PG사한테 최종 컨펌 API호출하기
        response = requests.post('https://api.tosspayments.com/v1/payments/' + pg_key, json={
            'amount': amount,
            'orderId': order_number,
        },
        
        )
```        
        
- 이렇게 PayView를 만들어주고 GET 방식으로 데이터를 받을 때, status를 같이 받도록 인자를 설정해준다. 

- **그리고 pg_key = self.request.GET.get('paymentKey') 이렇게 pg_key를 받는데, PayView같은 경우는 우리가 연동할 PG사에서 결제가 다 끝나고 나서, 즉 결제창을 열고 카드사 인증 등을 
  거친 뒤에 그 인증이 끝나고 나면 다시 우리 화면으로 돌아오게되는 과정이 있다. 그래서 우리 웹사이트로 돌아와서 우리의 페이지, 뷰를 redirection를 시켜주게 된다. 이 때, paymentKey라는 이름으로
  key를 제공해주는 형태로 메뉴얼이 되어있다. 이 값은 우리가 --> Booking 모델을 models.py에서 정의할 때 pg_transaction_number 필드를 의미하게 된다.** 그래서 이렇게 거래 건에 대해서 
  pg_key를 하나 주게 된다. 그걸 paymentKey라고 명명해서 GET 파라미터로 우리쪽에 redirection을 시켜준다. 
- 그리고 우리쪽에서 발급한 거래번호인 order_number가 orderId라는 명칭으로 오게 된다. 또한, 결제금액인 amount 값도 받아준다. 

- **즉, 이렇게 결제 인증이 끝나고나서 --> 실제로 입출금이 일어나는 결제 승인 직전에 받는 이 PayView에 대해서 위와같은 3개의 파라미터들을 세팅을 해주면 된다.** 이 PayView는 결과적으로 
  결제 인증이 끝나고나서 체크한뒤에 유효하다면, 예를 들면 amount 값을 인증 결과로 받았는데, amount 값이 변조가 되어있을 수도 있을 것이다. 우리는 2만원을 받아야하는데 갑자기 1원으로 되어있다던가 
  한다면, 이 거래 건은 취소를 시켜야 할 것이다. ==> **그래서 위의 코드들이 이러한 검증을 우리쪽에서 한번 더 시켜주고자 하는 그런 의도의 코드라고 생각하면 된다.** **지금까지의 def get_context_data(self, status):
  이 부분들을 결제 컨펌, 결제 승인 과정이라고도 부른다.**
  
- 여기서 이제 검증이 통과를 하면, 다시 PG사한테 백엔드에서 그쪽 백엔드로 API로 호출을 해가지고 '정말 이거는 유효하니까 이대로 거래를 컨펌할께' 라고 알려주는 통신을 보내면 --> 이제 실제로 금액의
  입출금이 일어나게 되는 것이다. 
  
- booking = get_object_or_404(Booking, order_number=order_number) 이렇게 설정해서 Booking데이터에서 받은 order_number가 저장된 데이터를 가지고 온다. 근데 여기서, booking의
  price가 amount와 일치하지 않는다면, 아니면 booking.status가 READY가 아니라면 --> 문제가 있는 것으로 간주해서 PermissionDenied 에러를 발생시켜준다.
  
- **그 다음 코드부터는 이제, 우리가 PG사의 결제 확인을 컨펌시켜주는, 그러니까 실제로 돈을 처리해라 또는 결제를 최종처리해라 라고 승인해주는 API를 호출하는 부분이다.** 
  - response변수로 requests를 사용해서 API를 호출하고 pg_key도 붙여준다. 또한 json으로 데이터를 전달하게 되어있다. 
  - 그리고 header를 추가로 보내게 되어있다. 





