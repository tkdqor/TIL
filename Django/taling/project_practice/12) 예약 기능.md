## 예약 기능
- 이번에는 예약 페이지와 예약 기능 만들기 
- 먼저 models.py로 가자. 추가로 테이블 작성하기. 현재 여유가 있는 좌석의 수를 미리 가지고 있는 그런 레코드가 된다. 

```python
...

class AvailableSeat(models.Model):
    restaurant = models.ForeignKey(Restaurant, on_delete=models.CASCADE)
    table = models.ForeignKey(RestaurantTable, on_delete=models.CASCADE)
    datetime = models.DateTimeField()
    remain = models.IntegerField(default=-1) 
    created_at = models.DateTimeField(auto_now_add=True, null=False)
    
    class Meta:
        unique_together = ('restaurant', 'table', 'datetime')
        

class Booking(models.Model):
    user = models.ForeignKey(User, on_delete=models.SET_NULL, null=True)
```


- **AvailableSeat 모델은 restaurant 모델과는 1:N관계로 설정. 그리고 RestaurantTable과도 1:N설정. 여기서 요일과 시간만 참조하는 것이다. 그래서 RestaurantTable은 요일별로 예약가능한 시간을 정하는 타임테이블 역할을
  해주는 것이다.** 
- 여기서 datetime 필드는 구체적인 날짜가 들어간다. 지금부터 10일치가 예약이 가능한데, 그래서 10일치의 date가 RestaurantTable의 time과 합쳐져서 이 time이 12시이면 datetime에는 20일 12시 
  이렇게 된다. **즉, AvailableSeat 모델은 실질적으로 해당 날짜의 예약된 잔여 좌석 수라고 보면 된다.**
- 남은 좌석을 remain이라는 필드로 표현. default는 -1인데, -1일 경우에는 그냥 아예 시트가 배정되지 않은 걸로 해서 처리를 하자. 0일 경우에는 품절이라고 보는 게 맞는 것 같다. -1은 애초부터 좌석이 
  없었던 시간이라고 보면 된다. 
- 이 모델도 unique를 지정하자. 3개의 필드가 겹치지 않도록 하는 것이다. 

* * *

- **그 다음 모델로는 예약 내역을 의미하는 Booking이라는 모델이다.**
- 어떤 사용자가 예약을 한 것인지 기입할 수 있는 user 필드가 필요하다. 해당 필드를 사용자가 삭제되었을 때 SET_NULL로 설정했다. null도 True로 했다. 이렇게하면, user 값이 null일 때도 제약조건이
  깨지지 않아서 존재할 수가 있다. **이렇게 하는 이유는, 사용자가 회원탈퇴를 할 수도 있기 때문이다. 회원탈퇴를 하더라도 이 예약 내역 존재자체는 그대로 DB에 남아있어서 나중에 식당이 예약내역을 모아서 
  보고 싶다고 했을 때, 예약을 했던 내용은 전부 다 볼 수 있도록 남겨두는 것이다.**
