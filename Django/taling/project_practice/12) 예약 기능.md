## 예약 기능
- 이번에는 예약 페이지와 예약 기능 만들기 
- 먼저 models.py로 가자. 추가로 테이블 작성하기. 현재 여유가 있는 좌석의 수를 미리 가지고 있는 그런 레코드가 된다. 

```python
...

class AvailableSeat(models.Model):
    restaurant = models.ForeignKey(Restaurant, on_delete=models.CASCADE)
    table = models.ForeignKey(RestaurantTable, on_delete=models.CASCADE)
    datetime = models.DateTimeField()
    remain = models.IntegerField(default=-1) 
    created_at = models.DateTimeField(auto_now_add=True, null=False)
    
    class Meta:
        unique_together = ('restaurant', 'table', 'datetime')
        

class Booking(models.Model): 
    user = models.ForeignKey(User, on_delete=models.SET_NULL, null=True)
    restaurant = models.ForeignKey(Restaurant, on_delete=models.CASCADE)
    table = models.ForeignKey(RestaurantTable, on_delete=models.CASCADE)
    seat = models.ForeignKey(AvailableSeat, on_delete=models.CASCADE)
    
    class PayMethod(models.TextChoices):
        CARD = 'CARD', _('카드')
        
    class PayStatus(models.TextChoices):
        READY = 'READY', _('결제대기')
        PAID = 'PAID', _('결제완료')
        FAILED = 'FAILED', _('예약실패')
        CANCELED = 'CANCELED', _('예약취소')
```


- **AvailableSeat 모델은 restaurant 모델과는 1:N관계로 설정. 그리고 RestaurantTable과도 1:N설정. 여기서 요일과 시간만 참조하는 것이다. 그래서 RestaurantTable은 요일별로 예약가능한 시간을 정하는 타임테이블 역할을
  해주는 것이다.** 
- 여기서 datetime 필드는 구체적인 날짜가 들어간다. 지금부터 10일치가 예약이 가능한데, 그래서 10일치의 date가 RestaurantTable의 time과 합쳐져서 이 time이 12시이면 datetime에는 20일 12시 
  이렇게 된다. **즉, AvailableSeat 모델은 실질적으로 해당 날짜의 예약된 잔여 좌석 수라고 보면 된다.**
- 남은 좌석을 remain이라는 필드로 표현. default는 -1인데, -1일 경우에는 그냥 아예 시트가 배정되지 않은 걸로 해서 처리를 하자. 0일 경우에는 품절이라고 보는 게 맞는 것 같다. -1은 애초부터 좌석이 
  없었던 시간이라고 보면 된다. 
- 이 모델도 unique를 지정하자. 3개의 필드가 겹치지 않도록 하는 것이다. 

* * *

- **그 다음 모델로는 예약 내역을 의미하는 Booking이라는 모델이다.**
- 어떤 사용자가 예약을 한 것인지 기입할 수 있는 user 필드가 필요하다. 해당 필드를 사용자가 삭제되었을 때 SET_NULL로 설정했다. null도 True로 했다. 이렇게하면, user 값이 null일 때도 제약조건이
  깨지지 않아서 존재할 수가 있다. **이렇게 하는 이유는, 사용자가 회원탈퇴를 할 수도 있기 때문이다. 회원탈퇴를 하더라도 이 예약 내역 존재자체는 그대로 DB에 남아있어서 나중에 식당이 예약내역을 모아서 
  보고 싶다고 했을 때, 예약을 했던 내용은 전부 다 볼 수 있도록 남겨두는 것이다.** 대신에 사용자정보는 날라가기 때문에 여기가 null로 채워질 것이고 그러면 실제 사용자의 개인정보는 파기가 된다. 대신에 예약 내역 자체는 사용자가 탈퇴한다고 해서 지워지지 않도록 설정한 것이다. 
- 다른 restaurant과 table 필드는 1:N으로 설정. 
- **그리고 Booking 모델 아래쪽에는 결제 정보도 같이 들어갈 것이다. 그래서 내부에 PayMethod라는 클래스를 하나 정의해준다.**
  - 결제방식을 정의하는건데, 우리는 지금 카드 결제만 할 것이니까 카드 결제만 넣어두자. 

- **그리고 결제 상태를 의미하는 클래스도 정의해준다.**
  - 결제를 아직 진행하지 않은 READY / 결제가 된 PAID / 결제가 실패한 FAILED / 결제가 취소된 CANCELED 

- **또한, 주문번호를 의미하는 order_number 필드를 정의해준다. 이 필드는 PG사랑 내 주문 결제건이랑 연동하는데에 통영되는 하나의 key로 쓰이게 된다.** 그래서 결제가 붙는 대부분의 서비스들은 주문번호라는 개념이 꼭 있어야 한다. **당연히 이 주문번호라는 건, 해당 모델의 pk인 id가 그대로 쓰이는 건 좋은 방법이 아니다.** 왜냐면, 그렇게 되면 내 내부에 있는, 내부 데이터에 대한 정보가 그대로 다른 곳에 노출이 되는 것이기 때문에 바람직하지 않다. 또 이게 서비스단에서는, 주문번호는 보통 시간이 들어가는 무작위의 값이 생성된다. 그러다보니까 이 값을 가지고 우리 서비스의 매출을 유추하기는 쉽지 않다. 근데 만약에 id를 외부에 보낸다거나 이렇게 데이터 설정을 자주 하게 되면, 이 id값이 카운트가 1부터 계속 늘어나게 되니까 만약 id = 100이라면, '아 지금까지 여기가 100건 결제되었구나' 라고 유추할 수 있게 된다. 게다가 이제 id같은 경우 목적이 다르다고 볼 수 있다. 
  - **id는 레코드가 DB에 저장된 순번, 즉 DB에 우리가 접근하기 위한 key에 가깝고 / order_number는 이 주문에 대한 정보에 대해서 PG사랑 고객이랑 전부 소통하기 위한 어떤 일련번호가 되는 것이다. 그래서 보통 우리가 주문을 할 때 연/월/일 과 같이 현재 시간이 앞에 들어가 있는 주문번호를 많이 보게 된다. 그렇게 굳이 만든 이유는, 이 사이트의 관리자인 admin도 그렇고 / 고객도 그렇고 / PG사 입장에서도 그렇고 이 order_number 라는 KEY를 보게되면 --> 쉽게 이 주문이 언제 생성되었는지 유추하기 쉬워진다.**

10:01






