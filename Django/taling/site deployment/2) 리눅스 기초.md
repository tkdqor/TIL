## 리눅스 기초
- 이번에는 Ubuntu 리눅스의 명령어 즉, 리눅스 전체적인 명령어에 대해서 알아보자. 
- 먼저 EC2 인스턴스에 접속한 상태가 되어야 한다. 

- 먼저 pem 파일의 권한을 수정한다.

```terminal
chmod 400 {키 파일 이름 및 경로}.pem
```

- 그리고 맥의 Terminal을 실행 한 뒤 다음의 커맨드 입력해서 접속한다.

```terminal
ssh -i {키 파일 이름 및 경로}.pem ubuntu@{서버 ElasticIP}
```


### 리눅스 명령어 - 배포과정과 함께 알아보기
- 대표적으로 5개 종류로 나눌 수 있다. 

**1) 프로그램 설치**
- 리눅스 계열 OS에서는 확인된 소프트웨어를 쉽게 설치하기 위해서 OS 자체적으로 프로그램을 알아서 설치해주는 기능을 제공해준다. 일반 리눅스에서는 yum이라고 사용하고, 우리가 사용할 우분투 계열에서는

```terminal
ubuntu@ip-172-31-22-117:~$ apt-get
```

- 이렇게 사용한다. 중요한 건 소프트웨어 설치 시, 시스템 구성을 건드리는 경우가 많기 때문에 앞에 sudo라는 명령어를 붙여줘야 한다. super do의 약어 같은 느낌으로, 슈퍼 관리자 권한으로 명령어를 실행시켜주는 명령어이다. 처음 우분투 서버를 세팅하면 배포를 위해 해야 하는 명령어부터 시작해보자. 

```terminal
ubuntu@ip-172-31-22-117:~$ sudo apt-get update
```

- **이렇게 업데이트를 하면 apt-get 명령어 자체를 업데이트하기 때문에, 최신 소프트웨어를 받기 위해서 먼저 이 명령어부터 입력한다. 이후 빌드 환경을 위한 소프트웨어를 알아서 설치해주는 빌드 에센셜을 설치해보자.**


```terminal
ubuntu@ip-172-31-22-117:~$ sudo apt-get install build-essential
```

- 도중에 계속하겠냐고 물어보면 y 입력. 이렇게 빌드 에센셜 명령어를 입력해서 apt-get으로 설치하게 되면 -> 우분투 저장소에서 코딩할 때, 프로그래밍을 할 때 빌드에 필요한 어떤 라이브러리나 환경 구성들을 전부 다 설치해준다. 설치가 끝나고 나면 이어서 우리가 python3랑 python3 pip도 사용해야 하니까 그래서 이것들을 설치하는 것도 해보자. 

```terminal
ubuntu@ip-172-31-22-117:~$ sudo apt-get install python3 python3-pip
```

- 이렇게 python3 다음에 공백을 두고 또 입력하면 동시에 패키지 2개를 설치할 수 있다. 다 설치가 되고나서 

```terminal
ubuntu@ip-172-31-22-117:~$ python3 -V
```

- 이렇게 확인해보면 python 버전이 뜨면서 설치된 걸 볼 수 있다. 


**2) 파일 편집 명령어**
- 이제 파일 편집 명령어를 보자. vr, vi, vim 나노가 있는데 3가지 명령어 모두 파이 편집기를 여는 역할을 하지만, UI가 조금씩 다르다.
- 우리는 가장 기본적인 vi 명령어를 통해서 파일을 생성하고 편집하는 작업만 해보자. 

```terminal
ubuntu@ip-172-31-22-117:~$ vi example
```

- 이렇게 vi 다음에 파일명을 입력하면, 해당 파일이 있다면 파일이 열리고 / 없으면 새로운 파일을 생성하는 화면이 열린다. 그래서 위의 명령어를 입력해준다.
- vi를 치고 들어오면 --> 화면이 깨끗하게 비어있다. 이거 자체가 바로 파일 편집기 창이 된다. 우리가 파일 편집기에 접근한 것이다. 
- **그리고 이 상태에서 시프트 콜론 버튼을 누르면 밑에 콜론 글자가 뜨게 된다. 이렇게 콜론이 뜨고 q를 입력하고 엔터하면 다시 탐색기를 나갈 수 있다.**

```terminal
...
:q
```

- **다시 vi example로 들어간 다음, i를 누르면 화면 하단에 -- INSERT -- 라고 표기된다. 이러면 "입력 모드"가 된 것이라서 이 때부터 esc를 누르기 전까지는 키 입력이 전부 파일에 기록된다.**
- i를 입력하고 나서,

```vim
hello world!
welcome to django world 
powered by python3 

...

end of file
```

- **이렇게 입력하고 esc를 눌러서 입력 모드를 나간다. 그 다음 맨 밑에 /world 이렇게 슬래쉬를 누르고 world라는 글자를 입력해보면 일치하는 걸 찾아준다. 엔터를 누르면 검색을 해주면서 커서 위치가 이동이 된다. 여기서 n 키를 누르면 다른 일치 케이스로 커서가 이동한다.**
- **그리고 1g를 입력하면 파일의 처음으로 커서가 이동하고 / g를 입력하면 커서가 파일의 끝으로 이동한다.**

- 다시 :q를 누르면, 아직 저장이 안되었기 때문에 나가지 못하게 된다. 
  - **그래서 :w를 눌러서 저장을 먼저 해준다.** 그리고 다시 :q를 하면 vi에서 나가게 된다.


**3) 파일 관련 명령어**

```terminal
ubuntu@ip-172-31-22-117:~$ pwd
```

- **pwd는 현재 파일 위치를 알려준다. 처음 ssh를 접속하면, /home/ubuntu 경로로 접속되기 때문에 초기 경로가 나온다.** 


```terminal
ubuntu@ip-172-31-22-117:~$ cp example example2
```

- **cp는 카피의 약어로 복사 명령어이다. cp 복사할 파일 그리고 복사할 파일명을 저장하면 파일이 복사된다.** 
- 위의 코드처럼 cp example example2 이렇게 하면, 기존에 우리가 만들었던 example이라는 파일을 example2로 복사하는 것이다. 


```terminal
ubuntu@ip-172-31-22-117:~$ mv example example3
```

- **mv는 무브의 약어로 파일을 이동하거나 파일명을 바꿀 때 사용한다.** 
- mv 이동할 파일 그리고 이동할 경로나 이름을 지정하면 된다. 
- mv example example3 이렇게 하면, 기존의 example 파일을 example3으로 바꿀 수 있다. 


```terminal
ubuntu@ip-172-31-22-117:~$ ls
example2 example3

ubuntu@ip-172-31-22-117:~$ ls -l
total 8
-rw-rw-r-- 1 ubuntu ubuntu 75 Oct 12 19:46 example2
-rw-rw-r-- 1 ubuntu ubuntu 75 Oct 12 19:45 example3
```

- **ls는 리스트 디렉토리의 약어로 파일의 목록을 보여준다. 그래서 만약 ls 하고 -l이라는 옵션을 같이 입력하면 리스트의 형태로 보여준다.** 
- ls만 입력하면 현재 경로의 파일 리스트가 뜨게 되고, ls -l을 입력하면 이렇게 목록 경로로 보여준다.
- -rw-rw-r-- --> 이건 순서대로 소유자/그룹사용자/모든유저 이렇게 되고 rw는 읽기/쓰기 권한을 의미한다. 그래서 소유자와 그룹사용자는 읽고 쓰는 권한이 되고 모든 유저들은 읽기권한만 되고 쓰기 권한은 안 되는 것이다.


```terminal
ubuntu@ip-172-31-22-117:~$ rm example3
```

- **rm은 리무브의 약어로 파일을 삭제한다. 그래서 rm 다음에 파일 경로를 지정하면 파일이 삭제가 된다. 지금은 example3 파일을 삭제하게 된다.**


```terminal
ubuntu@ip-172-31-22-117:~$ cat example2
hello world!
welcome to django world
powered by python3

...

end of file
```

- **cat은 catenate의 약어로 파일의 내용을 출력해준다.** cat 다음에 example2라고 파일명을 입력하면 -> 파일 내용을 그냥 바로 출력해준다.


```terminal
ubuntu@ip-172-31-22-117:~$ mkdir world
```

- **mkdir은 make directory의 약어로 폴더를 생성한다.**
- mkdir world 이렇게 입력하면 world라는 폴더가 생성된다. 


```terminal
ubuntu@ip-172-31-22-117:~$ cd world
```

- **cd는 change directory의 약어로 특정 경로로 이동할 때 쓰인다.** 여기서 cd world라고 하면 -> world 폴더로 들어가게 된다. 


```terminal
ubuntu@ip-172-31-22-117:~/world$
```

- **여기서 보이는 물결 표시는 우리가봤던 /home/ubuntu/ -> 이 경로를 보통 물결로 표시한다.**
- 정확하게 말을 하면 내가 접속한 계정의 home 디렉터리를 물결로 표시하는 건데, 지금 우리는 ubuntu라는 계정으로 방금 접속했으니까 ubuntu의 home 계정은, home 디렉터리는 바로 /home/ubuntu/ 이기 때문에 이렇게 슬래쉬로 대체되서 보이는 것이고 그 다음에 우리가 world라는 위치에 있으니까 ~/world 이건 ==> /home/ubuntu/world 이걸 의미한다. 
- 또한, cd ..를 입력하면 다시 상위 폴더로 이동한다. 
- cd / 이렇게 입력하면 최상위 폴더로 이동하게 된다. 이 상태에서 ls -l를 입력하면 --> 리눅스 최상위 폴더에 있는 모든 폴더들이 전부 표시가 된다. 


```terminal
ubuntu@ip-172-31-22-117:~$ tail example2
```

- **tail이라는 명령어는 파일 내용의 마지막 내용을 출력할 때 쓰인다. tail 다음 파일명을 입력하면 마지막 내용이 나오는데 지금은 파일명이 길지가 않아 그냥 다 뜨게 된다.**
- **이 명령어는 로그를 볼 때 자주 쓰이는데, f 플래그랑 같이 명령어를 입력하면 실시간으로 파일이 변할 때 변하는 내용을 계속해서 트래킹해서 보여준다.** 

```terminal
ubuntu@ip-172-31-22-117:~$ tail -f example2
```

- **이렇게 입력하면, 커서가 원래 상태로 돌아오지 않는데, 여기에 로그 같은 것들이 append가 될 때, 데이터가 추가될 때마다 화면에 계속 알아서 출력이 된다.**
  - 이 때는 ctrl + C를 누르면 빠져나올 수 있다.  


**4) 권한 관련 명령어**
- 리눅스의 권한에 대한 부분을 이해하려면 사용자와 그룹을 알아야 한다. 생각보다 많은 OS가 알게 모르게 비슷한 구조로 되어있다. 윈도우나 맥의 경우도 컴퓨터를 켜서 바탕화면까지 도달하려면, 비밀번호를 입력해야 된다. 
- **우리가 우분투에 ssh로 접속할 때도 기본 계정인 ubuntu라는 계정으로 OS에 로그인했다고 보면 된다.**
- **중요한 건 OS 시스템에서 계정별로 특정 파일은 실행하지 못하게 하거나, 중요한 시스템 파일들을 보안을 위해 최고 관리 권한을 가진 사용자만 실행하고 수정하게 하거나 하는 등으로 구성한다는 점이다.**
  - 우리가 앞에서 apt-get을 쓸 때 sudo가 없이는 제대로 실행이 안 되는 게 ubuntu 계정에 있는 권한만으로는 프로그램을 설치할 수 있기는 어렵기 때문이다. 
  - 그래서 sudo를 실행하면 임시로 최고 관리 권한을 부여해서 실행하기 때문이다. 참고로 최고 관리 권한을 기본적으로 가지고 있는 계정을 "루트"라고 하는데, 특정한 경우를 제외하고는 보안 이슈로 루트 ssh를 통해 바로 접속하는 경우는 없다고 보면 된다. 

- 이러한 사용자들은 그룹이라는 개념으로 묶일 수가 있는데, 그래서 파일에 대한 권한 예를 들면 실행하거나 편집하거나 읽을 수 있는 권한을 그룹에 포함된 유저 전체를 대상으로 부여할 수 있다. 

- **ch모드는 체인지 모드의 약자이다. 파일의 시스템 모드를 바꾸는 역할을 한다.** 사실 이 명령어가 리눅스 명령어 중에서 이해하기가 어려운 편이다. 보통 다음의 형태로 기호를 조합해서 실행하게 된다. 

```terminal
ubuntu@ip-172-31-22-117:~$ chmod [class][operator][mode] path
```

- **chmod 다음에 클래스 / 연산자 / 모드 그 다음에 파일 경로를 입력하는 문법을 가지고 있다.**
- **클래스 란에는 u나 g나 o나 a 이런것들이 들어갈 수 있다. 연산자는 플러스나 마이너스 같은 게 들어갈 수 있다. 모드는 r,w,x가 들어갈 수 있다.** 
  - u는 소유사용자, g는 같은 그룹 내 사용자, o는 소유한 사용자 외의 사용자, a는 모든 사용자, u는 그냥 유저, 그룹은 g, o는 ownership except이다.
  - 연산자의 경우에는 +해서 권한을 부여하거나 -해서 권한을 뺄 수 있다. 
  - r은 읽기권한, w는 쓰기권한, x는 실행하기 권한 이렇게 부여할 수 있다. 

- ex) 그래서 만약 example2에 쓰고, 읽고, 실행할 권한을 모든 사용자에게 허가한다면

```terminal
ubuntu@ip-172-31-22-117:~$ chmod a+rwx example2
```

- **이렇게 입력해주면 된다. 권한이 적용되었는지 보려면 ls -l를 입력해보면 된다. 그러면 플래그가 바뀌어있다.** 지금은 플래그가 -rwxrwxrwx 이렇게 되어있어서 ==> 모든 사용자가 전부 다 rwx를 다 수행할 수 있는 권한이 있다. 그래서 순서대로 첫 rwx는 소유자 / 그다음 rwx는 그룹 사용자 / 그다음 rwx는 나 외에, 소유한 자 외에 다른 사람들의 권한들이다. 

- **이러한 권한 부여는 알파벳 기호 대신에 8진수로 표현해서 부여할 수도 있다.** 우리가 ssh 접속할 때 입력했던, 팸 파일에 체크 모드 400이라는 걸 입력했을 것이다. 이게 소유자에게만 읽기 권한만 주는 명령어 였다는 것이다.
  - **팸에는 이런 명령어를 줘야지만 실제로 키로 읽어서 접근할 수 있게끔 뭔가 리눅스나 ssh 클라이언트 속성이 그렇게 설정되어있다.**


```terminal
ubuntu@ip-172-31-22-117:~$ ps -ef
```

- **그리고 ps라는 명령어는 현재 실행되고 있는 프로세스의 리스트를 보여준다.** 우리가 실제로 익혀야 하는 옵션은 딱 2개이다. 
  - 위에 처럼 -ef라는 옵션을 붙여서 입력하면 -> 현재 실행되고 있는 목록이 뜬다. 


```terminal
ubuntu@ip-172-31-22-117:~$ ps -ef | grep sshd(검색할 프로세스명)
```

- 이번에는 이렇게 ps -ef | grep 다음에 검색할 프로세스명을 입력해보자. 그러면 sshd와 관련된 프로세스가 몇 개가 있다는 걸 알 수 있다. 그리고 해당 권한권 자는, 첫번째 것은 root라는 얘가 실행시킨 것이고, 세번째는 ubuntu 이렇게 다양하다. 


```terminal
ubuntu@ip-172-31-22-117:~$ ps -ef | grep py
```

- 나중에는 이렇게 python의 첫글자인 py만 들어가는 프로세스만 볼 수 있다. 


```terminal
ubuntu@ip-172-31-22-117:~$
```

- kill은 프로세스를 종료할 때 쓰는 명령어인데 




