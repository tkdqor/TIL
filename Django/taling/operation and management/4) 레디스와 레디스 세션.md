## 레디스와 레디스 세션
- 이번에는 서비스 확장에 대해 고민을 해보자. 우리가 서비스를 하나 배포한다고 가정해보자. 배포를 진행해서 하나의 컴퓨터에 django 서버가 실행되고 있는 것이다. 
- 처음에 몇명의 사용자가 작게 접속할 때는 문제가 없으나 사람이 계속 늘어난다면 -> 서버 1대의 한계치를 넘어서서 요청을 처리하지 못하고 튕겨내거나 밀리게 된다. 이럴 때 허용량을 늘리기 위해서 서버의 대수를 
  늘리는 것을 "스케일 아웃"이라고 한다. 또는 서버 1대의 스펙이 늘어나는 경우(CPU나 메모리값이 증가)를 "스케일 업"이라고 한다.

- **이렇게 서버의 대수가 늘어나는 스케일 아웃 상황일 때, 세션의 공유문제에 주목할 필요가 있다.**
  - 사용자가 하나의 서버에서 로그인을 했다면 세션이 서버 메모리에 기억이 된다. 하지만 스케일 아웃을 해서 서버가 여러 대 라고 하면 다른 서버로 접속하게 되었을 때는 그 서버는 사용자를 기억하지 못한다. 그래서 로그인 유지가 되지 않는다. 이 문제를 해결하는 방법은 크게 2가지가 있다.

- **세션 고정**
  - 하나는 세션이 만들어진 서버에 같은 요청을, 로그인이 된 사용자 요청을 계속해서 고정시키는 방법이다. 이건 중간에 라우팅을 해주는 무언가가 있어서 요청 HTTP 헤더에 세션 ID를 읽어서 특정 서버로 계속 보내주는 것이 가능할 수 있다. HTTP 헤더 정보로 서버를 고정시키는 것이다. 

- **세션 공유**
  - 두번째로는 공유하고 있는 어떤 메모리가 있어서 세션을 같은 곳에 저장하고 불러오는 방법이 있다. 이걸 위해 우리가 배운 MySQL과 같은 디스크에 저장되는 형태의 DB를 사용할수도 있지만, 세션 데이터는 기본적으로 영구적으로 저장되는 게 아니라, 영구적으로 저장될 필요가 없는 휘발성 데이터이다. 그리고 수시로 조회가 발생하기 때문에 빠른 속도, 잦은 요청을 처리해야 한다.
  - **컴퓨터의 구조 상, 데이터가 어떤 디스크에 저장되어 있는 것 보다는, 메모리에 저장되어 있는 게 속도가 더 빠르다.** 그래서 디스크보다는 메모리(램..)에 저장되어 있는 게 더 빠른데, 이 메모리 보다는 CPU에 달려있는 캐시 메모리라는 것이 있다. 
  - **그래서 Disk < Memory < Cache 메모리 순으로 빠르다. -> CPU에서의 거리에 따라 접근속도, 처리속도가 더 빠르지만, 용량이 비교적 더 작고 유지기한이 짧다는 단점이 있다. 그래서 일반적인 데이터베이스 보다는, 메모리에 저장하는 게 좋은데, 이 때 등장하는 게 바로 "메모리 데이터베이스"이다.**


## 레디스
- **메모리 데이터베이스 중에 대표적인 레디스에 대해서 알아보자. 이 레디스를 django에서 스케일 아웃에 대비하기 위해 세션을 저장하는 공유 메모리 저장소로 사용하려고 한다.**
- 레디스는 Remote Dictionary Server의 약자로 메모리 기반 데이터베이스를 의미한다. 그래서 키 - 밸류 형태의 자료구조를 가지고 메모리에 데이터를 저장하는 방식이다. **키 - 밸류 형태의 자료구조 라는 건, python의 딕셔너리를 생각하면 되는데, 우리가 배운 해시 테이블이 이런 딕셔너리 형태 자료구조의 원형격 개념이라고 보면 된다.** 
  - 그래서 해시 테이블과 유사하게 탐색속도가 O(1)이다. 데이터가 저장된 레코드의 개수와 상관없이 무조건 한 번에 해당 데이터에 바로 접근할 수 있어 효율적이고 빠르다는 장점이 있다. 대신에 범위 검색이 어렵다. 
  - 그래서 레디스는 범위 검색을 효율적으로 하기 위해 내부적으로 ZRANGE라는 정렬된 리스트를 구현하는 식으로 해결하는 방법이 있긴 있다. 하지만 레디스의 탄생 배경을 생각해보면, 키 - 밸류 형태의 데이터를 저장하는 데에 더 적합하다고 볼 수 있다. 이 구조를 이용해서 -> 세션을 저장하는 데 쓰거나, 서버의 캐시 데이터를 저장하는 데 쓰는 경우가 많다. 


### 레디스의 특징
- 싱글 쓰레드 : atomic하다(분산을 위해서 토폴로지, 샤딩, 클러스터 등의 개념으로도 확장해 나갈 수 있음). 
  - 우리가 데이터베이스에서 트랜잭션을 배울 때, atomic를 배웠는데 **어떤 데이터가 삽입되거나 삭제되거나 조회가 될 때 항상 단일 연산으로 수행된다는 것이다.** 그래서 트랜잭션이 잘 유지된다고 볼 수 있다. 
  - 보통 컴퓨터는 하나의 컴퓨터 내에서 여러 프로그램을 동시에 실행하는 게 가능하다. 그리고 그와 비슷하게 하나의 프로그램은 동시에 여러 작업들을 병렬적으로 실행할 수 있다. 컴퓨터 사이언스에서는 프로그램을 "프로세스", 작업을 "쓰레드"라는 실행단위로 묶어서 이야기를 한다. 
  - 그래서 싱글 쓰레드라는 것은, 하나의 프로그램에서 하나의 작업을 하게 된다. 즉 실행단위 내에서만 연산이 수행된다는 것을 의미한다. 레디스에서는 다른 서버에서 Read, Update 요청이 동시에 들어오더라도 메모리에 대한 작업은 정확하게 하나씩 순서대로 수행되게 된다. 즉, atomic 연산에 대해서 보장이 된다는 것이다. 
- O(1)의 탐색속도로 속도가 아주 빠르다. 
- 인메모리 I/O가 빠르다. 
  - 인메모리는 서버의 메모리 상에서 이 데이터들을 저장하고 조작하기 때문에 디스크에서 직접 처리하는 것 보다는 I/O가 훨씬 빠르다. 대신에 서버 장애 시, 우리가 디스크에 반영구적인 방식으로 저장한 게 아니라서, 램카드에 들어간 데이터들은 전부 날라가게 된다. 우리가 컴퓨터를 켰다가 그냥 전원을 내려버리면 -> 실행중인 파일이 다 날라가는 것 처럼, 서버 장애 시 데이터의 유실 발생이 가능하다. 
- 위의 문제를 보완하기 위해 Disk 저장 지원 
  - Snapshot : 특정 시점 데이터를 그대로 저장 / 현재 메모리상에 올라와있는 모든 데이터값들을 어떤 시점마다 그대로 사진 찍듯이 데이터를 직렬화해서 다른 데이터로 변환해서 파일로 떨궈주는 것이다. 그래서 특정 시점으로 데이터를 복구할 수 있게 된다.
  - AOF : 연산을 로깅(Binary Logging), 즉 연산을 하나씩 저장하는 방식이다. 
    - 예를 들어 레디스 DB안에 키 테이블에 키1이 하나 있다고 가정하고 여기에 데이터를 넣었다. 이게 첫번째 연산이 된다. 이 메모리 데이터베이스에 첫번째로 수행된 작업이다. 두번째 연산으로는 키3에 데이터를 넣었다. 그리고 세번째 연산으로는 키1에 있는 데이터값을 A로 변경했다. 이걸 실제로 로그로 남겨보면 -> 1 key1 = D / 2 key3 = D / 3 key1 = A -> 이렇게 해서 1,2,3 이라는 순서가 나왔고 이것들을 하나씩 로그로 남기는 것이다. 그래서 이 로그를 파일에 저장해두고 있는 것이다. 이걸 Binary Logging이라고 한다. 즉, 모든 연산을 순서대로 파일에 저장해서 가지고 있다가 나중에 복구할 때 이걸 처음부터 똑같이 실행하면 복구가 된다는 개념이다. 이 Binary Logging이라는 개념이 레디스에만 사용되는 건 아니고 MySQL이나 다른 DB에서 이걸 사용하고 있다. 데이터의 백업이나 복구를 위해서 말이다. 
    - 또한, 나중에 우리가 배울 클러스터링, 즉 DB에 데이터를 저장할 때 다른 DB, 복구용 DB에 내 DB에서 수행된 연산들을 전달해서 내가 가지고 있는 데이터를 똑같이 싱크를 맞출때도 이런 방식을 사용한다. 


## 레디스에 대해 오해하지 말아야 할 것
- **데이터연산이 수행되는 곳이 싱글 쓰레드인거지 레디스 전체가 싱글 쓰레드라는 게 아니다.**
  - 디스크에 스냅샷, AOF를 저장하는 쓰레드도 있고 버전 6부터는 외부 서버로부터 요청을 받고 응답을 돌려주는 부분을 멑티 쓰레드로 구현하고 있음. 
  - 이벤트 루프(OS 커널 단에서 kqueue, epoll, iocp 등을 사용)와 I/O 멀티플렉싱을 통해 동시에 들어오는 요청들의 동시성을 효율적으로 처리하되 각 연산은 싱글 쓰레드에서 발생해서 원자성을 보장
    - OS 커널 관련은, 비동기적으로 OS에서 내부적으로 처리하기 위한 인터페이스이다. kqueue, epoll은 리눅스 계열에서 사용하는 것이고 iocp는 윈도우즈 계열에서 사용하는 인터페이스이다. 이게 커널에서 지연되는 툴 같은 것이라고 보면 된다. 그래서 OS 자체에서 OS에 설치된 프로그램들을 위해서 비동기적으로 어떤 I/O Iuput이나 Output에 들어오는 하드웨어 로직이나 어떤 데이터 시그널이나 이런것들을 잘 유연하게 처리하기 위해 이러한 인터페이스들을 제공한다. 그래서 이런것들을 가지고 이름을 붙인 것이다. 이걸 사용해서 이벤트 루프를 Redis에서 구현해서 멀티플렉싱을 사용해서 외부 네트워크의 요청들을 유연하게 처리할 수 있다.
  - 즉, 멀티 쓰레드로 뭔가 외부적으로 데이터를 입력받고 그런것들이 있긴 하지만 결과적으로 연산을 처리하는 부분은 싱글 쓰레드로 되어있어서 atomic이 보장된다는 것이다. 

- **하나의 연산의 원자성이 보장된다는 것이지 하나의 작업의 트랜잭션이 보장되는 게 아니다.**
  - 위의 예시처럼 key1에 대해서 D라는 데이터가 들어가고, 그리고 key3에는 S가 들어갔다고 해보자. 예를 들어 우리가 코드상에서는 2개의 연산을 한 번에 수행할 수도 있다. 레디스 안에서는 이게 각각 하나씩 수행이 되지만 / 우리가 코드상에서 구현할 때는 이걸 동시에 묶어서 처리하고 싶을 수 있다. 그러다보니까 이럴때는 당연히 트랜잭션이 보장되지 않는다는 것이다. 
  - **만약 트랜잭션을 안 묶어주게 되면, 위의 k1 = D / k3 = S 의 로직이 실행되고 있고, 다른 쓰레드나 프로세스에서 k1 = S를 수행하고 있다면 -> 처음에 기존 로직에서 k1 = D가 실행되고 그 사이에 다른 쓰레드에서 k1 = S 이게 실행이 될 수 있다. 즉 엇갈려서 실행이 될 수도 있다는 것이다.** 
  - **대신에 k1 = D 이렇게 키 하나에 대해서 매핑된 값에 대해서는 원자성이 보장된다. 이 키가 업데이트 치는 동안에는 k1 = S가 접근해서 변경할 수는 없다는 의미이다.**
  - 그래서 로직 단위로, 하나의 작업 단위로 하려면 Redis Trasaction를 내부적으로 지원하고 있기 때문에 이 기능을 활용해서 여러 연산들을 묶을 수 있다. 


## 토폴로지 / 샤딩 / 클러스터
- 앞서 분산을 위해서 토폴로지, 샤딩, 클러스터 등의 개념으로도 확장해 나갈 수 있다고 했었다. 싱글 쓰레드이면 하나의 컴퓨터에서 모든 연산이 이루어져야 하니까 스케일 아웃이 불가능한 구조가 아닐까 생각되는데, 즉 하나의 컴퓨터에 설치된 Redis에서 싱글 쓰레드가 있는 곳은 결국 하나의 컴퓨터내에서 이루어져야 한다. 그러다 보니까 스케일 아웃이 불가능한 구조처럼 생각될 수 있다.
- 그래서 이걸 극복하기 위해 Redis에서는 3가지 확장 구조를 지원한다. 토폴로지 / 샤딩 / 클러스터인데 이 개념은 Redis 뿐만 아니라 데이터베이스 전체적으로 확장을 할 때 사용되는 개념이다. 우리가 앞서 배운 MySQL 경우도 이런식으로 어떤 데이터를 여러 서버에서 서비스를 할 수 있도록 구축을 하고 있다. 


### 토폴로지
- 하나의 서버가 메인이 되어서(마스터) 이 서버만 쓰기(write)를 한다. 즉 이 서버만 새로운 데이터를 받아드리는 것이다. 그 데이터를 다른 서버들한테 전파를 한다. 그래서 이 슬레이브라는 다른 서버들이 읽기 연산(Read)을 받아주는 것이다. 만약 이렇게 읽기와 쓰기를 구분하는 구조라면, 쓰기 연산보다는 보통 읽기 연산이 많다. 그래서 그 가정하에 구현된 구조라고 보면 된다. 
- 아니면, 이중화라는 개념으로 해서 슬레이브들이 대기를 하고 있는 것이다. 그래서 마스터가 뻗으면 다른 슬레이브가 마스터가 되는 것이다. 


### 샤딩
- 샤딩은 여러 마스터를 둘 수 있다. 대신 키값을 여러 서버에 분산해서 저장하는 것이다. 키를 문자열이라고 가정하면 A부터 G까지는 1번 마스터에 저장하고 / H부터 M까지는 2번 마스터에 저장 / N부터 Z까지는 3번 마스터에 저장하는 방식으로 우리가 서버에 접근할 때 만약, B라는 키를 가지고 접근하게 되면 -> 1번 마스터 서버에 접근하게 되서 -> 데이터를 조회하게 되는 것이다. 그래서 이런식으로 어떤 키나 pk나 이런 기준이 되는 값을 기준으로 해서 여러 서버에 분산해서 저장하는 것을 샤딩이라고 한다.


### 클러스터
- 클러스터는 마스터 서버가 여러개이지만, 어느 서버를 지정해서 요청하지 않아도 알아서 읽기와 쓰기가 보장되는 것을 의미한다. Redis에서는 샤딩의 개념을 응용해서 마스터에 처음 접근을 하게 되었을 때, 내가 접근한 이 마스터에서 '내가 가지고 있는 키가 아니야'라고 한다면, 다른 마스터 서버한테 redirection를 시켜주게 된다. 그래서 다른 마스터 서버에서 데이터를 조회하고 데이터를 꺼내갈 수 있게 하는 이런 형태가 된다. 
- 그래서 클러스터로 서버들을 묶게되면, 내부적으로는 약속을 하고 있다. 어떤 서버가 '나는 a부터 g까지 가지고 있을께' 이렇게 하고 다른 마스터 서버는 h부터 m, 다른 마스터 서버는 n부터 z 이렇게 약속을 내부적으로 하고 있다가 우리는 요청을 굳이 구분할 필요없이 알아서 클러스터에 보내버리면, 그 요청이 마스터에 접근했을 때 '내 키가 아니야' 할 경우에는 그 키를 가지고 있는 마스터한테 redirection 시켜주는 개념이다. 
- 클러스터의 구현 방식에 따라 조금씩 다를 수 있다. 어쨌든 이런식으로 클러스터를 구성하게 되면, 데이터의 접근과 수정이 보장되게 되는 것이다. 내부적으로는 키 기반으로 샤딩 비슷하게 되어있는 것이다. 다만, 이렇게 구현을 할 수 있게 되면 여러 서버들을 하나의 서버처럼 동작하게 하기 때문에 고가용성, 그러니까 HA를 지원한다고 볼 수 있다. Redis 클러스터는 3대 이상부터 가능하니까 참고하자.


## Redis 구축/연동하기
- AWS 관리 콘솔로 들어가서 EC2로 들어가서 서버를 직접 세팅해보자. 여기서 인스턴스 시작을 누르고 진행해보자.
  - 여기서 Ubuntu Server 20.04 LTS (HVM), SSD Volume Type를 선택
  - 원래는 Redis를 만들려면 메모리가 조금 높아야 되는데, 우리는 지금 테스트로 하나를 만들어보는 거니까 t2 micro로 하자. 스토리지도 늘릴 필요가 없다. 
  - 보안 그룹 메뉴에는 새로운 보안 그룹을 만들어서 보안그룹이름을 Redis-Group 이라는 것을 만든다. 그리고 인바운드 보안 그룹 규칙에서는 ssh유형은 내 IP로 하나 뚫어주면 내 컴퓨터에서만 접속이 가능하다. 그리고 외부에서 접속할 수 있게 하나 더 추가하고 포트 범위를 6379로 설정하고 소스 유형은 위치 무관으로 선택한다. 지금은 강의에서 설명하는 것이니까 Redis를 위치무관으로 모든 서버에서 접근이 가능하도록 오픈을 하게 되는데, 실제 Redis를 서비스에서 사용할 때는 이 Redis 자체가 보안을 신경써야 할 수 있다. 왜냐면 여기에 맘대로 접근할 수 있으면 세션을 변경할 수 있을 것이다. 그래서 "소스"를 정의할 때 가능하면 방화벽으로 접근 제어를 해줘야 한다. 그래서 접근해야되는 서버의 IP로만 설정을 하거나 혹은 나중에 우리가 IDC에서 직접 서버를 물리적인 서버를 가지고 구축을 한다고 할 경우에는 그 내부 네트워크를 통해서만 접근이 가능하도록 하는 게 기본적인 보안 방식이다. 우리는 지금 강의를 진행해야 하니 위치 무관을 선택하자.
  - 그리고 "새 키 페어 생성"을 클릭해서 키 페어 이름을 taling-lecture라고 해준다. 키 페어 유형은 RSA / 프라이빗 키 파일 형식은 .pem으로 해준다. 그러면 키가 다운로드 된다. 
  - 다 만든 다음, 헷갈리지 않게 인스턴스 이름을 TALING-REDIS라고 설정해준다.
  - 이렇게 방금 생성된 EC2 인스턴스에 직접 pem키를 이용해서 접속을 하면 된다.


### Ubuntu 접속 이후 Redis server 설치
```ubuntu
sudo apt-get update
```

- 일단 처음에는 위의 명령어로 ubuntu를 업데이트 해주자. ubuntu의 installer를 업데이트 해서 설치를 하기 위한 사전 준비를 한다. 
  - **sudo는 super do의 약자로, 최고관리자가 내리는 명령을 의미한다. root가 아닌 사용자가 최고관리자 권한을 빌리는 것으로 root에 준하는 능력으로 sudo 다음에 나오는 명령을 실행하게 하는 명령어이다.**

```ubuntu
sudo apt-get upgrade
```

- 이어서 해당 명령어를 입력해준다.
  - **Ubuntu에서 apt-get은 OS에 맞는 패키지를 install 해주는 툴이라고 보면 된다. 이걸 처음에 EC2를 생성하면 업데이트를 한 번 해줘야지 프로그램을 잘 설치할 수 있게 된다. 안 그러면 해당 인스턴스가 기본 OS set에 맞춰있기 때문에 필요한 install 파일들을 잘 가지고 오지 못하게 된다. 그래서 처음 EC2를 생성하면 이렇게 업데이트를 시켜줘야 한다.**

```ubuntu
sudo apt-get install redis-server
```

- **그 다음으로는 이렇게 redis 서버를 설치해준다.**

```ubuntu
redis-server --version

Redis server v=5.0.7 sha=00000000:0 malloc=jemalloc-5.2.1 bits=64 build=66bd629f924ac924
```

- **마지막으로 해당 명령어를 입력하면, redis가 설치되어서 버전이 표시가 된다.**

* * *
- **여기까지 설치가 완료되었고, 이제 메모리 설정을 봐야한다.**

```ubuntu
vmstat -s


991160 K total memory
       165452 K used memory
       305920 K active memory
       362268 K inactive memory
       178324 K free memory
        29740 K buffer memory
       617644 K swap cache
            0 K total swap
            0 K used swap
            0 K free swap
         6675 non-nice user cpu ticks
         2462 nice user cpu ticks
         4706 system cpu ticks
      7955726 idle cpu ticks
         1955 IO-wait cpu ticks
            0 IRQ cpu ticks
           72 softirq cpu ticks
         1036 stolen cpu ticks
       827940 pages paged in
      1253564 pages paged out
            0 pages swapped in
            0 pages swapped out
       836619 interrupts
      2314402 CPU context switches
   1652241074 boot time
        25139 forks
```

- 위의 명령어를 입력해주면, 사용가능한 메모리가 나온다. 우리의 메모리가 크지 않기 때문에 메모리 사이즈를 제한 할 필요가 있다. 

```ubuntu
sudo systemctl restart redis-server.service
```

- 일단 해당 명령어로 Redis 서버를 재시작해준다. 


```ubuntu
sudo vi /etc/redis/redis.conf 
```

- 그리고 해당 명령어로 redis.conf 라는 파일을 열어주면 설정 파일을 볼 수가 있다. 

- **Vim 편집기에서는 안에 내용을 수정하기 위해서는 i키를 눌러서 삽입 모드로 들어가야 한다.**

- 해당 파일에서 "MEMORY MANAGEMENT" 라는 부분이 있는데, 거기에 # maxmemory <bytes> 이렇게 주석처리가 되어있는 maxmemory 부분이 있다. 그래서 이 부분의 주석을 지우고 <bytes> 부분도 지운 다음에, 512 MB를 선언해주기 위해 
  
```vim
...
maxmemory 512mb
```

- 이렇게 수정해주면 된다. 그리고 조금 더 아래로 내려보면 maxmemory-policy noeviction 라는 부분이 있다. 여기도 주석을 지우고 noeviction이라는 부분을 allkeys-lru 이렇게 수정해주자.
  
```vim
maxmemory-policy allkeys-lru
```
  
- 이렇게 하면 Evict를 해준다는 의미이다. 원래는 Evict를 안 한다고 씌여져 있었던 것이었다. Evict를 한다고 한다면, 데이터가 계속 쌓을건데 근데 우리 용량은 제한이 되어있다. 그래서 이렇게 제한된 데이터를 가지고 저장을 할 때는 계속해서 옛날 데이터를 삭제해줘야 한다. 그래서 이 삭제를 어떤 순서로 할 것이냐를 정책을 정의하는 것이다. lru라는 것은 Least Recently Used의 줄임말이다. maxmemory-policy 부분 위쪽에 주석으로 되어있다. 그래서 최근 사용된 순서로 일단 살려두고 사용 안하는 얘들을 순차적으로 삭제한다는 뜻이다. 그래서 이렇게 policy를 정의해둔다. 
- **이렇게 수정하고나서 ESC를 누르고 일반 모드로 전환한 다음, :wq를 입력해서 파일을 저장하고 Vim를 종료시키면 된다.** 

```ubuntu
sudo systemctl restart redis-server.service
```
  
- 그리고 다시 위의 명령어를 입력해서 Redis 서버를 재시작해주면 된다. 
  
  
- **이렇게 해서 사용할 준비가 되었으나, 그 다음에 해야되는 게 하나 더 있다. 지금은 Redis가 외부에서 접근이 안되게 막혀있는데 그래서 한 번더 열어줘야 한다. 다시 redis.conf로 들어가기 위해
  
```ubuntu
sudo vi /etc/redis/redis.conf 
```
  
- 이렇게 입력해주고, NETWORK 라고 되어있는 주석들을 찾아보자. 거기에서 bind 127.0.0.1 ::1 이렇게 localhost에서만 접속가능한 형태로 되어있다. 그래서 이걸
  
```vim
bind 0.0.0.0
```
  
- **이렇게 바꿔주면 외부에서도 이 redis 서버에 접속할 수 있게 된다. 그리고 password도 설정을 해줘야 한다. SECURITY 라는 부분을 보면, requirepass foobared라는 것이 있다.** 그래서 해당 부분의 주석을 삭제하고 
  
```vim
requirepass passw0rd!**
```
  
- **이런식으로 패스워드를 passw0rd!** 이렇게 설정해줄 수 있다. 여기까지 수정한 다음 저장하고, 한 번더 redis server를 restart 해주면 된다.**
  
- 이 상태에서 우리가 접속이 되는지 체크를 해봐야 하는데, 
  
```ubuntu
sudo apt-get install redis-tools
```

- 해당 명령어를 입력해주면, redis와 관련된 툴이 설치가 된다. 그 다음으로는 
  
```ubuntu
redis-cli
  
127.0.0.1:6379> 
```
  
- redis-cli라는 것이 설치가 되어있을 것인데, 이걸 입력하면 127.0.0.1:6379> 이렇게 변하면서 접속이 된다. 이 상태에서 내가 어떤 오퍼레이션을 수행하려고 하면 인증이 실패했다고 나오니까 아까 전에 입력해두었던 비밀번호를 입력해주자.

  
```ubuntu
127.0.0.1:6379> AUTH passw0rd!**
  
OK
  
127.0.0.1:6379> KEYS *
(empty list or set)
```

- 그러면 OK가 뜨면서 오퍼레이션이 먹힌다. 
  

