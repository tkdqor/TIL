## 레디스와 레디스 세션
- 이번에는 서비스 확장에 대해 고민을 해보자. 우리가 서비스를 하나 배포한다고 가정해보자. 배포를 진행해서 하나의 컴퓨터에 django 서버가 실행되고 있는 것이다. 
- 처음에 몇명의 사용자가 작게 접속할 때는 문제가 없으나 사람이 계속 늘어난다면 -> 서버 1대의 한계치를 넘어서서 요청을 처리하지 못하고 튕겨내거나 밀리게 된다. 이럴 때 허용량을 늘리기 위해서 서버의 대수를 
  늘리는 것을 "스케일 아웃"이라고 한다. 또는 서버 1대의 스펙이 늘어나는 경우(CPU나 메모리값이 증가)를 "스케일 업"이라고 한다.

- **이렇게 서버의 대수가 늘어나는 스케일 아웃 상황일 때, 세션의 공유문제에 주목할 필요가 있다.**
  - 사용자가 하나의 서버에서 로그인을 했다면 세션이 서버 메모리에 기억이 된다. 하지만 스케일 아웃을 해서 서버가 여러 대 라고 하면 다른 서버로 접속하게 되었을 때는 그 서버는 사용자를 기억하지 못한다. 그래서 로그인 유지가 되지 않는다. 이 문제를 해결하는 방법은 크게 2가지가 있다.

- **세션 고정**
  - 하나는 세션이 만들어진 서버에 같은 요청을, 로그인이 된 사용자 요청을 계속해서 고정시키는 방법이다. 이건 중간에 라우팅을 해주는 무언가가 있어서 요청 HTTP 헤더에 세션 ID를 읽어서 특정 서버로 계속 보내주는 것이 가능할 수 있다. HTTP 헤더 정보로 서버를 고정시키는 것이다. 

- **세션 공유**
  - 두번째로는 공유하고 있는 어떤 메모리가 있어서 세션을 같은 곳에 저장하고 불러오는 방법이 있다. 이걸 위해 우리가 배운 MySQL과 같은 디스크에 저장되는 형태의 DB를 사용할수도 있지만, 세션 데이터는 기본적으로 영구적으로 저장되는 게 아니라, 영구적으로 저장될 필요가 없는 휘발성 데이터이다. 그리고 수시로 조회가 발생하기 때문에 빠른 속도, 잦은 요청을 처리해야 한다.
  - **컴퓨터의 구조 상, 데이터가 어떤 디스크에 저장되어 있는 것 보다는, 메모리에 저장되어 있는 게 속도가 더 빠르다.** 그래서 디스크보다는 메모리(램..)에 저장되어 있는 게 더 빠른데, 이 메모리 보다는 CPU에 달려있는 캐시 메모리라는 것이 있다. 
  - **그래서 Disk < Memory < Cache 메모리 순으로 빠르다. -> CPU에서의 거리에 따라 접근속도, 처리속도가 더 빠르지만, 용량이 비교적 더 작고 유지기한이 짧다는 단점이 있다. 그래서 일반적인 데이터베이스 보다는, 메모리에 저장하는 게 좋은데, 이 때 등장하는 게 바로 "메모리 데이터베이스"이다.**


## 레디스
- **메모리 데이터베이스 중에 대표적인 레디스에 대해서 알아보자. 이 레디스를 django에서 스케일 아웃에 대비하기 위해 세션을 저장하는 공유 메모리 저장소로 사용하려고 한다.**
- 레디스는 Remote Dictionary Server의 약자로 메모리 기반 데이터베이스를 의미한다. 그래서 키 - 밸류 형태의 자료구조를 가지고 메모리에 데이터를 저장하는 방식이다. **키 - 밸류 형태의 자료구조 라는 건, python의 딕셔너리를 생각하면 되는데, 우리가 배운 해시 테이블이 이런 딕셔너리 형태 자료구조의 원형격 개념이라고 보면 된다.** 
  - 그래서 해시 테이블과 유사하게 탐색속도가 O(1)이다. 데이터가 저장된 레코드의 개수와 상관없이 무조건 한 번에 해당 데이터에 바로 접근할 수 있어 효율적이고 빠르다는 장점이 있다. 대신에 범위 검색이 어렵다. 
  - 그래서 레디스는 범위 검색을 효율적으로 하기 위해 내부적으로 ZRANGE라는 정렬된 리스트를 구현하는 식으로 해결하는 방법이 있긴 있다. 하지만 레디스의 탄생 배경을 생각해보면, 키 - 밸류 형태의 데이터를 저장하는 데에 더 적합하다고 볼 수 있다. 이 구조를 이용해서 -> 세션을 저장하는 데 쓰거나, 서버의 캐시 데이터를 저장하는 데 쓰는 경우가 많다. 


### 레디스의 특징
- 싱글 쓰레드 : atomic하다(분산을 위해서 토폴로지, 샤딩, 클러스터 등의 개념으로도 확장해 나갈 수 있음). 
  - 우리가 데이터베이스에서 트랜잭션을 배울 때, atomic를 배웠는데 **어떤 데이터가 삽입되거나 삭제되거나 조회가 될 때 항상 단일 연산으로 수행된다는 것이다.** 그래서 트랜잭션이 잘 유지된다고 볼 수 있다. 
  - 보통 컴퓨터는 하나의 컴퓨터 내에서 여러 프로그램을 동시에 실행하는 게 가능하다. 그리고 그와 비슷하게 하나의 프로그램은 동시에 여러 작업들을 병렬적으로 실행할 수 있다. 컴퓨터 사이언스에서는 프로그램을 "프로세스", 작업을 "쓰레드"라는 실행단위로 묶어서 이야기를 한다. 
  - 그래서 싱글 쓰레드라는 것은, 하나의 프로그램에서 하나의 작업을 하게 된다. 즉 실행단위 내에서만 연산이 수행된다는 것을 의미한다. 레디스에서는 다른 서버에서 Read, Update 요청이 동시에 들어오더라도 메모리에 대한 작업은 정확하게 하나씩 순서대로 수행되게 된다. 즉, atomic 연산에 대해서 보장이 된다는 것이다. 
- O(1)의 탐색속도로 속도가 아주 빠르다. 
- 인메모리 I/O가 빠르다. 
  - 인메모리는 서버의 메모리 상에서 이 데이터들을 저장하고 조작하기 때문에 디스크에서 직접 처리하는 것 보다는 I/O가 훨씬 빠르다. 대신에 서버 장애 시, 우리가 디스크에 반영구적인 방식으로 저장한 게 아니라서, 램카드에 들어간 데이터들은 전부 날라가게 된다. 우리가 컴퓨터를 켰다가 그냥 전원을 내려버리면 -> 실행중인 파일이 다 날라가는 것 처럼, 서버 장애 시 데이터의 유실 발생이 가능하다. 
- 위의 문제를 보완하기 위해 Disk 저장 지원 
  - Snapshot : 특정 시점 데이터를 그대로 저장 / 현재 메모리상에 올라와있는 모든 데이터값들을 어떤 시점마다 그대로 사진 찍듯이 데이터를 직렬화해서 다른 데이터로 변환해서 파일로 떨궈주는 것이다. 그래서 특정 시점으로 데이터를 복구할 수 있게 된다.
  - AOF : 연산을 로깅(Binary Logging), 즉 연산을 하나씩 저장하는 방식이다. 
    - 예를 들어 레디스 DB안에 키 테이블에 키1이 하나 있다고 가정하고 여기에 데이터를 넣었다. 이게 첫번째 연산이 된다. 이 메모리 데이터베이스에 첫번째로 수행된 작업이다. 두번째 연산으로는 키3에 데이터를 넣었다. 그리고 세번째 연산으로는 키1에 있는 데이터값을 A로 변경했다. 이걸 실제로 로그로 남겨보면 -> 1 key1 = D / 2 key3 = D / 3 key1 = A -> 이렇게 해서 1,2,3 이라는 순서가 나왔고 이것들을 하나씩 로그로 남기는 것이다. 그래서 이 로그를 파일에 저장해두고 있는 것이다. 이걸 Binary Logging이라고 한다. 즉, 모든 연산을 순서대로 파일에 저장해서 가지고 있다가 나중에 복구할 때 이걸 처음부터 똑같이 실행하면 복구가 된다는 개념이다. 이 Binary Logging이라는 개념이 레디스에만 사용되는 건 아니고 MySQL이나 다른 DB에서 이걸 사용하고 있다. 데이터의 백업이나 복구를 위해서 말이다. 
    - 또한, 나중에 우리가 배울 클러스터링, 즉 DB에 데이터를 저장할 때 다른 DB, 복구용 DB에 내 DB에서 수행된 연산들을 전달해서 내가 가지고 있는 데이터를 똑같이 싱크를 맞출때도 이런 방식을 사용한다. 


## 레디스에 대해 오해하지 말아야 할 것
- **데이터연산이 수행되는 곳이 싱글 쓰레드인거지 레디스 전체가 싱글 쓰레드라는 게 아니다.**
  - 디스크에 스냅샷, AOF를 저장하는 쓰레드도 있고 버전 6부터는 외부 서버로부터 요청을 받고 응답을 돌려주는 부분을 멑티 쓰레드로 구현하고 있음. 
  - 이벤트 루프(OS 커널 단에서 kqueue, epoll, iocp 등을 사용)와 I/O 멀티플렉싱을 통해 동시에 들어오는 요청들의 동시성을 효율적으로 처리하되 각 연산은 싱글 쓰레드에서 발생해서 원자성을 보장
  - 즉, 멀티 쓰레드로 뭔가 외부적으로 데이터를 입력받고 그런것들이 있긴 하지만 결과적으로 연산을 처리하는 부분은 싱글 쓰레드로 되어있어서 atomic이 보장된다는 것이다. 




