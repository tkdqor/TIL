## 로드밸런싱과 SSL
- 서버의 스케일 아웃을 어떻게 처리할까. 많은 서버가 요청을 받을 때 HTTP 요청이 들어오게 되면, 어떻게 하나의 서버로 지정되어 포워딩 되는 걸까.
- 우리가 은행을 방문하는 걸 생각해보자. 그럼 보통 문에 번호표가 있다. 번호표를 뽑고 숫자를 확인하고 창고에서 해당 번호가 될 떄까지 기다렸다가 번호가 뜨면 은행업무를 보려가게 된다. 

- **트래픽의 분산도 이와 유사하다.**
  - **여기서 번호표를 제공하는 역할을 하는 것을 "로드 밸런서"라고 한다. HTTP 요청이 들어오면 웹 앱 서버로 트래픽을 분산해서 포워딩해주는 역할을 한다.** 그리고 이런 개념을 로드 밸런싱이라고 한다. 


### 로드 밸런서의 종류
- **L4: IP/Port**
  - 컴퓨터의 네트워크 레이어(Layer) 레벨을 따서 4번 계층인 Transport 레이어 단위에서 분산을 하면 L4

- **L7: URL/HTTP Header**
  - 7번 계층인 어플리케이션 레이어 단위에서 분산을 하면 L7이라고 한다.

- "네트워크" 부분에서 Transport Layer와 Application Layer를 공부해보자. 
   - L4는 우리가 어떤 호스트를 입력하고 들어왔을 때 들어온 IP별로 .... 일반적인 하드웨어 단에서의 로드 밸런서가 보통 여기에 속한다. 네트워크 Transport Layer단에서 패킷들이 데이터가 왔다갔다 한다. 그 때 Transport Layer단에서 인식할 수 있는 태그들이 있다. 그게 바로 하나가 IP이고 Port번호도 있다. 그래서 이러한 Port 번호들을 인식할 수 있으니까 이 Port 번호가 80번이면 어디로 보내고, 81번이면 여기로 보내고 이렇게 할 수 있다. 80번으로 보냈을 때 80번은 포워딩을 내부 클러스터에 8080으로 보낸다거나, 즉 도커처럼 80번으로 들어왔을 때 -> 8080포트로 보낸다거나 이런식의 포워딩을 해주는 것이 L4가 하는 역할이다.  
   - L7은 이 패킷 단위에서 더 쪼개가지고 이걸 해석한 뒤에 HTTP 메시지로 까보는 것이다. 여기에 보통 Header들이 들어있으니까, GET이나 POST나 이런것들도 담겨있고 path도 들어가 있을 것이다. /user 나 /search 등 이런 path들을 다 측정을 해서 이것에 따라서도 포워딩을 다르게 할 수 있는 것을 application Layer의 로드 밸런서라고 해서 L7이라고 부른다. 


### 로드 밸런서 알고리즘
- 그리고 분산 처리시의 어떤 서버의 요청을 포워딩하느냐에 따라서 알고리즘을 크게 3가지로 구분할 수 있다. 

- **라운드 로빈**
  - 만약, 3대의 서버 컴퓨터가 있다고 하면 요청이 들어올 때 이 컴퓨터를 순서대로 전달하는 알고리즘이다. 즉, 순차적으로 서버에 돌아가며 포워딩을 한다. 그래서 3대의 번호가 1/2/3이라면 계속 1/2/3/1/2/3/... 이러한 순서대로 포워딩을 하게 된다. 

- **웨이티드 라운드 로빈**
  - 이건 특정 서버에 가중치를 부여하여 배분되는 비중을 달리하는 방법이다. 그래서 보통 하나의 서버가 TPS(Transaction Per Second로 '초당 트랜잭션 수' 또는 '1초에 처리하는 단위 작업의 수'를 의미)가 많이 나와서, 처리량이 많아서 2번씩 보내게 된다. 그래서 1/2/3/3/1/2/3/3/... 이렇게 3번 서버에만 2번씩 보내게 된다. 

- **리스트 커넥션**
  - 최소 연결 수 서버에 우선적으로 포워딩하는 것을 의미한다. 서버 컴퓨터 1,2,3이 있고 요청이 1번에 5개, 2번에 4개, 3번에 1개 이렇게 보내지고 있다면 3번 서버가 제일 적기 때문에 -> 3번에 우선적으로 배분해서 요청을 보내는 것이다. 이런식으로 커넥션을 체크해서 보내는 방식이다. 보통은 이 커넥션 타임이 길지 않은 웬만한 서버들의 경우에는 라운드 로빈으로 처리를 한다. 



### AWS 로드 밸런서 
- 로드 밸런서를 실제로 실습하기 위해 AWS 로드 밸런서를 사용해서 구현을 할 것이다. 여기 AWS 로드 밸런서에서는 도메인을 연결하고 SSL 인증서라는 것을 연결하면 사용자가 HTTPS로 접속할 수 있도록 하는 게 가능하다.


### SSL(Secure Sockets Layer) 인증서
- SSL 인증서를 알기 위해서는 먼저 다음의 내용을 알고 있어야 한다.

- **공개키/개인키 암호화**
  - RSA 알고리즘이 유명하며 개인키로 암호화하면 공개키로만 복호화가 가능한 특징이 있다. 
  - ex) 우리가 편지를 보낸다고 생각해보자. 그래서 공개키, 공개열쇠를 봉투에 같이 넣어서 수신자한테 보냈다. 수신자가 메세지를 받았고 그 내용을 공개키로 까보는 것이다.(공개키를 제3자가 들고 있다.) 그러면 복호화가 잘 되어서 의미있는 문장이 되었다. 사실 내가 편지를 작성할 때 개인키가 있고 암호표가 있다. 그래서 이 암호표를 가지고 내가 메세지를 작성해서 개인키로 암호화를 하는 것이다. 이렇게 공개키로 복호화가 가능하려면 숨겨진 개인키로 암호화를 해야지만 가능하다는 특징이 있다. 이런식으로 만들어진 게 바로 RSA 알고리즘이다. 즉, 특정 키로는 암호화만 되고 특정 키로는 복호화만 되는 특징을 이용한 것이다.


- **CA(인증기관)**
  - 인증서를 발급하는 기관으로 암복호화를 위한 공개키와 개인키도 발급한다. 그래서 위에서 언급한 제3자가 바로 CA이다. 
  - CA가 있고, 서버와 클라이언트가 있다고 생각해보자. 그래서 서버가 CA한테 인증서를 발급해달라고 한다. 그러면 CA가 인증서를 발급해주면서 서버한테 개인키를 몰래 준다. 그리고 CA는 공개키를 진열대에 올려둔다. 그래서 누구나 가지고 갈 수 있게 한다. 그래서 클라이언트가 와서 해당 공개키를 가져갈 수 있는 것이다. 그 클라이언트가 서버와 통신을 할 때 -> 서버의 개인키로 암호화된 메세지를 클라이언트가 받아서 공개키로 복호화를 해서 내용을 확인할 수 있는 것이다. 
  - **이렇게 하면 통신할 때 암호화가 유지된다. 만약 중간에 다른 해커가 있어서 네트워크를 해킹해서 클라이언트가 접속을 해커랑 할 수도 있다. 이게 바로 "피싱"이라는 것이다.** 예를 들어서 나는 분명히 특정 은행 사이트에 접속했는데 이상하게 해커 사이트로 가게 된다. 근데 화면은 똑같이 생겼다. 그래서 비밀번호를 입력하게 만들어버렸다. **이 때 보면 -> url에 https가 아닐 것이다. 아마 s가 안 붙어있을 것이다.** 왜냐면 이 https를 정확하게 구현해서 메세지를 보낼 수 있는 주체는 올바른 서버밖에 없다. 해당 서버만 메세지를 나만의 숨겨진 키로 암호화해서 보낼 수가 있는데, 중간에 해커가 가로채고 있으면 얘는 이걸 개인키가 없으니까 흉내낼 수 없다. 
  - **그래서 보통 피싱 사이트인지 아닌지 보고 싶으면 -> url에 https가 뜨는지 안 뜨는지 확인하면 된다.** 이런 걸 지원해주는 것이 바로 https와 SSL 인증서이다.


- **TLS**
  - SSL 3.0 버전부터는 TLS라는 명칭을 사용한다. 


### SSL 연결 수립(바탕화면 참고)
- 클라이언트와 서버가 연결 수립을 하는 과정이다.
- 처음에는 TCP로 "3 way 핸드쉐이크"라는 걸 한다.(둘이 악수를 한다는 의미) 클라이언트와 서버가 서로 연결을 수립하기 전에 연결의 패킷을 맞춰보는 작업을 하는 것이다. 
- 이렇게 해서 연결이 수립이 되면, 그 다음에는 TLS로 say hello해서 인증서를 체크하고 인증서에서 인증서 교환을 하고, 키를 교환하고 암호화 스펙을 공유한다. 
- (검정색 부분)그리고는 데이터를 그 다음부터는 암호화해서 왔다갔다 하는 로직을 타게 된다. 
  - **여기서 중요한 건, TLS까지 오면서 발전이 되긴 했다. 위에서 우리가 공개키로 까보고 체크한다고 했는데, 이제는 여기에 더해서 중간에 암호화 키를 교환하기도 한다. 중간에(TLS에서) 암호화 키를 생성한다. 그리고 우리가(서버가) 메세지를 보낼 때 이 암호화 키 자체를 한번 더 서버의 개인키로 암호화를 하는 것이다. 그래서 이걸 클라이언트한테 보내서 클라이언트가 이걸 까본다. 여기서 암호화 키를 꺼낼 수 있고 이 키를 가지고 서로 통신하는 것이다. 그러면 다시 RSA 방식으로 클라이언트는 본인의 암호화 키로(?) 암호화를 해서 다시 서버에 전송하는 것이다.**
  - 이런식으로 서버와 클라이언트 둘이 소통을 할 수 있는 서로의 암호화 키를 교환하게 된다. 매 연결마다 교환하게 된다. 이 암호화 키를 이용해서 서로의 일반적인 메세지들도 전부 다 암호화를 해서 종단 간 암호화를 완성시키는 것도 포함이 된다. 
  - 이렇게 TLS나 SSL 방식들은 공개키나 개인키 암호화를 사용해서 이런 인증서를 유효성 체크를 하고 그 키를 이용해서 서로의 이번 연결에 사용할 암호화 키를 교환 한 다음에 그 키를 이용해서 서로의 메세지를 해석하면서 데이터를 교류한다고 보면 된다.



### 아키텍처
- 지금까지 우리가 TCP 커넥션을 맺는 과정에서 SSL 통신을 수립하는 과정까지 확인을 해봤다. AWS도 CA역할이 가능하기 때문에 도메인 연결을 해보면서 AWS Certificate manager를 사용해서 실제 인증서 발급을 진행해보고 로드 밸런서를 세팅해보자.
- 우리가 설계할 아키텍처는 다음과 같다.(바탕화면 참고)
  - **여기에 보면 S3라는 것이 추가되었는데, 우리가 멀티 인스턴스 환경에서는 기존의 업로드 파일을 로컬에 저장하는 식은 파일의 n분의 1 확률로만 접근에 성공하게 된다. 그래서 중앙에 저장해둘 저장소가 필요하게 된 것이다.**  
  - 예를 들면, 첫번째 EC2 서버에서 오리 사진을 하나 올렸는데, 나중에 다른 요청이 들어와서 오리 사진을 조회해보니까 3번째 EC2 서버에는 없다. 오리 사진은 그냥 첫번째 서버의 파일로 안에만 생긴 것이기 때문이다. 이걸 방지하기 위해 멀티 인스턴스 환경에서는 오리 사진을 S3라는 공유 저장소에 올려두고 모든 EC2 서버가 접근할 수 있게 만드는 것이다. 


### S3 파일 업로드 진행하기
- S3 라는 것 자체가 AWS에서 제공하는 클라우드 스토리지 서비스이다. 그래서 이걸 사용하면 멀티 인스턴스 환경에서 중앙 저장소 역할을 할 무언가를 만들게 되는 것이다. AWS를 안 쓰는 경우도 있다. 그래도 중앙에 어떤 공유 스토리지 서버를 지금처럼 사용하게 되니까 개념은 거의 비슷하다. 

1) 먼저 AWS에서 S3라고 입력하기 - 그리고 "버킷 만들기" 클릭
2) 버킷 이름은 "taling-bucket" / AWS 리전은 "아시아 태평양(서울) ap-northeast-2" 선택, 객체 소유권은 "ACL 활성화됨"을 선택, 그리고 "모든 퍼블릭 엑세스 차단"에 체크를 해제해준다. 이렇게 해서 버킷 만들기를 눌러주면 된다. 그러면 이 버킷 단위로 스토리지가 저장된다. 
3) 그래서 Amazon S3 - 버킷을 누르면 상세화면이 나온다. 
4) 그 다음은 AWS에서 IAM을 입력하고 클릭한다. 그래서 접근 토큰과 시크릿 키를 얻어와야 한다. IAM 메뉴에서 "사용자"를 클릭하고 사용자를 추가해준다. 사용자 이름은 "taling-user"라고 만들고 AWS 엑세스 유형 선택은 "엑세스 키 - 프로그래밍 방식 엑세스"를 선택해준다. / 권한 설정에서는 기존 정책 직접 연결을 클릭해서 "SES"라고 검색하기. 그래서 AmazonSESFullAccess를 체크, 그리고 "S3" 라고 검색해서 AmazonS3FullAccess 체크하고 넘어가기.
5) 마지막 "검토"화면에서 권한 요약에 2개가 추가된 것을 확인할 수 있다. 그러면 이제 사용자 추가가 완료되었고 .csv 파일을 다운로드 해서 보관한다. 
6) 이제 우리 코드 화면인 VSCode로 돌아와서 모듈 2개를 설치해야 한다. (ls했을 때 requirements.txt가 보이는 위치일듯하다)

```terminal
pip install boto3
```

- 이건 S3에 접근하기 위한 클라이언트 역할을 해주는 것이다.

```terminal
pip install django-storages
```

7) 이렇게 2개를 설치해준다. 이제 우리가 업로드 파일만 할 게 아니고, static 파일들도 공유 저장소에 올려놔야지, 로컬에서 쓰이는 파일로 끝나는 게 아니라 공유 저장소에서 서빙되서 멀티 인스턴스 상황에서 파일이 흩어지는 그런 상황이 안 나타나게 된다. 그래서 static 파일들도 S3에 올려주도록 하자.
8) settings.py를 열어서 static url를 설정했던 부분 위쪽에 

```python
AWS_ACCESS_KEY_ID = '....'
AWS_SECRET_ACCESS_KEY = '....'
AWS_SES_REGION_NAME = 'ap-northeast-2'

STATIC_URL = 'static/'
STATICFILES_DIRS = [
    BASE_DIR / 'static',
]
```

- 이렇게 이메일 전송 시 입력했던 부분들을 가져와준다.

9) 여기서 AWS_ACCESS_KEY_ID는 아까 사용자 추가 화면에 있었던 "엑세스 키 ID"를 의미한다. 그래서 복사해서 붙여넣어주고, AWS_SECRET_ACCESS_KEY도 사용자 추가 화면의 "비밀 엑세스 키"를 의미하니까 복사해서 붙여 넣어준다. 그리고 INSTALLED_APPS에 'storages'를 추가해준다. 그리고 다시 static 쪽으로 와서 

```python
AWS_ACCESS_KEY_ID = '....'
AWS_SECRET_ACCESS_KEY = '....'
AWS_SES_REGION_NAME = 'ap-northeast-2'

AWS_STORAGE_BUCKET_NAME = 'taling-bucket'
AWS_S3_CUSTOM_DOMAIN = '%s.s3.amazonaws.com' % AWS_STORAGE_BUCKET_NAME
AWS_S3_OBJECT_PARAMETERS = {
    'CacheControl': 'max-age=86400'
}
AWS_DEFAULT_ACL = 'public-read'
STATICFILES_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'

STATIC_URL = 'https://%s/static/' % AWS_S3_CUSTOM_DOMAIN
STATICFILES_DIRS = [
    BASE_DIR / 'static',
]
```

- 이렇게 AWS_STORAGE_BUCKET_NAME = 'taling-bucket' 버킷의 이름을 넣어준다. 그리고 AWS_S3_CUSTOM_DOMAIN = '%s.s3.amazonaws.com' % AWS_STORAGE_BUCKET_NAME 이렇게 도메인을 합쳐준다. 그 다음에 AWS_S3_OBJECT_PARAMETERS로 브라우저에 파일이 내려갈 때 CacheControl를 지정해주게 되어있어서 이걸 86400초로 지정해서 캐시값도 미리 정의를 한다. 우리가 여길 통해서 업로드를 할 때 브라우저 캐시는 얼마나 먹여야 하는지를 여기서 정의하는 것이다. 한 번 브라우저가 S3에서 파일을 다운로드 받으면, 86400초 만큼은 기존 파일을 재사용하게 된다. 
- AWS_DEFAULT_ACL = 'public-read' -> 이건 내가 파일을 새롭게 올릴 때 모든 사람이 read 권한을 가지도록, 전 세계에 이 파일을 서빙할 수 있도록 조취를 해주는 것이다.
- STATICFILES_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage' => STATICFILES_STORAGE의 모듈로 해당 모듈을 사용한다는 의미이다. 우리가 django 스토리지를 깔고 거기에 백엔드로 제공되는 모듈이다. 그래서 s3boto3 패키지 안에 있는 S3Boto3Storage이라는 모듈을 참조하게 되면, 여기를 통해서 업로드가 이루어지게 된다. 더 궁금하면 이 코드를 command로 들어가보자.
- STATIC_URL = 'https://%s/static/' % AWS_S3_CUSTOM_DOMAIN -> 이렇게 수정해주기. 그러면 STATIC_URL의 접근할 때 full 호스트 네임은 -> https://taling-bucket.s3.amazonaws.com/static/sjdkfls.png 이런식으로 마지막에는 파일명이 들어가게 될 것이다. 나중에 CDN를 붙이면 이걸 수정해야 된다. 
- STATICFILES_DIRS은 -> 기존의 루트 디렉터리 하위에 static 폴더를 위치시킨다는 의미이니까 그대로 두어도 된다. 

10) 그 다음에는 터미널에 해당 명령어를 입력해서 requirements.txt를 갱신해준다. 

```terminal
pip freeze > requirements.txt
```

11) 그 다음에 실제 table_bookings 프로젝트 디렉터리로 들어가서(ls하면 manage.py가 보이는 위치)

```terminal
python manage.py collectstatic
```

- **다음과 같은 명령어를 입력한다. 그리고 yes를 입력한다. 그러면 100개가 넘는 static 파일이 업로드가 되었다고 뜨게 된다.**

12) 실제로 우리가 AWS의 S3를 들어가서 우리가 만든 버킷을 클릭하면 -> "객체"라는 부분에 static 파일들이 올라간 모습을 확인할 수 있다. 하나 파일을 클릭해서 보면 "객체 URL" 이라는 것이 나와있고 이걸 클릭해보면 코드가 뜨는 것까지 볼 수 있다. 

13) **실제로 python manage.py runserver로 실행을 해서 브라우저를 보자. 개발자 도구를 열어서 "네트워크"를 클릭해서 새로고침 해보면, "전체" 부분에 styles.css를 보면 오른쪽 헤더에 "요청 URL" 이라고 되어있는 부분이 우리가 저장한 S3의 저장소로 요청이 가는 것을 확인해볼 수 있다.**

14) 이제 업로드 media 수정을 해보자. table_bookings 루트 디렉터리(settings.py가 있는 디렉터리)안에 config.py라는 파일을 만들자. 여기에 우리가 media 업로드를 처리하기 위한 설정을 저장하고 있는 모듈을 만들 것이다. 

```python
from storages.backends.s3boto3 import S3Boto3Storage

class MediaStorage(S3Boto3Storage):
    location = 'media'
    file_overwrite = False
```

- 일단 S3Boto3Storage은 static 파일을 업로드 하는 모듈이었다. 
- 그리고 그 모듈을 상속받아서 MediaStorage라는 클래스를 정의해준다. location = 'media' 이렇게 해서 우리의 업로드된 파일들이 media라는 폴더에 저장이 되도록 한다. 그리고 file_overwrite = False라는 속성을 주면 파일들이 오버라이트 되지 않게 한다. 업로드할 때 똑같은 파일이 있으면 overwirte가 되지 않는다. 
- 여기까지 하고 저장하고 다시 settings.py로 돌아간다.

15) settings.py - MEDIA에 대한 설정을 바꿔줘야 한다. 기존의 

```terminal
# MEDIA_URL = '/media/'
# MEDIA_ROOT = 'media'

DEFAULT_FILE_STORAGE = 'table_bookings.config.MediaStorage'
```

- 해당 코드는 필요가 없을 것 같고, DEFAULT_FILE_STORAGE = 'table_bookings.config.MediaStorage' 이렇게 해서 우리가 위에서 새롭게 만들어준 그 클래스를 가져다 쓰기 위해 입력해준다. 그러면 업로드할 때는 우리가 작성한 MediaStorage라는 클래스의 설정값에 따라서 업로드가 될텐데, 우리가 추가로 작성한 설정은 location과 file_overwrite 설정이다. 

16) 우리가 생각해보면, 사진을 띄워주는 부분들이 있다. web앱의 templates - restaurant - detail.html에도 있을 것이다. 아니면 office 앱의 templates - restaurant - list.html을 보면 있을 수도 있다. 즉, img 태그에서 src 속성을 django template language로 하는 게 아니라 '/media/..' 이런식으로 되어있는 부분이 있다면 수정해야 한다는 것이다. 

17) 여기까지 한 다음, 서버를 껐다가 다시 켜보고 localhost:8000/office/로 가서 운영자 권한이 있는 계정으로 들어가면, "식당"이라는 메뉴가 뜰 것이다. 식당을 클릭해서 "추가하기"를 클릭해서 작성하면 이미지가 제대로 뜬다. 이걸 개발자 도구를 켜서 사진을 클릭해보면 -> src 속성이 AWS 버킷 주소로 잘 들어가 있다. 

18) 그리고 AWS S3로 가서 버킷을 클릭해보면 -> media라는 폴더가 생겨있고 이 안에 방금 업로드 한 이미지가 뜨게 된다. 


34:57




