## 오류 핸들링과 디버깅

### 프로그래밍에서의 익셉션
- 실행 흐름 상 오류가 발생하면 별도의 코드 흐름을 구현할 수 있게 해주는 것. 이러한 익셉션, 예외를 처리하는 것을 Exception Handing 또는 Trouble Shooting 이라고 한다. 
  - 잘못된 메모리 접근 / 불가능한 연산(divide by zero) / 자료형 불일치(int형 자료를 받아야 하는데 str로 들어와서 문제가 됨) / 하드웨어 손상 / 운영체제 손상 / 없는 파일 접근 
  - 이런것들이 코드 상에서 예상할 수 없는 것들이 된다. 내가 아무리 코드를 잘 짜도 그 코드가 다른 외부의 하드웨어나 소통들이 일어나는 건데, 이 때 예상하지 못했던 상황들이 발생한다. 
  - 그래서 이럴 땐 익셉션 처리를 해서 -> 익셉션이 발생하면 우리가 그걸 대응할 수 있도록, 우리의 코드 흐름에 외적으로 다른 흐름을 만들어서 내 코드에 실행환경에서 오류가 발생했을 때를 대응할 수 있도록 해주는 것


### Django에서 추가로 정의하는 익셉션
- 위의 내용은 컴퓨터 공용적인 느낌으로 정의
- django에서는 django에 맞게 특정지어서 이 프레임워크에서 익셉션을 따로 정의해서 발생시켜주고 있다. django 프레임워크를 개발하는 사람들이 이런 익셉션들을 추가로 만들어서 문제가 생길 때 익셉션을 발생시키고 우리가 그것에 대해 대응할 수 있도록 배려를 해준다. 
  - ObjectDoesNotExist : 어떤 데이터를 우리가 데이터베이스에서 조회를 했으나 이 조건을 만족하는 데이터가 없을 때 발생 
  - PermissionDenied : 어떤 권한밖의 일을 했을 때, 어떤 View에 사용자가 접근했는데 permission이 없는 경우 발생
  - FieldError : 필드가 잘못되었을 때 발생
  - BadRequest : 우리가 int로 받기로 약속한 어떤 pass variable에서 그게 문자열로 들어온다던가 하는 경우, 어떤 데이터를 받기로 했는데 잘못된 형식으로 오는 경우 발생(클라이언트와 소통의 문제)
  - ValidationError : 이것도 클라이언트와 소통의 문제 / 클라이언트에서 validation이 조금 안 맞는, 비밀번호가 10자리 이상이어야 하는데 2자리만 온다던가 하는 경우 발생

- 이러한 것들은 내 코드만으로는 해결되지 않는 문제들이다. 데이터가 들어오고 나가거나, 외부적인 객체를 호출하거나 이럴 경우에 발생.
- 그 외에도 https://docs.djangoproject.com/en/4.0/ref/exceptions/ 여기에 다양하게 존재.


### 스택스테이스 (stack trace)
- 우리가 django를 쓰다보면 오류가 나면 브라우저에 페이지가 뜬다. 노란색 바탕에 줄이 엄청 많이 출력된다. 맨 밑으로 스크롤을 내려보면 몇번째 라인 이렇게 표시가 된다.
  - 이렇게 리스트같은 형태의 문자열들이 스택스테이스라고 한다. 
  - 소스코드의 실행 위치를 나타내는 하나의 방법으로, 오류가 발생할 때 해당 코드 실행 전까지 호출된 함수들의 호출 순서 리스트를 출력하는 것이다. 모든 프로그래밍 디버깅 상황에서 스택트레이스를 펼쳐보고 내가 오류가 발생했을 때 이걸 통해서 내 오류가 어디서 발생했는지 내가 참고할 수 있다. 


### 익셉션 발생시키기
- ObjectDoesNotExists 발생시키기 / try-except 구문 구현하기
- 먼저, users.py를 열어서 오류를 발생시켜보자.

```python
from django.core.exceptions import ObjectDoesNotExist
from django.http import Http404
...

class ProfileView(LoginRequiredMixin ,UpdateView):
    form_class = ProfileForm
    template_name = 'users/profile.html'
    success_url = reverse_lazy('profile')
    login_url = reverse_lazy('login')

    def get_object(self, queryset=None):
        return UserProfile.objects.get(user=self.request.user)

    def get_context_data(self, **kwargs):
        context = super().get_context_data()
        social_account = SocialAccount.objects.filter(user=self.request.user).first()
        context['is_social_login'] = social_account is not None
        return context

```

- **먼저 ObjectDoesNotExist와 Http404를 가져와준다.**
- **그리고 ProfileView를 보자.** 
  - 지금은 우리가 로그인된 사용자로 직접 접근을 해서 UserProfile를 받아오고 있었다. 여기서 일부로 없는 프로필에 접근해서 익셉션을 발생시켜 보자. 
