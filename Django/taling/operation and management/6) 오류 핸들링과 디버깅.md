## 오류 핸들링과 디버깅

### 프로그래밍에서의 익셉션
- 실행 흐름 상 오류가 발생하면 별도의 코드 흐름을 구현할 수 있게 해주는 것. 이러한 익셉션, 예외를 처리하는 것을 Exception Handing 또는 Trouble Shooting 이라고 한다. 
  - 잘못된 메모리 접근 / 불가능한 연산(divide by zero) / 자료형 불일치(int형 자료를 받아야 하는데 str로 들어와서 문제가 됨) / 하드웨어 손상 / 운영체제 손상 / 없는 파일 접근 
  - 이런것들이 코드 상에서 예상할 수 없는 것들이 된다. 내가 아무리 코드를 잘 짜도 그 코드가 다른 외부의 하드웨어나 소통들이 일어나는 건데, 이 때 예상하지 못했던 상황들이 발생한다. 
  - 그래서 이럴 땐 익셉션 처리를 해서 -> 익셉션이 발생하면 우리가 그걸 대응할 수 있도록, 우리의 코드 흐름에 외적으로 다른 흐름을 만들어서 내 코드에 실행환경에서 오류가 발생했을 때를 대응할 수 있도록 해주는 것


### Django에서 추가로 정의하는 익셉션
- 위의 내용은 컴퓨터 공용적인 느낌으로 정의
- django에서는 django에 맞게 특정지어서 이 프레임워크에서 익셉션을 따로 정의해서 발생시켜주고 있다. django 프레임워크를 개발하는 사람들이 이런 익셉션들을 추가로 만들어서 문제가 생길 때 익셉션을 발생시키고 우리가 그것에 대해 대응할 수 있도록 배려를 해준다. 
  - ObjectDoesNotExist : 어떤 데이터를 우리가 데이터베이스에서 조회를 했으나 이 조건을 만족하는 데이터가 없을 때 발생 
  - PermissionDenied : 어떤 권한밖의 일을 했을 때, 어떤 View에 사용자가 접근했는데 permission이 없는 경우 발생
  - FieldError : 필드가 잘못되었을 때 발생
  - BadRequest : 우리가 int로 받기로 약속한 어떤 pass variable에서 그게 문자열로 들어온다던가 하는 경우, 어떤 데이터를 받기로 했는데 잘못된 형식으로 오는 경우 발생(클라이언트와 소통의 문제)
  - ValidationError : 이것도 클라이언트와 소통의 문제 / 클라이언트에서 validation이 조금 안 맞는, 비밀번호가 10자리 이상이어야 하는데 2자리만 온다던가 하는 경우 발생

- 이러한 것들은 내 코드만으로는 해결되지 않는 문제들이다. 데이터가 들어오고 나가거나, 외부적인 객체를 호출하거나 이럴 경우에 발생.
- 그 외에도 https://docs.djangoproject.com/en/4.0/ref/exceptions/ 여기에 다양하게 존재.


### 스택스테이스 (stack trace)
- 우리가 django를 쓰다보면 오류가 나면 브라우저에 페이지가 뜬다. 노란색 바탕에 줄이 엄청 많이 출력된다. 맨 밑으로 스크롤을 내려보면 몇번째 라인 이렇게 표시가 된다.
  - 이렇게 리스트같은 형태의 문자열들이 스택스테이스라고 한다. 
  - 소스코드의 실행 위치를 나타내는 하나의 방법으로, 오류가 발생할 때 해당 코드 실행 전까지 호출된 함수들의 호출 순서 리스트를 출력하는 것이다. 모든 프로그래밍 디버깅 상황에서 스택트레이스를 펼쳐보고 내가 오류가 발생했을 때 이걸 통해서 내 오류가 어디서 발생했는지 내가 참고할 수 있다. 


### 익셉션 발생시키기
- ObjectDoesNotExists 발생시키기 / try-except 구문 구현하기
- 먼저, users.py를 열어서 오류를 발생시켜보자.

```python
from django.core.exceptions import ObjectDoesNotExist
from django.http import Http404
...

class ProfileView(LoginRequiredMixin ,UpdateView):
    form_class = ProfileForm
    template_name = 'users/profile.html'
    success_url = reverse_lazy('profile')
    login_url = reverse_lazy('login')

    def get_object(self, queryset=None):
        UserProfile.objects.get(pk=200)

        return UserProfile.objects.get(user=self.request.user)

    def get_context_data(self, **kwargs):
        context = super().get_context_data()
        social_account = SocialAccount.objects.filter(user=self.request.user).first()
        context['is_social_login'] = social_account is not None
        return context

```

- **먼저 ObjectDoesNotExist와 Http404를 가져와준다.**
- **그리고 ProfileView를 보자.** 
  - 지금은 우리가 로그인된 사용자로 직접 접근을 해서 UserProfile를 받아오고 있었다. 여기서 일부로 없는 프로필에 접근해서 익셉션을 발생시켜 보자. 
  - get_object 메소드에 UserProfile.objects.get(pk=200) 라는 코드를 넣어주면 로그인/회원가입을 200번 이상해야 가져올 수 있다. 
  - 이렇게해서 서버를 구동시키고 로그인을 해서 "정보 수정" 메뉴를 클릭하면 오류가 나게 된다. 

<img width="813" alt="image" src="https://user-images.githubusercontent.com/95380638/168500914-766ab5c0-ce9f-4456-9477-b75d46546101.png">

- 이렇게 DoesNotExist 익셉션이 발생하고 그 밑에 Traceback 이라는 게 뜬다. 
  - django에서는 현재 익셉션이 발생했을 때 익셉션의 프로필을 잘 보여주는 편이다. 메세지가 뜨고 노란 바탕에 여러 개가 뜬다. Traceback은 스택스테이스라고 보면 된다. 이걸 보면,
  - 처음에 response = get_response(request) --> 이것을 장고 쪽에서 마지막으로 했다고 되어있다. 
  - **Traceback 맨 위에가 가장 마지막을 의미한다. 그래서 맨 뒤로 가서 역으로 따라가야 한다.** 
  - 근데 response = get_response(request) 를 먼저 호출했다..? 그 안에서 wrapped_callback를 호출을 했고, self.dispatch를 호출하고, super().dispatch를 호출하고 이렇게 계속 나온다. 
  - 이러한 것들은 다 우리가 구현한 건 아니고, django에서 구현된 내용들이 쭉 나열되다가 --> 갑자기 우리가 짠 코드를 만나게 된다.(진한 회색) -> 그 전에 self.get_object() 까지는 왔었다. 그게 ProfileView의 def get_object(self, queryset=None):이다. 그래서 이 코드가 수행되다 보니까 우리가 작성한 UserProfile.objects.get(pk=200) 이 코드를 만나게 된 것이다. 
  - 당연히 이 코드가 문제가 되서 이 때 익셉션이 발생하게 된다. 그래서 마지막에는 self.model.DoesNotExist가 raise 되었다는 것 까지 보여준다. 
  - 그리고 Local vars를 클릭해보면 -> 여기서 선언된 변수들이 지금 현재 어떤 상태였는지 보여주고 있다. 
  - 이렇게 해서 찾아갈 수 있다.

- **이제 다시 코드를 수정해보자.** 이런 경우를 예외처리 하는 것이다.

```python
...

class ProfileView(LoginRequiredMixin ,UpdateView):
    form_class = ProfileForm
    template_name = 'users/profile.html'
    success_url = reverse_lazy('profile')
    login_url = reverse_lazy('login')

    def get_object(self, queryset=None):
        # 예외처리 진행
        try:
            UserProfile.objects.get(pk=200)
        except:
            raise Http404

        return UserProfile.objects.get(user=self.request.user)

    def get_context_data(self, **kwargs):
        context = super().get_context_data()
        social_account = SocialAccount.objects.filter(user=self.request.user).first()
        context['is_social_login'] = social_account is not None
        return context
```

- **사용자에 input에 따라서, 해커일 수도 있고, 이상한 값이 들어올 수 있다. 이건 모든 소프트웨어에서 발생할 수 있는 문제이다. 그래서 이런 걸 얼마나 잘 대처하는지가 소프트웨어의 품질을 결정한다.**
- 그래서 try로 오류 코드를 넣어주고 except에 django에서 핸들링을 정상적으로 하는 Http404라는 익셉션을 발생시켜서 클라이언트한테 이 데이터가 없다는 메세지를 404라는 status code로 내려주는 것이다. 
- **이렇게 수정한 다음, 브라우저를 보면 Page not found (404) 라고 바뀌게 된다.**


- **그런데, 아까처럼 Traceback이 뜨면 --> 코드가 전부 다 노출이 된다.**
  - **그래서 실제로 우리가 지금은 디버깅중이니까, 테스트니까 이런 페이지가 대놓고 떠도 상관이 없지만 / 만약에 실제 서비스에서 이렇게 보여진다면 문제가 있다.** 
  - **그래서 settings.py에 가보면 DEBUG = True 라는 코드가 있다. 그래서 이걸 False라고 바꿔주고 / ALLOWED_HOSTS를 ['*'] 이렇게 별표로 채워주면 django 서버에 접속할 수 있는 호스트들을 모든 클라이언트에 대해서, 모든 IP에 대해서 열어주는 형태가 된다.**
  - 이렇게 하면, 브라우저에서 오류가 발생할 때 --> Not Found라고만 뜨지 오류 코드들이 뜨지 않게 된다. 그래서 보안 관점에서는 DEBUG를 False로 해주는 게 맞다. 

- 그리고 우리가 지금까지 실험한 ProfileView의 코드를 원래대로 복구시키자. 

```python
class ProfileView(LoginRequiredMixin ,UpdateView):
    form_class = ProfileForm
    template_name = 'users/profile.html'
    success_url = reverse_lazy('profile')
    login_url = reverse_lazy('login')

    def get_object(self, queryset=None):
        # 예외처리 진행
        # try:
        #     UserProfile.objects.get(pk=200)
        # except:
        #     raise Http404

        return UserProfile.objects.get(user=self.request.user)

    def get_context_data(self, **kwargs):
        context = super().get_context_data()
        social_account = SocialAccount.objects.filter(user=self.request.user).first()
        context['is_social_login'] = social_account is not None
        return context
```

* * *
### django의 익셉션 핸들링
- django에서는 아까전에 봤던 오류 페이지를 어떻게 띄우는 걸까. 

