## 배포

## CI/CD


### CI
- Continuous Integration의 약자로 "지속적인 통합"이라는 뜻이다. 즉, 우리가 소스코드를 작성한 다음에 github과 같은 레포지토리에 코드를 올려두면, 원하는 타이밍에 자동으로 소스코드가 빌드되고 테스트까지 수행되는 것을 CI라고 한다.
- CI와 관련해서 여러 툴들이 있는데, 
  - Github Action : 깃헙의 내부 서비스 기능으로, 소스코드를 git에 올려두면 자동으로 인식해서 소스코드를 내려받아 빌드를 수행하고 패키징을 해서 이후 배포를 위해 빌드 버전별로 CD에서 가져갈 수 있는 위치에 업로드까지 수행해준다. 필요하다면 이 과정에서 유닛 테스트 통과 여부도 같이 수행하고 실패하면 빌드를 진행하지 않는 과정도 거친다. 즉, github 레포지터리를 기반으로 빌드, 테스트, 배포 이벤트를 발생 시킬 수 있다. 예전 인터프리터형 코드는 단순 파일 압축 형태로 / 빌드가능한 언어들은 빌드결과물만 아카이빙해서 versioning을 했다면 -> 요즘에는 Docker 이미지 기반으로 결과물을 생성하고 있다.

### CD
- Continuous Delivery & Deployment의 약자로 "지속적인 전달과 배포"라는 뜻이다. 즉, 그리고 그렇게 빌드된 프로그램이 자동으로 버전이 올라가서 실제 사용자에게 배포까지 자동으로 나가는 과정을 CD라고 한다.
- CD와 관련해서도 여러 툴들이 있는데,
  - 이렇게 빌드된 Docker 이미지를 AWS ECS라는 CD 툴을 사용해서 EC2에 배포하는 것으로 구현할 수 있다. AWS Code Deploy와 같은 툴도 제공하고 있다. 버전에 따라 선택하려는 툴이나 상세 설정 값에 따라서 배포 세팅이 다양해지기도 하고 최신 트렌드까지 고려하면 쿠버네티스를 포함하는 다른 파트를 좀 많이 배워야 할 정도로 양이 많기에 실습을 하기는 어렵다.


### 꼭 알아야 할 기술
- **Github Action**
  - 요새는 Github에 코드를 많이 올려서 사용하는데, 그래서 Github Action이라는 메뉴가 있다. 거기에 내가 스크립트를 작성해서 스크립트를 넣어주면 그것에 따라서 테스트를 하거나 아니면 github에서 master 브랜치에다가 코드를 merge 하는 순간에 자동으로 빌드를 트리거링 해가지고 github이 알아서 어떤 동작을 수행하게끔 할 수 있다. 


- **Docker**
  - 리눅스 기반의 실행환경과 프로그램을 "컨테이너"라는 개념으로 격리시켜서 컨테이너 단위로 시스템을 구동하고 프로그램을 실행시킬 수 있게 해주는 오픈소스 프로젝트이다. 그래서 빌드 명령이 시작되면 Docker 기술을 통해 컨테이너 이미지(Django 웹앱과 필요한 패키지, 시스템 구성요소들을 전부 그대로 하나의 리눅스 서버로 실행할 수 있는 패키지로 묶음)가 생성
  - 이게 버튜얼 머신이나 부트캠프 같은 것을 써본 사람들은 이해할 수 있다. **Docker는 가상화 기술을 이용해서 마치 사진을 찍듯이 컴퓨터 상태, 그러니까 설치된 프로그램이나 OS, 파일 그대로 "식품을 얼려서 보존하듯이" 스냅샷으로 보존을 해준다.** 그리고 이걸 복제를 그대로 할 수 있게 해준다. 그래서 복제를 해서 필요할 때마다 해동해서 뭔가를 꺼내 쓰는 것 처럼, 그 이미지 상태와 똑같은 컴퓨터를 막 찍어낼 수 있도록 해주는 것을 "Docker 라이징"이라고 한다. 그리고 이 Docker 라이징의 결과물로 Docker 이미지가 만들어진다. 그래서 우리가 Docker 이미지를 가지고 있으면 서버를 여러개로 막 찍어낼 수 있는 것이다.


- **AWS ECS**
  - CD에 대표적인 사례라고 볼 수 있다. AWS의 컨테이너 오케스트레이션(인프라나 시스템 자원을 조정하는 걸 자동화하는 시스템)으로 컨테이너 기반으로 서버 및 인프라를 구동하고 증설하거나 축소하는 등의 기능을 의미. Github Action에서 merge가 되서 빌드라는 이벤트가 발생하면 -> Docker 이미지라는 게 만들어지고 -> 그 이미지를 이 AWS ECS에서 가지고가서 EC2 서버를 띄울 때 사용한다. 이게 바로 CD 즉, Delivery와 Deployment의 개념이 된다. 
  - 그렇게 해서 배포가 될 때, 사용량에 따라서 자동으로 배포를 자동화해주고 또한 그 과정에서 무중단 배포를 해준다거나 별도의 증설, 서버를 1대만 띄울 수 있지만 배포할 때 한 번에 20대, 100대 이렇게 할 수도 있다. 그래서 그걸 자동화해서 조정을 해준다는 개념이다. 그래서 오케스트레이션이라는 단어가 등장한다. 

- 여기 설명된 툴 이외에도, CI/CD를 통합해서 가지고 있는 툴들도 많고 하나만 가지고 있는 툴들도 많다. 대표적으로는 Jenkins, GoCD, TravisCI, TeamCity, CircleCI 등이 있다. 
- 더 자세히 배우고 싶다면 "쿠버네티스" 나 "데브옵스"에 대해서 따로 공부하면 좋을듯 하다.


### MSA(Micro Service Architecture)
- 우리가 백엔드 프로젝트를 만들 때 Web 앱을 Web과 Office로 2개의 App으로 쪼개서 구현을 했다. 이렇게 2개로 쪼갰을 때 각각을 다른 서버, 다른 클러스터로 구성해서 하는 것도 방법이지만 더 작게 쪼개서 Web에서도 사용자 관련 기능, 예약 관련 기능, 식당 관련 기능으로 나눠서 서비스를 개발하고 개별적으로 배포할 수 있도록 구성하는 것을 의미하기도 한다. 이게 바로 MSA이다. 
- 최근에는 하나의 서비스가 워낙 커지고 있기 때문에 하나의 서비스가 단일 프로젝트로 완성되는 것 보다는 여러 프로젝트로 나눠서 각자 역할을 분담해서 구현하게 된다. 
- 만약에 우리가 쇼핑몰을 구현한다면, 검색단만 만드는 프로젝트가 있고, 해당 프로젝트를 담당하는 조직이 그대로 일대일로 대응되는 형식이 있는 것이다. 만약에 쇼핑몰이 작다면 상관이 없지만, 아마존/쿠팡/이베이/네이버쇼핑/11번가/G마켓 이런 큰 마켓의 경우에는 시스템이 워낙 크기 때문에 하나의 기능 단위에서 해결해야 하는 작업도 너무 많아서 MSA로 구성하지 않으면 조직을 나누기도 어렵다. 또한 각각의 프로젝트의 버전 추적이나 장애 원인 파악도 너무 어려워지게 된다. 
- 예를 들자면, 쇼핑몰 개발이 만약 하나의 거대 단일 시스템으로 되어있다면 -> 검색 기능을 고칠때마다 사용자기능, 관리자 기능 등 같이 배포가 한꺼번에 도매급으로 이루어지게 될 것이다. 이렇게 검색기능을 고치는 와중에 사용자 관련 기능 코드를 수정하게 될 수도 있어서 side effect를 전파할 가능성이 있다. 
- 그리고 하나의 배포에 대해서 이곳 저곳에서 업데이트한 내역들이 막 합쳐져서 한 번에 나가기 때문에, 만약 그 이후에 장애가 발생했다면 원인을 파악하려면 관련된 모든 담당자나 조직들이 자신의 문제가 아닌지 어떤 문제가 있는지 찾아봐야 하는 번거로움이 생긴다. 
- 그래서 이러한 MSA라는 개념 덕분에 -> 조직별로 필요한 단위로 쪼개서 서비스를 운영하고 / 배포를 할 수 있게 되었다. 이에 따라 배포 방식에 대한 고민도 따라오게 되었다. 


### 배포의 종류
- **롤링 배포(Rolling)**

