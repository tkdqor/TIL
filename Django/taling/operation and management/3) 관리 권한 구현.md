## 관리 권한 구현
- 지난 시간에 만든 관리자 페이지들을 권한에 따라 접근제어를 하도록 설정을 해보자. 
- django에서는 기본적으로 User 모델을 지원하고 있다. 또한 권한을 관리하기 위한 모델들도 제공하고 있다. 그게 바로 auth_group / auth_group_permission / auth_user_group / auth_user_user_permission이다.
  - 이 내용들은 우리가 DBeaver에도 볼 수 있다. 

- **권한부여의 관점을 2가지로 나눌 수 있다.**
  - 직접부여를 하는 것 : 특정 사용자한테 레스토랑 편집 권한을 주는 것과 같다. 즉, 사용자 계정에 권한을 부여한다. 
  - 간접부여를 하는 것 : 사용자 그룹에 권한을 부여하는 것이다. 현재 프로젝트에서는 운영자 그룹이랑 상점주 그룹 이렇게 2가지가 있다. 

- **그래서 django 기본 모델을 활용하자.**
  - auth_group : 운영자 / 상점주 그룹
  - auth_user_group: 운영자 / 상점주가 될 유저들을 등록
  - auth_group_permission: 상점 정보 관리 권한
    - ‘restaurant_manage’ (운영자전용), 식당 관리 권한
    - ‘booking_manage’ (운영자/상점주전용), 예약 관리 권한
  - 즉, 운영자는 식당 및 예약 관리를 다 할 수 있고 / 상점주는 본인 식당 예약 관리만 할 수 있다. 

- **추가로, DBeaver를 보면 auth_permission이라는 모델이 있다.**
  - 모델을 보면 기존에 데이터가 여러 개 이미 들어가 있다. django에서 이걸 만들 때, 우리가 모델을 추가할 때마다 그 모델의 CRUD 권한이 각각 있을 수 있다. 우리가 Restaurant이라는 모델을 만들었으니까 --> 여기 보면 

<img width="666" alt="image" src="https://user-images.githubusercontent.com/95380638/167451148-3fb81448-430c-49c9-b2d6-4f84491f2816.png">

- **이런식으로 CRUD에 대응하는 권한을 django에서 모델을 migration 하는 순간에 알아서 이렇게 DB에도 권한을 데이터에 넣어준다.**
  - 그래서 superuser는 이러한 권한을 모두 획득한 상태로 시작하고 일반 유저들은 django 어드민에 로그인을 해서 권한을 개별적으로 부여하고 그 메뉴들만 표시되도록 커스텀할 수 있다. 
  - 해당 모델에 위에서 설명했던 것 처럼 restaurant_manage 권한이랑 booking_manage 권한 2개를 레코드를 추가해서 코드를 구현해보도록 하자.

- **모든 권한을 다 가지고 있는 경우, User 모델의 is_superuser 필드가 1로 되어있다.**

- **이렇게 데이터베이스 상에 권한과 그룹이 설정되어 있다면, View에서 사용자의 권한을 부여하고 체크할 수 있다.**

```python
myuser.groups.set([group_list])
myuser.groups.add(group, group, ...)
myuser.groups.remove(group, group, ...)
myuser.groups.clear()
myuser.user_permissions.set([permission_list])
myuser.user_permissions.add(permission, permission, ...)
myuser.user_permissions.remove(permission, permission, ...)
myuser.user_permissions.clear()
```

- **위의 코드에서 myuser는 request.user라고 생각하면 된다. 그래서 해당 객체에 groups.set를 하게되면 실제 그룹을 저장할 수 있고, groups.add로 그룹을 추가할 수도 있다. 이런식으로 작업할 수 있고 또한, user_permissions를 사용해서 각각 유저한테 권한을 부여할 수도 있다.**


### 권한 체크하는 방법
- 함수형 View에 경우에는, 로그인 여부를 체크하는 건 -> @login_required라는 데코레이터를 사용해서 할 수 있고 / 권한 여부를 체크하는 건 -> @permission_required 데코레이터를 쓸 수 있다.
- 클래스 View에 경우에는, 로그인 여부를 -> LoginRequiredMixin를 상속받아서 할 수 있고 / 권한 여부를 -> PermissionRequiredMixin를 상속받아서 할 수 있다. 

- 사용 예시

```python
from django.contrib.auth.mixins import PermissionRequiredMixin

class
RestaurantCreateView(PermissionRequiredMixin, CreateView):
# 하나만 체크
permission_required = ‘web.booking_manage'
# 두개 이상 체크
permission_required = (‘web.restaurant_manage', ‘web.booking_manage')
```

- **이렇게 필드를 선언하게된다. 하나의 권한만 체크할 때는 문자열로 하면 되고 2개 이상 할 때는 튜플로 묶어서 하게되면 이 2개의 권한을 가지고 있는 경우에만 해당 View에 접근할 수 있도록 세팅이 된다.**
- 여기서 문자열을 '코드네임'이라고 한다. 그래서 우리가 권한 테이블에 직접 이 값을 입력해볼 것이다.
  - **우리가 booking_manage라는 코드네임으로 auth_permission이라는 테이블에다가 데이터를 넣게 된다. 그럴 때 -> '앱의 명칭.booking_manage' 이렇게 입력해줘야 한다.**

- 우리가 권한을 체크할 때, 상점 주인의 경우 booking_manage 권한이 있긴 하지만, 내가 소유하고 있는 상점에 대한 것만 관리를 할 수 있어야 한다. 그래서 이걸 해당하는 권한만 체크할 수 있도록 별도의 모델을 하나 더 구현해야 한다. **즉, 우리가 새롭게 구현할 모델은 바로 사용자가 소유하고 있는 상점들의 관계들을 정의하는 그런 모델이 되어야 한다.** 
  - 구현할 모델은, 식당권한 모델(RestaurantPermission)으로 사용자ID, 식당ID가 필드로 들어가서 -> 이런 사용자중에서 상점주 그룹에 속해있는 사용자의 경우에는 식당ID만 가지고와서 권한여부를 체크하게 된다.
  - 그리고 추가로, PermissionRequiredMixin으로 권한 체크를 할 때, 우리가 구현할 식당권한 모델로 체크하는 로직을 오버라이드 할 것이다. 즉, 기존 메소드를 오버라이드 할 것이다. 바로 "has_permission" 메소드이다. 

```python
def has_permission(self):
"""
Override this method to customize the way permissions are checked.
"""

perms = self.get_permission_required()
return self.request.user.has_perms(perms)
```

- 이렇게 원형코드를 





