## 관리 권한 구현
- 지난 시간에 만든 관리자 페이지들을 권한에 따라 접근제어를 하도록 설정을 해보자. 
- django에서는 기본적으로 User 모델을 지원하고 있다. 또한 권한을 관리하기 위한 모델들도 제공하고 있다. 그게 바로 auth_group / auth_group_permission / auth_user_group / auth_user_user_permission이다.
  - 이 내용들은 우리가 DBeaver에도 볼 수 있다. 

- **권한부여의 관점을 2가지로 나눌 수 있다.**
  - 직접부여를 하는 것 : 특정 사용자한테 레스토랑 편집 권한을 주는 것과 같다. 즉, 사용자 계정에 권한을 부여한다. 
  - 간접부여를 하는 것 : 사용자 그룹에 권한을 부여하는 것이다. 현재 프로젝트에서는 운영자 그룹이랑 상점주 그룹 이렇게 2가지가 있다. 

- **그래서 django 기본 모델을 활용하자.**
  - auth_group : 운영자 / 상점주 그룹
  - auth_user_group: 운영자 / 상점주가 될 유저들을 등록
  - auth_group_permission: 상점 정보 관리 권한
    - ‘restaurant_manage’ (운영자전용), 식당 관리 권한
    - ‘booking_manage’ (운영자/상점주전용), 예약 관리 권한
  - 즉, 운영자는 식당 및 예약 관리를 다 할 수 있고 / 상점주는 본인 식당 예약 관리만 할 수 있다. 

- **추가로, DBeaver를 보면 auth_permission이라는 모델이 있다.**
  - 모델을 보면 기존에 데이터가 여러 개 이미 들어가 있다. django에서 이걸 만들 때, 우리가 모델을 추가할 때마다 그 모델의 CRUD 권한이 각각 있을 수 있다. 우리가 Restaurant이라는 모델을 만들었으니까 --> 여기 보면 

<img width="666" alt="image" src="https://user-images.githubusercontent.com/95380638/167451148-3fb81448-430c-49c9-b2d6-4f84491f2816.png">

- **이런식으로 CRUD에 대응하는 권한을 django에서 모델을 migration 하는 순간에 알아서 이렇게 DB에도 권한을 데이터에 넣어준다.**
  - 그래서 superuser는 이러한 권한을 모두 획득한 상태로 시작하고 일반 유저들은 django 어드민에 로그인을 해서 권한을 개별적으로 부여하고 그 메뉴들만 표시되도록 커스텀할 수 있다. 
  - 해당 모델에 위에서 설명했던 것 처럼 restaurant_manage 권한이랑 booking_manage 권한 2개를 레코드를 추가해서 코드를 구현해보도록 하자.

- **모든 권한을 다 가지고 있는 경우, User 모델의 is_superuser 필드가 1로 되어있다.**

- **이렇게 데이터베이스 상에 권한과 그룹이 설정되어 있다면, View에서 사용자의 권한을 부여하고 체크할 수 있다.**

```python
myuser.groups.set([group_list])
myuser.groups.add(group, group, ...)
myuser.groups.remove(group, group, ...)
myuser.groups.clear()
myuser.user_permissions.set([permission_list])
myuser.user_permissions.add(permission, permission, ...)
myuser.user_permissions.remove(permission, permission, ...)
myuser.user_permissions.clear()
```

- **위의 코드에서 myuser는 request.user라고 생각하면 된다. 그래서 해당 객체에 groups.set를 하게되면 실제 그룹을 저장할 수 있고, groups.add로 그룹을 추가할 수도 있다. 이런식으로 작업할 수 있고 또한, user_permissions를 사용해서 각각 유저한테 권한을 부여할 수도 있다.**


### 권한 체크하는 방법
- 함수형 View에 경우에는, 로그인 여부를 체크하는 건 -> @login_required라는 데코레이터를 사용해서 할 수 있고 / 권한 여부를 체크하는 건 -> @permission_required 데코레이터를 쓸 수 있다.
- 클래스 View에 경우에는, 로그인 여부를 -> LoginRequiredMixin를 상속받아서 할 수 있고 / 권한 여부를 -> PermissionRequiredMixin를 상속받아서 할 수 있다. 

- 사용 예시

```python
from django.contrib.auth.mixins import PermissionRequiredMixin

class
RestaurantCreateView(PermissionRequiredMixin, CreateView):
# 하나만 체크
permission_required = ‘web.booking_manage'
# 두개 이상 체크
permission_required = (‘web.restaurant_manage', ‘web.booking_manage')
```

- **이렇게 필드를 선언하게된다. 하나의 권한만 체크할 때는 문자열로 하면 되고 2개 이상 할 때는 튜플로 묶어서 하게되면 이 2개의 권한을 가지고 있는 경우에만 해당 View에 접근할 수 있도록 세팅이 된다.**
- 여기서 문자열을 '코드네임'이라고 한다. 그래서 우리가 권한 테이블에 직접 이 값을 입력해볼 것이다.
  - **우리가 booking_manage라는 코드네임으로 auth_permission이라는 테이블에다가 데이터를 넣게 된다. 그럴 때 -> '앱의 명칭.booking_manage' 이렇게 입력해줘야 한다.**

- 우리가 권한을 체크할 때, 상점 주인의 경우 booking_manage 권한이 있긴 하지만, 내가 소유하고 있는 상점에 대한 것만 관리를 할 수 있어야 한다. 그래서 이걸 해당하는 권한만 체크할 수 있도록 별도의 모델을 하나 더 구현해야 한다. **즉, 우리가 새롭게 구현할 모델은 바로 사용자가 소유하고 있는 상점들의 관계들을 정의하는 그런 모델이 되어야 한다.** 
  - 구현할 모델은, 식당권한 모델(RestaurantPermission)으로 사용자ID, 식당ID가 필드로 들어가서 -> 이런 사용자중에서 상점주 그룹에 속해있는 사용자의 경우에는 식당ID만 가지고와서 권한여부를 체크하게 된다.
  - 그리고 추가로, PermissionRequiredMixin으로 권한 체크를 할 때, 우리가 구현할 식당권한 모델로 체크하는 로직을 오버라이드 할 것이다. 즉, 기존 메소드를 오버라이드 할 것이다. 바로 "has_permission" 메소드이다. 

```python
def has_permission(self):
"""
Override this method to customize the way permissions are checked.
"""

  perms = self.get_permission_required()
  return self.request.user.has_perms(perms)
```

- 이렇게 원형코드를 보면, perms라는 변수를 가지고 오게 된다. 그래서 permission_required 조건을 가지고와서 만족하는 perms를 검색하게 되는데 이걸 가지고 왔을 때 booking_manage 권한명이 들어가 있으면, 우리가 상점주일때는 해당 권한이 있는지 체크해야 한다. 그래서 update / create / delete는 has_perms에서부터 막히도록 할 것이고, Read의 경우에는 바로 막지는 않고 쿼리셋을 정의할 때 내가 가진 식당의 권한을 가져올 수 있도록 별도의 메소드를 만들자.


## 관리 권한 구현 실습
- **먼저 DBeaver로 가서 auth_permission 모델에 데이터 추가하기**
  - 여기서 name을 Manage Restaurant이라고 입력, content_type_id는 16번, codename은 manage_restaurant이라고 입력. 우리가 실제 권한 체크 할 때는 codename이라는 부분만 본다. 
  - 한 줄 더 추가해서 name에 Manage Booking, 21번, manage_booking이라고 입력. 그리고 저장해준다. 

- **그리고 이제 group를 만들어줘야 한다. auth_group 모델로 들어가서 2개를 생성해야한다.**
  - 첫번째 데이터 name은 manager / 두번째 데이터 name은 owner로 설정한다. 그래서 운영자랑 상점주 이렇게 그룹을 나눈다. 여기까지 하고 저장한다.

- **그 다음은 auth_group_permissions 모델이다.**
  - 여기서 group_id 필드에는 위에서 만든 group의 id를 적어준다. 그리고 데이터를 2개 만들어서 group_id가 1일 때(즉, 운영자 그룹일 때) permission_id는 93, 94번으로 위에서 만든 권한들 2개를 다 적용한다. 
  - 그리고 group_id 2번인 상점주는 booking 권한만 있으면 되니까 94번으로 해주고 저장하면 된다.

- **User모델의 한 계정을 선택해서 권한을 줘보자. auth_user_groups라는 모델에 들어가서**
  - user_id는 내가 선택한 계정으로 하고, group_id는 매니저인 1번을 입력한다. 매니저이기 때문에 2개의 권한에 모두 접근할 수 있게된다. 


### 코드추가
- **이렇게 권한이 정리가 되었으면 이제 코드를 추가하자. office 앱 안에 있는 models.py로 가자.**

```python
from django.db import models
from django.contrib.auth.models import User

from web.models import Restaurant


class RestaurantPermission(models.Model):
    restaurant = models.ForeignKey(Restaurant, on_delete=models.CASCADE)
    user = models.ForeignKey(User, on_delete=models.CASCADE)

```

- **이렇게 web의 모델과 User를 가지고 오고, 해당 모델은 Restaurant모델과 User모델을 매핑시키는 역할이니까 이 2개를 가지고 오는 것이다.**
- **모델은 가져온 모델들과 1:N으로 설정. 그리고 migration / migrate 해주기.**

- **그 다음, Restaurant.py로 가서 import로 mixin에서** 

```python
from django.contrib.auth.mixins import PermissionRequiredMixin
...

# 식당 조회
class RestaurantListView(PermissionRequiredMixin, ListView):
    model = Restaurant
    paginate_by = 10
    template_name = 'office/restaurant/list.html'
    ordering = ['-created_at']
    permission_required = 'web.manage_restaurant'
    login_url = reverse_lazy('login')


# 식당 생성
class RestaurantCreateView(PermissionRequiredMixin, CreateView):
    model = Restaurant 
    fields = ('name', 'category', 'address', 'phone', 'menu_info', 'description')
    template_name = 'office/restaurant/create.html'
    success_url = reverse_lazy('office-restaurant-list')
    permission_required = 'web.manage_restaurant'
    login_url = reverse_lazy('login')

    def form_valid(self, form):
        data = form.save(commit=False)
        data.save()

        image_data = self.request.FILES.get('main_image')
        if image_data:
            image = RestaurantImage(
                restaurant=data,
                image=image_data,
            )
            image.save()
            data.main_image = image
            data.save()
        
        return super().form_valid(form)


# 식당 업데이트
class RestaurantUpdateView(PermissionRequiredMixin, UpdateView):
    model = Restaurant
    pk_url_kwarg = 'restaurant_id'
    fields = ('name', 'category', 'address', 'phone', 'menu_info', 'description')
    template_name = 'office/restaurant/update.html'
    success_url = reverse_lazy('office-restaurant-list')
    permission_required = 'web.manage_restaurant'
    login_url = reverse_lazy('login')

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['object'] = self.object
        return context

    def form_valid(self, form):
        data = form.save(commit=False)
        data.save()

        image_data = self.request.FILES.get('main_image')
        if image_data:
            image = RestaurantImage(
                restaurant=data,
                image=image_data,
            )
            image.save()
            data.main_image = image
            data.save()
        
        return super().form_valid(form)


# 식당 삭제
class RestaurantDeleteView(PermissionRequiredMixin, DeleteView):
    model = Restaurant
    pk_url_kwarg = 'restaurant_id'
    template_name = 'office/restaurant/delete.html'
    success_url = reverse_lazy('office-restaurant-list')
    permission_required = 'web.manage_restaurant'
    login_url = reverse_lazy('login')

```

- 이렇게 PermissionRequiredMixin를 가지고 온다. 그 다음, RestaurantListView, RestaurantCreateView, RestaurantUpdateView, RestaurantDeleteView에 해당 mixin을 상속시켜준다. 
- **그리고 각각의 View에 우리가 추가로 permission_required라는 변수를 추가해주면 된다. 그래서 web의 manage_restaurant 권한이 있는 사람만 이 View를 사용할 수 있다는 것이다.**

- 여기까지 진행하고 서버를 구동시켜보면, http://localhost:8000/office/로 들어가서 로그인을 하지 않은 상태로 "식당"버튼을 클릭하게 되면 Page not found 에러가 뜨면서 권한이 방어가 된다.
  - **url를 보면 자동으로 redirect로 login으로 넘기니까 우리가 다시 여러 View에서 login_url를 설정해주자.**


- **이제, 그러면 접근할 수 없을 때 로그인 화면이 나오게 된다. 그리고 우리가 권한을 주었던 계정으로 로그인을 한 다음에, 아까와 같은 페이지에서 식당을 클릭해보면 해당 유저는 권한이 있기 때문에 잘 들어가지는 것을 확인할 수 있다.**


### 코드추가 - booking 부분
- 이제는 office 앱 - views 디렉터리 내부에 permission.py라는 파일을 생성해보자. 여기에는 기존의 PermissionRequiredMixin를 상속받아서 우리가 상점 권한을 체크할 수 있는 클래스를 따로 구현을 할 것이다. 

```python
from django.contrib.auth.mixins import PermissionRequiredMixin
from django.core.exceptions import ObjectDoesNotExist
from django.shortcuts import get_object_or_404

from ..models import RestaurantPermission
from web.models import Restaurant, Booking

class BookingPermissionRequiredMixin(PermissionRequiredMixin):
    check_permission_path_variable = None

    def has_manager(self):
        if self.request.user.is_superuser:
            return True

        groups = self.request.user.groups.all()
        if any(group.name == 'manager' for group in groups):
            return True
        
        return False

```

- **이렇게 먼저 필요한 것들을 import 해주고, BookingPermissionRequiredMixin이라는 이름을 설정해서 PermissionRequiredMixin를 상속받아준다.** 
  - **그리고 내부에는 check_permission_path_variable라는 필드를 설정한다.** 이건 pk_url_kwargs처럼 check_permission_path_variable에는 path 파라미터의 변수명을 넣을 것이고, 그러면 우리 로직에서 해당 booking id의 해당하는 레스토랑에 대한 권한이 있는지 체크하는 로직을 만들것이다. 
  - **클래스 내부에 has_manager라는 메소드를 설정하고, 현재 로그인된 사용자가 manager group에 속해있는지 체크하는 로직을 만든다.**
  - groups = self.request.user.groups.all() 이렇게 하면 현재 로그인된 유저의 그룹들을 전부 가지고 오게 된다. 
  - 그리고 if any(group.name == 'manager' for group in groups): 해당 코드들은, "groups 안에 있는 그룹 중에서 manager라는 그룹이 하나라도 있으면" 이라는 조건이다. 그래서 맞으면 True를 반환해준다. 
  - **그래서 결론적으로, 지금 로그인한 유저가 슈퍼유저이거나 manager 그룹에 소속되어있으면 True가 return이 되고 아니면 Flase가 반환되는 것이다.**
  - 우리는 이걸 지금 로그인된 유저가 상점주인지 아니면 다른 권한이 있는 그룹에 속해있는지 체크하는 것이다. 

- **그 다음, 클래스 내부에 추가로 get_bookings_has_perms라는 메소드를 만들어준다.**
  - 이 메소드를 사용하면, 나중에 우리가 ListView를 booking.py에 구현할 것인데, 그 때 현재 로그인된 사용자가 권한을 가지고 있는 booking의 리스트만 가지고 오게 할 것이다. 내가 만약에 이탈리아 레스토랑을 운영하고 있는데, 이 사이트는 이탈리아 레스토랑이 있고 옆집에는 스시집도 있다. 근데, 나는 이탈리아 레스토랑의 주인이다. 스시집 주인은 아니라서 거기의 booking 데이터까지 보여지면 안될 것이다. 나는 이탈리아 레스토랑의 예약 내역만 보고 있어야 한다. 그래서 이런 걸 필터링하기 위한 메소드라고 생각하면 된다. 
  - **권한이 매니저일 경우에는 모든 예약 내역을 볼 수 있어야 한다. 그래서 이 때는 if self.has_manager(): / return Booking.objects.all() 이런식으로 모든 Booking 데이터를 가지고 올 수 있게 쿼리셋을 리턴해준다.**









