## Migrations
- 모델의 변경내역을 "데이터베이스 스키마" 로 반영시키는 효율적인 방법을 제공해준다. 
- **우리는 모델과 데이터베이스 스키마를 맞춰야 한다. 맞춰야만 우리의 모델을 사용할 수 있다.**
- 우리가 모델만 개발하고 migrations를 통해 -> 데이터베이스로 자동 반영을 할 수 있는 것이다.

- 그런데 만약, 데이터베이스 관리자가 따로 있고 관리자(DBA)가 DB를 직접 설계하고 우리가 이 DB를 사용해야 한다면, 혹은 django 이전에 이미 DB가 있어서 그 DB와 연동해야 된다면 -> 이 때는 migrations 기능을 사용할 수 없다.
  - migrations 기능은 django를 통해서 직접 데이터베이스 스키마에 히스토리를 관리하고 직접 반영도 할 수 있는 기능이다.


### Migrations 관련 명령어
- **마이그레이션 파일 생성**
  - python manage.py makemigrations <앱이름>   (앱이름을 생략하면 전체 앱에 대해서 검사를 하게 되는데 앱이름을 지정하는 걸 추천한다. 이렇게 지정을 해주면 좀 더 빠르게 동작한다.

- **지정 데이터베이스에 마이그레이션 적용**
  - python manage.py migrate <앱이름>   (위와 같이 앱이름을 생략하면 전체 앱에 대해서 지정을 하게 된다.)
  - 맨 처음 프로젝트를 만들고 난 후에 해야하는 migrate는 앱이름 없이 전체 앱들에 대해서 진행한다. django는 기본 앱들이 있는데 settings.py -> INSTALLED_APPS에 보면 기본 앱들의 종류를 알 수 있다. 이러한 기본 앱들한테도 마이그레이션 내역들이 있다. 
 또한, 각 기본 앱들한테도 모델이 있다.
     - auth 앱에게는 user 모델이 있고 sessions 앱에도 모델이 있다. 그래서 이러한 기본 앱 안에 있는 모델에 대한 마이그레이션들을 순차적으로 적용해줘야 하는 것이다.

- **마이그레이션 적용 현황 출력**
  - python manage.py showmigrations <앱이름>  (이 때, 앱이름을 쓰지 않으면 전체 앱에 대한 현황을 보여준다.)
  - X는 다 적용이 되었다는 표시이다. 만약 공백이 있으면 적용이 되어있지 않다는 의미이다.

- **지정 마이그레이션의 SQL 내역 출력**
  - python manage.py sqlmigrate <앱이름> <마이그레이션-이름>
  - 아직 수행되지 않은 마이그레이션 파일 혹은 이미 수행된 마이그레이션에 대해서도 언제든지 sql 내역을 볼 수 있다. 


### 실제 Migrations 진행 과정
- 보통 migrations를 진행하는 순서가 마이그레이션 파일 생성 -> 지정 마이그레이션의 SQL 내역 출력 -> 지정 데이터베이스에 마이그레이션 적용 / 마이그레이션 적용 현황 출력은 수시로 진행.
  - 처음에 먼저 models.py을 수정하고나서 migrations 파일 생성 명령을 내려주면, django가 만들어준다. 하지만 여기까지는 파일만 만들어진 것이고 실제 DB에 반영 및 변경이 된 것은 아니다. 그래서, 그 마이그레이션 파일이 실제로 DB에 어떤 변화를 가할것인지 그걸 SQL의 형태로 확인해봐야 한다.
  - 그래서 sql문을 확인해보고 우리가 의도한대로 sql이 잘 생성된다고 판단이 들면 migrate 명령을 통해서 실제로 적용을 하게 되는 것이다. 

* * *

### Migration 파일
- 데이터베이스에 어떤 변화를 가하는 Operation이라는 리스트로 나열한 파일.
- django에 의해서 자동생성 되기는 하지만, 우리가 직접 커스텀 Operation들을 추가헤줄 수 있다. 
- 테이블 생성/삭제, 필드 추가/삭제 등이 반영되고 우리가 커스텀 python / SQL Operation을 넣을 수도 있다. ex) 데이터 마이그레이션 
  - 우리가 우편번호 모델을 만들었다고 가정했을 때, 우편번호에 대한 모델을 설계하고 우편번호는 대개 데이터가 다 있으니까 모델을 설계하고나서 그 테이블에다가 데이터를 부울 때, 붓는 부분을 별도의 명령을 통해서 마이그레이션에 그 과정을 넣어줄 수도 있다. 이렇게 설정하게 되면 우편번호 모델 테이블이 만들어지고 나서 바로 데이터가 채워지게 된다.

- Migration 파일은 makemigrations 명령을 통해 대개 모델로부터 자동 생성된다. 참고로 DB는 수시로 백업을 해줘야 한다.
  - Migration 파일들은 앱 내부 디렉터리 안에 있는 -> migrations라는 디렉터리에 시간 순서대로 저장되어 있다.
  - migration 파일을 클릭해 보면, Migration이라는 클래스 안에 dependencies는 의존성을 의미한다. 어떤 앱에, 어떤 마이그레이션에 대해서 의존성을 가지는지 보여준다. / operations라는 리스트가 있다.
    - 이러한 코드들을 django가 자동 생성 해주고 있는 것이다.

- **같은 마이그레이션 파일이라고 할지라도 DB 종류에 따라 다른 SQL이 생성된다.**
  - 모든 데이터베이스 엔진들이 같은 기능을 제공하지 않기 때문이다. 따라서 DB가 바뀌게 되면 SQL를 확인해주는 것이 필요하다.


### 마이그레이션 파일 생성 및 적용
- 어떤 앱의 models.py 가 있고, 여기에서 여러 번 모델을 변경할 수 있다. 그리고나서 -> makemigrations 명령으로 마이그레이션 파일을 생성하고 이 파일을 꼭 열어봐야 한다.
  - 그리고 sqlmigrate 명령으로 우리가 의도한대로 맞게 생성이 되었는지 꼭 확인을 해야 된다. 확인 후 잘 생성이 되었다고 하면 -> migrate 명령으로 DB에 적용하는 것이다.
  - 이후에 또 models.py에 변경사항이 있을 때마다 위와 같은 과정을 거쳐야 한다.


### 언제 makemigrations를 해야 될까?
- 모델 필드 관련된 어떠한 변경이라도 발생 시에 마이그레이션 파일 생성해야 된다.
  - 즉, 실제 DB 스키마에 가해지는 변화가 없더라도 수행해야 한다. 왜냐하면, 마이그레이션 파일은 모델의 변경내역을 누적하는 역할을 하기 때문이다. 따라서 모델 필드에 직접적인 것이 아닌, 관련된 변경 내역이 본인이 생각했을 때 이 변경이 DB 스키마에 가해지는 변화가 없다고 판단하더라도 마이그레이션을 해야된다.
  - 그리고 만약 실제로 적용할 내용이 없다면, makemigrations를 할 때 적용할 내용이 없다고 알려준다.

- **주의할 점은, 적용된 마이그레이션 파일은 절대 삭제하면 안된다.**
  - 만약, 지금까지 3개의 마이그레이션 파일이 적용되었다고 했을 때 -> 다 끝난거니까 지워도 되는 게 아니라 히스토리를 쌓아간다는 개념으로 지우면 안된다.
  - **나중에 롤백(Rollback)(변경사항을 되돌리기)에 대해서도 살펴볼 것인데 만약 3번째 적용을 언두(undo)(실행취소) 하게 되면 -> 3번의 변경내역이 취소가 된다. 이 때 3번에 대한 마이그레이션 파일이 미적용되었으면 지워도 되지만 적용된 대상은 절대 삭제해서는 안된다.** (3번째 적용을 취소한거니까, 2번째 적용을 기준으로 보면 3번째 마이그레이션 파일은 미적용되는 사항들이니 지워도 되지 않을까..?)
  - 우리가 서비스를 하게 되면 이 마이그레이션 파일이 몇 백개 될 수도 있다. 그럴 때는 이 마이그레이션 내역을 개별적으로 히스토리를 쪼개서 볼 필요가 없다라고 판단이 들 수가 있다. 그런 경우에는 squashmigrations 명령으로 다수의 마이그레이션 파일들을 압축해서 통합할 수 있다.

* * *

### 마이그레이션 Migrate (정방향 / 역방향)
- 마이그레이션의 Migrate 명령은 정방향 / 역방향으로 구분된다. 

- **python manage.py migrate <앱이름>**
  - 미적용 <마이그레이션-파일> 부터 <최근-마이그레이션-파일> 까지 정방향으로 순차적으로 수행 

- **python manage.py migrate <앱이름> <마이그레이션-이름>**
  - 위의 코드로 입력하는 <마이그레이션-이름>이 현재 적용된 마이그레이션보다 
    - 이후라면, 정방향으로 순차적으로 지정 마이그레이션까지 forward 수행
    - 이전이라면, 역방향으로 순차적으로 지정 마이그레이션 이전까지 backward 수행
 
 
#### 중요한 마이그레이션 예시
- 만약 우리의 마이그레이션 파일들이 0001번, 그다음에는 0002번, 그다음에는 0003번 ... 이렇게 해서 총 0007번까지 있다고 가정하자.
  - 우리가 0005번까지 migrate를 하고 / 0006, 0007번에 대해서는 makemigrations만 하고 아직 migrate를 안한 상태이다. 그래서 지금 상황에서 우리가 python manage.py migrate를 하게 되면 정방향(1에서 시작)으로 0006번이 수행되고 그리고 0007번이 순차적으로 수행이 된다.
  - 반면에 역방향의 경우는, 현재 0005번까지 마이그레이션 파일 적용되고(showmigrations 했을 때 x표시) migrate까지 진행되었는데, 이 상황에서 python manage.py migrate <앱이름> 0003 이렇게 하게 되면 / 현재 0005번인데 0003번의 상태로 되돌아가게 된다. 
     - python manage.py migrate <앱이름> <마이그레이션-이름> 에서 <마이그레이션-이름>에 적어주는 이름은 -> 내가 마지막 상태가 되고 싶은 마이그레이션 이름을 쓰는 것이다. 지금은 0003번이 되고 싶다고 명령한 것이니까 0005번이 취소되고, 0004번도 취소되서 0003번이 마지막 상태가 되는 것이다.
     - 그렇게 해서 0003번이 현재 상황이 되었을 때, python manage.py migrate <앱이름> 0005번 -> 이렇게 해주게 되면 0005번이 되고 싶은거니까 다시 0004번 적용, 0005번 적용해서 0005번이 현재 상황이 된다.
     - 즉, python manage.py migrate <앱이름> 까지만 입력해서 뒷부분을 생략하게 되면 -> 마지막까지 정방향으로 진행하게 된다.


### 마이그레이션 이름 지정
- 개발을 하면서 마이그레이션 파일을 지정할 때, 전체 이름(파일명)을 지정하지 않더라도 1개를 판별할 수 있는 일부만 지정해도 된다. 대개 마이그레이션 파일 앞에 숫자가 붙는데 겹치지 않는다. 그런데,
```python
shop/migrations/0001_initial.py
shop/migrations/0002_create_field.py
shop/migrations/0002_update_field.py
```
- 이렇게 되는 경우가 있다. 이 경우는 저장소가 하나가 있는데, 팀원 A가 clone하고 팀원 B가 clone한 것이다. 그래서 A 따로 migration를 하고 B 따로 migration를 해버린 것이다. 그리고나서 둘다 push를 한 것이다. 그러면 위와같이 0002가 2개 생성될 수도 있다.

- 위와 같이 파일들이 있을 때, python manage.py migrate <앱이름> <마이그레이션-이름> 지정 시, 0001_initial 여기까지가 실제 파일의 풀네임이라고 보면 된다.
  - 그런데 
