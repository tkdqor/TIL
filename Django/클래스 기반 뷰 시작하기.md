## View
- django에서는 호출가능한 객체


### 함수 기반 뷰 (Function Based View
- View 구현의 기본. 공통기능들은 장식자 문법으로 적용. 

```python
@api_view(['GET'])
@throttle_classes([OncePerDayUserThrottle])
def my_view(request):
    return Response({"message":	"Hello	for	today!"})
```    

- 어떠한 View가 있을 때, 우리가 DRF를 사용한다면 API의 기능들을 위해 해당 View 함수에다가 @api_view(['GET']) 장식자로 꾸며준다. / 그리고 요청 호출 수를 제한하고 싶을 때는, @throttle_classes([OncePerDayUserThrottle]) 이 장식자를 설정한다.



### 클래스 기반 뷰 (Class Based View)
- 클래스 기반 View에서는 공통 기능들을 부모 클래스로 만들어서 상속 문법으로 자식 클래스에게 적용한다.
- 공식문서 https://docs.djangoproject.com/en/3.0/topics/class-based-views/

```python
class MyView(APIView):
    throttle_classes	=	[OncePerDayUserThrottle]
    
    def get(self,	request):
        return Response({"message":	"Hello	for	today!"}) 
```

- MyView는 APIView를 상속받아서 설정.

- 클래스 기반 View는, View 함수를 만들어주는 클래스 / as_view() 클래스 함수를 통해, View 함수를 생성
  - 상속을 통해, 여러 기능들을 믹스인

- 장고 기본 CBV 팩키지 -> django.views.generic에 위치해 있음 
  - https://github.com/django/django/tree/main/django/views/generic -> 여기에서 list.py를 보면, class ListView(MultipleObjectTemplateResponseMixin, BaseListView): 
    라고 해서 우리가 사용해본 클래스가 있다. 그리고 해당 클래스는 BaseListView를 상속받아 구현한 것을 알 수 있다. 해당 클래스의 위쪽에 보면 MultipleObjectTemplateResponseMixin, BaseListView의 
    클래스가 어떻게 정의되어 있는지 알 수 있다.
  - BaseListView 클래스는 어떤 get 요청이 왔을 때, 쿼리셋을 만들어주고 쿼리셋에 데이터가 없는 상황을 허용할지 안할지를 결정해준다. 만약 허용하지 않는다면 Http 404 에러를 발생하겠다고 한다.

- 써드파티 CBV
  - django-braces 라는 라이브러리가 있다. https://django-braces.readthedocs.io/en/latest/


### CBV 컨셉 구현해보기
- 먼저, FBV로 우리가 만약 어떤 앱에서 Post와 Article이라는 모델에 대해서 우리가 detail 함수를 설정한 경우이다.

```python
from django.shortcuts	import get_object_or_404,	render

def post_detail(request,	id):
    post	=	get_object_or_404(Post,	id=id)
    return render(request,	'blog/post_detail.html',	{
        'post':	post,
    })
    
def article_detail(request,	id):
    article	=	get_object_or_404(Article,	id=id)
    return render(request,	'blog/article_detail.html',	{
      'article':	article,
    })
```

- 이 2개의 View 함수는 비슷한 점이 많고 공통적인 부분이 많다.

```python

def post_detail(request: HttpRequest, pk: int) -> HttpResponse:
    post = Post.objects.get(pk=pk)

    return render(request, 'instagram/post_detail.html', {
        'post': post,
    })
```

- 이 post_detail 예시 코드에서는 Post 모델 테이블에서, pk라는 필드에 url로부터 받은 pk라는 인자를 대입하여 그 pk에 해당하는 객체를 post라는 변수에 담았다.
- post_detail(request: HttpRequest, pk: int) -> HttpResponse: 여기에서 -> 만약 pk가 100처럼 없는 pk라면 DoesNotExist라는 에러가 발생하게 된다.
  - 이 때, server 로그를 보면 -> [15/Feb/2022 03:06:34] "GET /instagram/34/ HTTP/1.1" 500 78863 이렇게 어떠한 GET 요청이 왔는데, 이 /instagram/34/ 주소에 대해서 HTTP/1.1 이라는 프로토콜이었고, server에서는 상태 코드라고 해서 500 응답을 주었다고 해준다. 그리고 응답의 크기는 78,863 바이트정도 된다는 것이다.
  - 우리가 서비스를 이용하다보면, Page not found 404라는 오류를 많이 볼 수 있다. 지금도 이러한 404로 줘야 한다. 500은 server 에러이고, 데이터가 없는 게 server 에러는 아니기 때문이다. 그래서 실제로 404를 띄우기 위해 다시 코드를 작성해보면,

```python
from django.http import Http404, HttpResponse, HttpRequest

def post_detail(request: HttpRequest, pk: int) -> HttpResponse:
    try:
        post = Post.objects.get(pk=pk)
    except Post.DoesNotExist:
        raise Http404    

    return render(request, 'instagram/post_detail.html', {
        'post': post,
    })
```

- 맨 위에 Http404를 import 해주고, 코드에서는 예외적으로 DoesNotExist 오류가 발생했을 때는 Http404를 보내주는 것으로 한다. 보통은 HttpResponse를 return 하는 형태이지만, Http404 같은 경우는 예외이기 때문에 raise로 발생시킨다. 이렇게 설정하면, 아래와 같이 DoesNotExist가 뜨는 게 아니라 Page not found (404)라고 뜨는 것을 확인할 수 있다. 그리고 server 로그에도 [15/Feb/2022 03:18:17] "GET /instagram/133/ HTTP/1.1" 404 12626 이렇게 바뀌게 된다.

<img width="414" alt="image" src="https://user-images.githubusercontent.com/95380638/153986250-3b4a9526-8b48-4e40-8a30-03074e4bc8e6.png">


- 다만, 매번 이런 방식으로 View 함수 내부에 적어주는 것이 번거로울 수 있다. 그래서 

```python
from django.shortcuts import render, get_object_or_404

def post_detail(request: HttpRequest, pk: int) -> HttpResponse:
    post = get_object_or_404(Post, pk=pk)

    return render(request, 'instagram/post_detail.html', {
        'post': post,
    })
```

- 위와같이 get_object_or_404라는 함수를 사용하면 더 간단하게 코드를 작성해서 위와 동일하게 데이터가 있으면 조회하고 없으면 404에러를 내주게 된다.






```python
<h2>Author: {{ post.author }}</h2>

{% if post.photo %}
    <div>
        <img src="{{ post.photo.url }}" alt="" />
    </div>
{% endif %}

{{ post.message }}
```

- View 함수에 이어서 포스트 1개에 detail를 보여주는 post_detail.html도 작성해보자.



