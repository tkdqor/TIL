## 페이지네이션
- 우리가 리스트를 사용자에게 보여줄 때, 데이터가 너무 많으면 페이지 단위로 보여줘야 할 것이다. 이렇게 페이지 단위로 데이터를 처리하는 것을 페이지네이션이라고 한다. 
- 장고에서는 이 페이지네이션을 지원하는 Paginator를 사용할 수 있다. views.py에서 설정해보자.

```python
from django.core.paginator import Paginator

class TaskListView(TemplateView):
    template_name = 'pages/task_list.html'
 
    def get_context_data(self, **kwargs):
        tasks = Task.objects.filter(due__gte=timezone.now()).order_by('-due').all()
        paginator = Paginator(tasks, 4)
        page_number = self.request.GET.get('page', '1')
        paging = paginator.get_page(page_number)

        return {
            'paging': paging,
        }
```


- **먼저 이렇게 core라는 패키지에 있는 Paginator를 import. 그리고 TemplateView를 상속받은 TaskListView를 수정해보자. 여기서 Paginator 클래스를 생성해야 한다.**
  - **Paginator() 괄호안에는 생성할 때의 QuerySet를 넣어주면 된다. 따라서 해당 조건으로 pagination을 하면 된다는 것이다.** 
  - paginator = Paginator(tasks, 4) -> 이렇게 설정해주면 한 페이지당 보여줄 데이터의 개수가 4개라는 것을 의미한다.
  - 이제 request의 쿼리 파라미터로 조회할 현재 페이지의 번호를 가지고 오면 된다. HTTP Request 객체의 GET 딕셔너리에서 조회를 해야 한다.

- **get_context_data에서는 인스턴스의 멤버 변수로 HTTP Request를 request로 그대로 가지고 있기 때문에 메소드의 인자로 request를 받지 않아도 GET 딕셔너리에 접근할 수 있다.** 만약 함수 구조였다면
  request를 바로 쓰면 되지만, 여기서는 self라는 키워드로, 이미 get_contex_data에 숨겨진 상태로 request라는 객체가 들어와 있는 것이다. 굳이 get_context_data함수의 인자로 받을 필요가 없다.
  - 그리고 page_number = self.request.GET.get('page', '1') -> 이렇게 request.GET 딕셔너리에 접근해서 page값을 가져온다. '1'은 디폴트 값으로 주는 것이다. 만약 page라는 값이 없다면 1이 
    기본적으로 page_number에 들어가게 된다.
  
- tasks = Task.objects.filter(due__gte=timezone.now()).order_by('-due').all() -> 위의 해당 코드는 tasks = ['..' , '..'] 이렇게 값이 있는 게 아니다. 아직 확정된 게 없고 조건문이라고 생각해보면 된다.

- 그 다음, 페이지네이터의 get_page 메소드의 현재 page 값을 넘겨주면, 쿼리셋으로 조회된 데이터에 현재 페이지에 보여줄 데이터들과 페이지 관련 정보들을 담은 page 객체를 돌려주게 된다. 
  - 이걸 우리는 paging이라는 이름을 붙여서 작성을 해보자. 
  - paging = paginator.get_page(page_number) 이렇게 작성해볼 수 있다. 

- 그리고 템플릿에는 tasks가 아닌 paging이라는 변수로 넘겨주자.

* * *
- 이제 Template 코드도 페이지 번호를 그려주도록 UI를 추가해야 한다. task_list.html로 가보자.
```html
{% extends "common.html" %}

{% block content %}
<div class="row row-cols-2 row-cols-md-4 g-4 mt-2">
    {% for item in paging %}
    <div class="col">
        <div class="card text-white bg-primary mb-3">
            <div class="card-header">{{ item.type }}</div>
            <div class="card-body">
                <h5 class="card-title">{{ item.title }}</h5>
                <p class="card-text">
                    <span class="badge bg-light text-dark">
                        {{ item.due|date:'Y년 m월 d일 H시 i분' }}까지
                    </span> 
                </p>
            </div>
        </div>
    </div>
    {% endfor %}
</div>

<!-- 페이지 리스트 부분 -->
<div class="row mt-4">
    <nav class="col-12">
        <ul class="pagination justify-content-center">
            <!-- 이전 페이지 버튼 -->
            {% if paging.has_previous %}
            <li class="page-item"> 
                <a class="page-link" href="?page={{ paging.previous_page_number }}">이전</a>
            </li>
            {% endif %}

            <!-- 다음 페이지 버튼 -->
            {% if paging.has_next %}
            <li class="page-item"> 
                <a class="page-link" href="?page={{ paging.next_page_number }}">다음</a>
            </li>
            {% endif %}
        </ul>
    </nav>
</div>
```

    
- 일단, 기본적으로 {% for item in paging %} 이렇게 tasks가 아닌 paging으로 변수를 바꿔준다. paging이라는 변수안에 결과물들을 담고있어서 하나씩 빼줄 수 있다. 
- 그리고 이제 페이지를 클릭할 수 있는 리스트들을 만들어야 한다. bootstrap에 있는 class="pagination"를 활용한다.
  - 또한 보통 pagination UI의 특징은, 이전페이지 버튼이 있다는 점이다. {% if paging.has_previous %} -> 만약에 paging이라는 객체에서 has_previous가 True면 이전 페이지가 있다는 뜻이다.

- views.py에서 설정한 paging이라는 객체를 이해해야할 필요가 있다. views.py에서 paging = paginator.get_page(page_number) -> 여기서 get_page를 command로 클릭하면 get_page 함수가 나오고,
  해당 함수 return에 page를 command로 클릭하면 또 page 함수가 나온다. 그리고 그 함수의 return인 _get_page를 클릭하면 return으로 Page(*args, **kwargs) 이렇게 page라는 객체를 돌려준다.
  이걸 또 command로 클릭하면 Page라는 클래스가 나온다. 여기에 object_list가 나와있고 이것이 literation 객체가 된다. 그 아래에 def __len__(self) 처럼 len()으로 측정했을 때 object_list의 
  len()가 return된다는 것을 봤을 때, 우리가 paging에서 꺼내서 쓰는 얘가 object_list에 담긴다는 것을 알 수 있다. 
  - Page 클래스 던더 init 메소드에 number와 paginator도 있다. number는 현재 페이지 번호를 의미하고 paginator는 현재 페이징 결과물들의 meta 데이터가 담겨있다. has_previous나 has_next 등이 있다.

- 그래서 다시 template으로 왔을 때, {% if paging.has_previous %} -> 이건 paging이라는 객체에 has_previous는 위에서 본 paginator에 들어있는 previous를 체크해서 if에 결과물을 돌려주게 된다.
- 그리고 전 페이지가 있으면 클릭할 수 있게 a element를 사용한다. <a class="page-link" href="?page={{ paging.previous_page_number }}"></a> -> 이러한 필드도 제공해준다.
  - 그리고 다음 페이지 버튼도 만들어준다.

```html
            <!-- 이전 페이지 버튼 -->
            {% if paging.has_previous %}
            <li class="page-item"> 
                <a class="page-link" href="?page={{ paging.previous_page_number }}">이전</a>
            </li>
            {% endif %}

            
            {% for page in paging.paginator.page_range %} 

            {% endfor %}


            <!-- 다음 페이지 버튼 -->
            {% if paging.has_next %}
            <li class="page-item"> 
                <a class="page-link" href="?page={{ paging.next_page_number }}">다음</a>
            </li>
            {% endif %}

- 이전 페이지 버튼과 다음 페이지 버튼 사이에는 보통 -> 페이지 개수만큼 숫자가 있다. 그래서 {% for page in paging.paginator.page_range %} 이렇게 작성해볼 수 있다.
  - django의 아쉬운 점은, 내장되어있는 다양한 필드들이나 메소드들이 찾기가 어려운 부분이 있다. 특히 template에서 사용할 때는 속성들이나 필드들을 command로 검색이 안된다. 그래서 이런 부분은 강의를 보거나,
    아니면 공식문서를 찾아서 실행해보는 것 밖에 없다. 

- 
