## 페이지네이션
- 우리가 리스트를 사용자에게 보여줄 때, 데이터가 너무 많으면 페이지 단위로 보여줘야 할 것이다. 이렇게 페이지 단위로 데이터를 처리하는 것을 페이지네이션이라고 한다. 
- 장고에서는 이 페이지네이션을 지원하는 Paginator를 사용할 수 있다. views.py에서 설정해보자.

```python
from django.core.paginator import Paginator

class TaskListView(TemplateView):
    template_name = 'pages/task_list.html'
 
    def get_context_data(self, **kwargs):
        tasks = Task.objects.filter(due__gte=timezone.now()).order_by('-due').all()
        paginator = Paginator(tasks, 4)
        page_number = self.request.GET.get('page', '1')
        paging = paginator.get_page(page_number)

        return {
            'paging': paging,
        }
```


- **먼저 이렇게 core라는 패키지에 있는 Paginator를 import. 그리고 TemplateView를 상속받은 TaskListView를 수정해보자. 여기서 Paginator 클래스를 생성해야 한다.**
  - **Paginator() 괄호안에는 생성할 때의 QuerySet를 넣어주면 된다. 따라서 해당 조건으로 pagination을 하면 된다는 것이다.** 
  - paginator = Paginator(tasks, 4) -> 이렇게 설정해주면 한 페이지당 보여줄 데이터의 개수가 4개라는 것을 의미한다.
  - 이제 request의 쿼리 파라미터로 조회할 현재 페이지의 번호를 가지고 오면 된다. HTTP Request 객체의 GET 딕셔너리에서 조회를 해야 한다.

- **get_context_data에서는 인스턴스의 멤버 변수로 HTTP Request를 request로 그대로 가지고 있기 때문에 메소드의 인자로 request를 받지 않아도 GET 딕셔너리에 접근할 수 있다.** 만약 함수 구조였다면
  request를 바로 쓰면 되지만, 여기서는 self라는 키워드로, 이미 get_contex_data에 숨겨진 상태로 request라는 객체가 들어와 있는 것이다. 굳이 get_context_data함수의 인자로 받을 필요가 없다.
  - 그리고 page_number = self.request.GET.get('page', '1') -> 이렇게 request.GET 딕셔너리에 접근해서 page값을 가져온다. '1'은 디폴트 값으로 주는 것이다. 만약 page라는 값이 없다면 1이 
    기본적으로 page_number에 들어가게 된다.
  
- tasks = Task.objects.filter(due__gte=timezone.now()).order_by('-due').all() -> 위의 해당 코드는 tasks = ['..' , '..'] 이렇게 값이 있는 게 아니다. 아직 확정된 게 없고 조건문이라고 생각해보면 된다.

- 그 다음, 페이지네이터의 get_page 메소드의 현재 page 값을 넘겨주면, 쿼리셋으로 조회된 데이터에 현재 페이지에 보여줄 데이터들과 페이지 관련 정보들을 담은 page 객체를 돌려주게 된다. 
  - 이걸 우리는 paging이라는 이름을 붙여서 작성을 해보자. 
  - paging = paginator.get_page(page_number) 이렇게 작성해볼 수 있다. 

- 그리고 템플릿에는 tasks가 아닌 paging이라는 변수로 넘겨주자.

* * *
- 이제 Template 코드도 페이지 번호를 그려주도록 UI를 추가해야 한다. task_list.html로 가보자.
```html
{% extends "common.html" %}

{% block content %}
<div class="row row-cols-2 row-cols-md-4 g-4 mt-2">
    {% for item in paging %}
    <div class="col">
        <div class="card text-white bg-primary mb-3">
            <div class="card-header">{{ item.type }}</div>
            <div class="card-body">
                <h5 class="card-title">{{ item.title }}</h5>
                <p class="card-text">
                    <span class="badge bg-light text-dark">
                        {{ item.due|date:'Y년 m월 d일 H시 i분' }}까지
                    </span> 
                </p>
            </div>
        </div>
    </div>
    {% endfor %}
</div>


    
    
    
- 일단, 기본적으로 {% for item in paging %} 이렇게 tasks가 아닌 paging으로 변수를 바꿔준다. paging이라는 변수안에 결과물들을 담고있어서 하나씩 빼줄 수 있다. 
- 그리고 이제 페이지를 클릭할 수 있는 리스트들을 만들어야 한다. bootstrap에 있는 class="pagination"를 활용한다.
  - 또한 보통 pagination UI의 특징은, 이전페이지 버튼이 있다는 점이다. {% if paging.has_previous %} -> 만약에 paging이라는 객체에서 has_previous가 True면 이전 페이지가 있다는 뜻이다.

- views.py에서 설정한 paging이라는 객체를 이해해야할 
