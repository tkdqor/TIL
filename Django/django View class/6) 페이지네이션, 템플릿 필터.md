## 페이지네이션
- 우리가 리스트를 사용자에게 보여줄 때, 데이터가 너무 많으면 페이지 단위로 보여줘야 할 것이다. 이렇게 페이지 단위로 데이터를 처리하는 것을 페이지네이션이라고 한다. 
- 장고에서는 이 페이지네이션을 지원하는 Paginator를 사용할 수 있다. views.py에서 설정해보자.

```python
from django.core.paginator import Paginator

class TaskListView(TemplateView):
    template_name = 'pages/task_list.html'
 
    def get_context_data(self, **kwargs):
        tasks = Task.objects.filter(due__gte=timezone.now()).order_by('-due').all()
        paginator = Paginator(tasks, 4)
        page_number = self.request.GET.get('page', '1')
        return {
            'tasks': tasks,
        }
```


- **먼저 이렇게 core라는 패키지에 있는 Paginator를 import. 그리고 TemplateView를 상속받은 TaskListView를 수정해보자. 여기서 Paginator 클래스를 생성해야 한다.**
  - **Paginator() 괄호안에는 생성할 때의 QuerySet를 넣어주면 된다. 따라서 해당 조건으로 pagination을 하면 된다는 것이다.** 
  - paginator = Paginator(tasks, 4) -> 이렇게 설정해주면 한 페이지당 보여줄 데이터의 개수가 4개라는 것을 의미한다.
  - 이제 request의 쿼리 파라미터로 조회할 현재 페이지의 번호를 가지고 오면 된다. HTTP Request 객체의 GET 딕셔너리에서 조회를 해야 한다.

- **get_context_data에서는 인스턴스의 멤버 변수로 HTTP Request를 request로 그대로 가지고 있기 때문에 메소드의 인자로 request를 받지 않아도 GET 딕셔너리에 접근할 수 있다.** 만약 함수 구조였다면
  request를 바로 쓰면 되지만, 여기서는 self라는 키워드로, 이미 get_contex_data에 숨겨진 상태로 request라는 객체가 들어와 있는 것이다. 굳이 get_context_data함수의 인자로 받을 필요가 없다.
  - 그리고 page_number = self.request.GET.get('page', '1') -> 이렇게 request.GET 딕셔너리에 접근해서 page값을 가져온다. '1'은 디폴트 값으로 주는 것이다. 만약 page라는 값이 없다면 1이 
    기본적으로 page_number에 들어가게 된다.
  
- tasks = Task.objects.filter(due__gte=timezone.now()).order_by('-due').all() -> 위의 해당 코드는 tasks = ['..' , '..'] 이렇게 값이 있는 게 아니다. 아직 확정된 게 없고 조건문이라고
  생각해보면 된다.
