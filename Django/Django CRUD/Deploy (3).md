## Deploy (3)
- nginx는 우리가 별도로 터미널에서 실행시키지 않아도 항상 돌아가는데 반해서 gunicorn은 
```terminal
gunicorn heestagram.wsgi --bind 0:8000
```

- 이렇게 터미널에서 실행시켜줘야 한다. 그리고 컨트롤 + C로 종료할 경우, gunicorn도 종료된다. 이렇게 종료되면 웹 페이지를 새로고침 했을 때, 502 Bad Gateway라는 에러 메시지가 뜨게 된다.
- **nginx는 항상 동작하고 있고 모든 request를 nginx가 먼저 받는데, nginx가 해당 request를 gunicorn한테 전달해줘야 하지만 -> gunicorn이 죽어있으니까, nginx와 gunicorn간의 커넥션이 없으니까 에러가 뜨는 것이다.**
  - 그래서 우리가 터미널을 끄더라도 nginx처럼 gunicorn이 항상 동작하게끔 만들어줘야 한다.

### Linux 서비스
- 이러한 문제를 해결하기 위해 Linux 서비스라는 것이 존재한다. 이 서비스는 프로세스를 대신 실행시켜주고 EC2 server 자체가 재부팅 되더라도 알아서 해당 프로세스를 재시작해준다.
- 새로운 Linux 서비스를 만드려면 서비스에 대한 정보를 담고 있는 서비스 파일을 만들면 되는데, django-samples로 들어와 있는 터미널 상태에서(ubuntu상태) 
```terminal
ls /etc/systemd/system/
```

- 이러한 경로 내부를 확인해보면 Ubuntu 시스템에 이미 등록되어 있는 다양한 서비스를 확인할 수 있다. 이제 우리는 /etc/systemd/system/이라는 디렉터리 내부에다가 우리가 추가하고자 하는 gunicorn과 관련된 서비스를 새롭게 만들어줄 것이다.

```terminal
sudo vim /etc/systemd/system/gunicorn.service
```

- 이렇게 서비스파일의 이름을 정해주자. vim이 실행되고 i를 눌러 insert 모드로 들어간 다음, 서비스 파일을 작성하면 되는데 이 파일 역시 공유된 github의 django-sample 프로젝트의 scripts 안을 보면 gunicorn.service라는 파일이 있다. 해당 파일의 내용을 복사한 다음, vim 화면에 붙여넣자.
  - 해당 코드는, gunicorn 서비스의 설명을 적어주었고 해당 서비스를 실행할 주체를 정의하고 해당 서비스는 WorkingDirectory, env안에 있는 django-sample이라는 디렉터리를 기준으로 실행되어야 하는데 해당 경로에서 실제로 서비스를 구동시키기 위해서 입력해야 하는 명령어는 ExecStart=...  다음과 같다고 얘기하고 있다.

- 다만, 우리는 gunicorn을 가상환경 내부에 설치했고 우리가 지금까지 사용할 때는 env 들어가서 activate한 다음 그 다음에 gunicorn를 사용했지만 -> 이 Linux 서비스 파일에서는 가상환경을 activate하고 이런게 어렵기 때문에 -> 정확하게 가상환경 내부에 설치되어있는 gunicorn를 활용해서 명령을 실행하게끔 지정했다. 우리가 만든 env 가상환경 안에 설치되어있는 gunicorn를 사용해줘 라고 지정해줬다.

- 내용을 다 작성하고 esc를 누르고 command 모드로 간 다음, :wq로 저장 및 종료를 해주고 

```terminal
sudo systemctl enable gunicorn.service
```

- systemctl은 system control의 약자이다. 우리가 추가해준 gunicorn.service라는 파일을 바탕으로 gunicorn 서비스를 enable, 만들어줘 라고 하는 것이다.
- 입력하면 정상적으로 gunicorn 서비스가 등록된 것을 확인할 수 있다. 이러한 상태에서

```terminal
sudo systemctl start gunicorn.service
```

- 위와 같은 명령어를 통해서 해당 서비스를 실행까지 시켜주면 된다. 여기까지 모두 했다면 nginx를 사용했던 것처럼 

```terminal
sudo service gunicorn status
```

- 해당 명령어를 입력하면 -> 현재 gunicorn 서비스가 동작하고 있는지 확인할 수 있다. q를 눌러서 다시 명령어를 입력할 수 있게 해준다.
  - 그리고 만약 django 소스코드가 변경이 되어서 gunicorn를 재시작해야 한다면 

```terminal
sudo service gunicorn restart
```

- 이런식으로 진행해주면 된다.
- 이제 우리가 터미널을 종료해도, 직접 gunicorn를 실행시켜주지 않아도 Linux 서비스의 형태로 Linux가 알아서 gunicorn를 실행하고 관리해준다. 이제는 웹페이지를 새로고침하면 정상적으로 뜬다.


```terminal
ps aux | grep gunicorn
```

- 이렇게 입력하면, 지금 Ubuntu 서버내에 gunicorn이라는 키워드를 포함한 상태로 실행되고 있는 프로세스가 어떤 것들이 있는지 확인할 수 있다. 현재 2개의 프로세스가 실행되고 있음을 알 수 있다. 그리고 우리가 exit 명령어로 Ubuntu 터미널에서 아예 빠져나오더라도 우리가 서비스가 정상적으로 동작하게 된다. 그리고 다시 Ubuntu로 접속해주자.
- 좋은 소프트웨어는 컴퓨터 하드웨어에 대한 이해가 바탕이 될 때 작성할 수 있다. 


### 도메인과 EC2 연결하기
- 지금까지 EC2 서버에 우리의 서비스를 배포하는 건 모두 마무리가 되었다. 해당 서비스를 이용하기 위해서 사용자가 IP주소를 입력하는 것이 아니라 -> 도메인을 통해 편하게 접속할 수 있게끔 해보자.
- AWS Management Console에서 **route53**이라고 검색하자. 링크를 눌러서 route53 대시보드로 이동하게 되는데 DNS 관리의 **호스팅 영역 생성** 버튼을 눌러주자.
- 호스팅 영역 구성에 도메인 이름 부분에다가 우리가 구매한 도메인의 이름을 적어주자. 설명은 적지 않아도 되고, 유형은 **퍼플릭 호스팅 영역** 으로 선택하자. 다 작성했다면 -> 하단에 호스팅 영역 생성 버튼을 눌러주자.
  - 그러면 레코드 탭 내용이 나오고 2개의 레코드가 자동으로 추가되어있다. 유형에 보면 NS는 NameServer의 약자이다.
  - 우리는 가비아라는 서비스를 통해 도메인을 구입했는데 그 도메인을 -> AWS의 네임서버와 연동시켜서 이후에 도메인과 관련된 모든 작업을 AWS 내부에서만 수행할 수 있게끔 변경해주자.
  - 이를 위해서는 가비아 대시보드에서 해당 도메인과 연동되어있는 네임서버를 AWS의 네임서버로 교체해줘야 한다. 우리가 가비아를 통해서 도메인을 구매하지 않았더라도, 도메인을 구매한 해당 서비스 내 어딘가에는 네임서버를 교체할 수 있는 항목이 있을것이다. 

- 먼저, 가비아 홈페이지에 접속하고 우측상단에 **My가비아** 클릭 -> 그리고 우측에 **도메인 통합 관리툴** 클릭 -> 좌측에 **도메인 정보 변경** 클릭 -> 그러면 우리가 구매한 도메인이 나오는데 해당 도메인을 체크한 다음, 위에 **네임서버**를 클릭 -> 그러면 네임서버 설정 화면이 나오는데, 1,2,3차에 전부 gabia의 네임서버가 연동되어 있는 것을 확인할 수 있는데, AWS route53에서 확인할 수 있었던 NS 유형의 4줄짜리 값들이 위에서부터 순서대로 1,2,3,4차이다. 그런데 각각의 값들의 끝에 점이 있는 것을 확인할 수 있다. 이 맨 끝의 점을 제외한 나머지 값들을 1차부터 4차까지 순서대로 입력해주면 된다. 1차부터 4차까지 순서대로 복사해서 붙여넣고 점을 지우면 된다.
  - 다 입력했다면, 반드시 소유자 인증을 해줘야 한다. 인증이 되었으면 하단에 적용 버튼을 누르자. -> 그래서 AWS의 네임서버 1차부터 4차까지 다 적용이 되었다.

- 다시 AWS Route53으로 돌아와서 레코드 창에 우측을 보면 "레코드 생성"이라는 버튼이 있다. 그 버튼을 누르고 -> 빠른 레코드 생성 화면에서 **마법사로 전환** 버튼을 눌러서 할 수도 있는데 일단 빠른 레코드 생성 화면을 보자. 여기에 레코드 이름을 보면 이미 .xxxx.com은 작성되어있다. 그래서 앞에 붙을 www나 blog 등 우리가 사용하고자 하는 다양한 서브 도메인을 구성할 수 있다. 일단 지금은 가장 기본이 되는 www를 작성하자. 레코드 유형은 A타입 그대로두면 되고 **값 부분에다가 www.xxx.com라는 도메인으로 접속했을 때 어떤 IP로 변환되어야 하는지에 대한 값을 적어주면 된다.** 즉 우리가 지금까지 계속해서 사용했던 EC2 인스턴스의 IP주소를 적어주면 된다. 다 적었으면 우측 하단에 **레코드 생성** 버튼을 눌러주자.

- 그러면 우리가 입력한 내용을 화면으로 확인할 수 있다. 그런데 이렇게 A타입의 레코드를 생성했다고 해서 바로 즉각적으로 반영되는 건 아니고 도메인 종류에 따라 반영되는 시간이 다 다른데 최대 48시간이 걸릴 수 있다. .com 도메인의 경우에는 빨리 반영이 되고 저렴한 도메인은 오래걸릴 수 있다.
  - 이제 브라우저에 해당 도메인 주소를 입력하면 -> Bad Request가 뜬다. 이러한 문제가 발생하는 이유는 SSH로 우리의 EC2 인스턴스 Ubuntu로 접속해서 

```terminal
cd env/
source bin/activate
cd django-sample/
```

- 여기까지 django 프로젝트로 들어온 다음에,

```terminal
vim heestagram/settings.py
```

- settings 모듈을 열어보면 -> ALLOWED_HOSTS에 IP주소만 등록되어 있는 것을 확인할 수 있다. 여기에 우리의 도메인이 등록되어 있지 않기 때문에 안된 것이다. 그래서 해당 부분에
```python
ALLOWED_HOSTS = ['13.xxx.xxx.xx', 'www.xxx.com']
```

- 이렇게 우리의 도메인을 문자열로 등록해주면 된다. 
- 또한 우리가 DEBUG라는 변수를 False로 설정했기 때문에 에러가 발생해도 어떤 이유인지 자세하게 나오지 않는것이다. 보안 상 이게 더 맞다.
  - 그래서 이처럼 django를 development 모드가 아니라 production 모드로 전환한 이후에는 서비스에 어떤 문제가 발생했을 때 우리가 직접 문제를 해결하기가 조금 어렵다. 그래서 server 다양한 기록과 로그들을 보면서 어떠한 문제가 있었는지 직접 확인하고 수정해야 된다. 

- vim 화면에서 이제 esc - :wq로 저장 및 종료를 해주고, 우리가 django 프로젝트 내부에 소스코드를 수정했으니까 gunicorn를 재시작하는 것으로 django server도 재시작해줘야 한다.django가 development 모드일 때만 파일의 내용이 수정되었을 때 자동으로 재시작되는 거지, production 모드에서는 재시작이 자동으로 되지 않는다. 그래서 내용이 변경되었다면 우리가 직접 재시작을 해줘야 한다. 이걸 **서비스 재배포 과정**이라고 생각하면 된다. 
  - 우리는 gunicorn를 Linux 서비스로 등록했기 때문에 

```terminal
sudo service gunicorn restart
```

- 이렇게 입력하고 브라우저 페이지를 새로고침하면 도메인 주소로 접속해도 정상적으로 페이지가 뜨게 된다. 

* * *
### HTTPS 적용을 위한 SSL 인증서 발급
- 그런데, 브라우저 좌측 상단 주소창에 보면 **주의요함** 이라고 뜨는 것을 확인할 수 있다. 아직 SSL 인증서가 적용되지 않아서 HTTPS가 적용되어 있지 않다.
- 그래서 이제 HTTPS까지 적용해서 우리의 서비스를 안전하고 신뢰할 수 있는 사이트로 만들어보자. 이를 위해서는 SSL 인증서를 발급받아야 한다.
- AWS Management Console에서 검색창에 acm이라고 입력해보자. 그러면 Certificate Manager라는 게 뜨는데, 클릭해서 보면 -> 좌측에 **인증서 프로비저닝** 이라는 것을 시작해주자. 
  - 그러면 공인인증서 요청이 클릭되어 있을텐데 그대로 두고 **인증서 요청** 버튼 클릭 -> 도메인 이름 추가 화면에서 HTTPS를 적용하고자 하는 우리의 도메인을 작성해주면 된다. 
  - 이 인증서를 도메인마다 따로 발급해야 하는데, 예를 들어 www.example.com, site.example.com, images.example.com 등 서브 도메인이 엄청 많은 경우에 이 각각의 도메인에 대해서 다 인증서를 원래는 발급받아야 한다. 이게 원칙적으로 제일 안전하고 정석적인 방법이다.
  - 서브 도메인이 엄청 많을 경우에는 다 따로 발급받고 관리하기가 어려우니까 asterisk(*) 즉, 와일드카드라고 부르는데 **와일드카드 인증서**라고 해서 발급받을 수도 있다.
  - 발급받기 위해서는 www로 작성하지 않고 그냥 별표 *을 사용해서 *.xxx.com 이렇게 도메인 이름을 설정해주면 된다. 우리는 www.xxx.com으로 작성하자. 작성했으면 우측에 다음을 클릭하자.
  - 그 다음에는 **검증 방법 선택** 화면이 나온다. 해당 도메인이 우리의 소유임을 입증해야 한다. 이메일 검증을 눌러서 다음을 누르고 태그 추가 화면은 그냥 검토 버튼 눌러서 넘기자. 마지막으로 검토 화면에서 **확인 및 요청** 을 누르게 되면 AWS에서 메일이 날아갈 것이다. 
  - 그 메일 속에있는 링크를 클릭하면 웹 페이지가 하나 뜨는데, **I Approve**라는 버튼을 눌러서 승인을 해줘야지만 인증서가 정상적으로 발급된다. 
  - 그리고 다시 AWS화면으로 가서 계속을 누르면 해당 도메인에 대한 인증서가 정상적으로 발급된 것을 확인할 수 있다.

- 이렇게 되면 끝인데, 안되는 사람들도 있다. 검증 방법 선택화면에서 **DNS검증**을 클릭해서 확인 및 요청까지 눌러보자. 그러면 검증이라는 화면에서 "DNS구성에서 아래에 나열된 각 도메인에 대해 CNAME 기록을 생성합니다" 이런 메세지가 뜬다. 그리고는 검증 보류 라고 뜬다. 세모 버튼을 눌러서 펼쳐보면, "사용자 도메인의 DNS 구성에 다음 CNAME 기록을 추가합니다" 라고 되어있다. AWS 얘네가 추가해준다는 게 아니라 우리가 추가하라는 소리이다.
  - **"너가 이 도메인의 소유주라면 내가 지금 부탁한 이 값들을 지금 너가 추가할 수 있을꺼야.. 그래서 너가 route53으로 가서 지금 내가 요청한 다음과 같은 값들을 지정할 수 있고 지정해놨다면 내가 주기적으로 체크하면서 값이 지정되어 있을 때 인증서를 발급해줄께"** 이런 의미인 것이다. 그래서 지금 페이지는 그대로 두고, 새로운 AWS 탭을 열어서 Route53 대시보드로 간 다음에 호스팅 영역 -> 우리 도메인을 클릭해서 상세페이지로 이동하자.
  - 지금 레코드가 3개 밖에 없는데 여기에 CNAME 타입의 레코드를 하나 더 추가하라는 소리이다. 그래서 우측에 레코드 생성 -> 그 다음 레코드 유형을 A타입이 아니라 CNAME 타입을 클릭하고 레코드 이름과 값에다가 아까 화면에서 가이드하는 값을 그대로 붙여주면 된다. 그런데 가이드하는 값 중 이름은 -> 마지막에 .xxx.com.은 뺀 문자열만 입력하는 것이다. 왜냐면 이미 오른쪽에 해당 부분이 작성되어 있기 때문이다. 
  - 그리고 값도 그냥 복사해서 붙여넣어주면 된다. 레코드 생성 주황색 버튼을 눌러서 CNAME 타입의 레코드를 생성해주자.
  - 생성이 되었으면 이제 AWS가 주기적으로 이 값을 체크하면서 체크가 완료된 시점에 SSL 인증서를 발급해준다. 시간이 조금 걸릴 수 있다. 그래서 돌아와서 계속 버튼을 누르면 아직 검증 보류라고 뜨는데, 새로고침을 계속하다보면 **발급완료** 라고 뜨면 된 것이다.


### Load Balancer 생성 및 HTTPS 적용 
- 여기까지 AWS ACM를 통해서 SSL 인증서를 발급받았다면 마지막으로 load balancer를 생성하고 load balancer의 SSL 인증서를 적용한 다음 우리의 EC2 인스턴스를 연결해주는 것으로 서비스 배포의 모든 절차를 마무리해보자. AWS Management Console에서 EC2 대시보드로 이동하자. load balancer는 EC2 대시보드에서 생성할 수 있다. 좌측 메뉴에서 스크롤을 맨 아래로 내리면 **로드 밸런싱 - 로드 밸런서**가 있다. 
  - 클릭해보면, 화면이 뜨고 파란색 load balancer 생성 버튼을 클릭하자. 그리고 맨 좌측에 있는 Application Load Balancer 생성 버튼을 눌러주자. 
  - 그리고 뜬 화면에서 이름설정은 적당히 지어주면 되고, xxx-LB 이런식으로 하자. 보통 Load Balancer를 LB라고 한다. 그리고 체계, IP주소유형은 건드릴 필요가 없다.
  - 그 다음 **리스너** 라는 부분에서 HTTP가 아니라 HTTPS로 변경해주자. HTTP가 기본적으로 80포트를 사용했다면 HTTPS는 기본적으로 443포트를 사용한다.
  - 그 다음 하단에 **가용 영역** 부분이 있는데 AWS에서 가용영역이란, 우리가 AWS를 쓰는 이유는 AWS의 인프라가 굉장히 훌륭하기 때문에 우리는 여기에 가상으로 입주하기 위해서 AWS를 쓰는 것이다. 하지만 AWS가 아무리 훌륭하고 아무리 견고한 인프라를 갖추고 있다고 하더라도 AWS의 데이터 센터에 폭탄이 떨어진다면 AWS에 의존하고 있던 서비스들은 전부 다 장애가 발생하게 된다. 서비스에 아예 들어가지도 못한다. 아무것도 못하는 상태가 된다. 
  - 그래서 이렇게 최악의 경우를 막기 위해서 AWS는 데이터 센터조차 여러 군데로 분리해서 관리하고 있다. 그래서 서비스의 규모가 점점 커짐에 따라서 더 많은 server를 필요로 할텐데 이 모든 server들을 하나의 데이터 센터에 몰아넣는 것이 아니라 여러 곳의 데이터 센터에 골고루 분산시켜 놓고 이 모든 server들을 하나의 load balancer로 묶어서 사용한다면 설령 데이터 센터 중에 일부 데이터 센터에 문제가 발생하더라도 load balancer라는 장치 자체가 load balancer에 연동되어 있는 장치 중에 일부 장치에 문제가 발생하면 더 이상 그쪽으로 트래픽을 전송하지 않고 멀쩡한 server들에게 트래픽을 추가로 분배해준다. 그래서 이러한 개념으로 사용되는게 바로 **가용 영역** 이라고 하는 것이다.
  - **AWS 서울 region 기준으로는 a,b,c,d 총 4개의 가용 영역이 있는데 EC2 인스턴스 화면 하단의 네트워킹 탭을 눌러보면 -> 우리의 EC2 인스턴스가 a,b,c,d 중에 어디에 배치되었는지 확인할 수 있다. 기본적으로는 랜덤하게 자동으로 배치가 되는 것이다.** 근데 우리가 비용을 더 내고 가용 영역 여러 곳에 걸쳐서 골고루 server를 분배할 수도 있다. 

- 그래서 다시 화면으로 돌아가보면, 가용 영역을 전부 다 체크해주자. 해당 화면을 보면 load balancer는 지정한 가용 영역에 위치한 대상으로만 트래픽을 라우팅한다고 되어있는데 그냥 다 체크하면 속 편하게 이후에 server를 추가할 때 바로 추가만하고 사용할 수 있다. 다 체크하셨다면, 우측 하단에 **다음:보안 설정 구성** 버튼을 눌러주자. 
  - 그리고 HTTPS를 적용하기 위해서 인증서 유형을 선택해줘야 하는데 우리가 ACM으로 인증서를 만들어줬기 때문에 ACM에서 인증서 선택이 이미 체크되어 있을 것이다. 인증서 이름 부분도 우리들이 발급받았던 인증서가 선택되어 있는 것을 확인할 수 있다. 우측 하단에 **다음:보안 설정 구성** 버튼을 누른다.
  - 그 다음에 보안 그룹 구성 화면에서 "새 보안 그룹 생성"을 클릭하고 보안 그룹 이름은 xxx-LB-SG 이렇게 설정. (Load Balancer Security Group) 설명부분도 똑같이 작성한다. 
  - 유형은 HTTPS를 선택해서 HTTPS로만 접근할 수 있게끔 설정해주자. 우측 하단에 **다음:라우팅 구성**을 누르자.
  - 이제 load balancer가 어떠한 EC2 인스턴스와 연동을 할지 그룹을 생성해주는 화면이 나온다. 이름을 xxx-LB-GROUP 이렇게 지정하자. 대상 유형은 인스턴스에 체크해주면 된다. 프로토콜은 HTTP 선택되어있는 상태로 그대로 두면 된다. 즉 load balancer가 서비스 사용자인 client와 통신할 때 프로토콜을 지정하는 것이 아니라 load balancer가 실제로 트래픽을 분배할 때, 우리의 EC2 인스턴스와 통신할 때 어떤 프로토콜을 사용할지를 지정하는 것이라고 보면 된다. 그래서 HTTP 80포트 / HTTP1 체크되어 있는 것 그대로 두면 된다.
  - 상태검사 부분은 HTTP 경로는 /로 그대로 두면 된다. **상태 검사란, load balancer가 해당 load balancer에 등록되어 있는 인스턴스들을 주기적으로 체크하게 된다. 멀쩡한지 죽었는지 건강을 계속해서 체크한다.** 이걸 이제 **헬스 체크**라고 하는데 헬스 체크를 어떠한 url pattern으로 하면 되는지를 작성해주는 것이다. 그래서 우리는 경로를 /로 해주었는지 그냥 메인 랜딩 페이지를 보겠다는 것이다. 메인 랜딩 페이지 체크했는제 정상적으로 뜨면 멀쩡한 server이고 페이지가 제대로 안뜨면 죽은 server인 것이다. 다 되었으면 우측 하단에 대상 등록을 클릭.
  - 이제 우리가 만든 LB-GROUP이라는 그룹에다가 우리가 실제로 사용하고 있는 EC2 인스턴스를 체크하고 80포트를 기준으로 등록된 항목에 추가라는 파란색 버튼을 눌러주면 -> 상단에 등록된 대상에 인스턴스가 추가 된다. 이렇게 하면 우리가 가지고 있는 EC2 인스턴스를 하나 등록해준 것이다.

- 우리의 서비스 규모가 커져서 더 많은 인스턴스가 필요하다면 하단에 인스턴스 목록에서 load balancer로 묶어서 관리하고자 하는 인스턴스들만 잘 선택한 다음 load balancer 대상 그룹에다가 EC2 인스턴스를 등록해주면 된다. 필요하다면 다시 빼줄수도 있다. 여기까지 했으면 우측 하단 "다음:검토" 버튼을 누르자. 그리고 지금까지 설정했던 것들을 쭉 살펴보고 우측 하단에 생성을 클릭.
- 그러면 드디어 load balancer 생성 완료가 뜨는 것을 확인할 수 있다. 닫기 버튼을 마지막으로 누르기.

- AWS Management Console로 가서 Route53 대시보드로 다시 가주자. 호스팅 영역 - xxx.com 클릭해서 보면, **우리가 처음에는 www.xxx.com이라는 도메인으로 접속했을 때 우리가 설정한 IP주소와 매핑이 되어서 사용될 수 있게끔 설정을 해줬는데 이렇게 사용하는 건 서비스 이용자인 client가 EC2 인스턴스에 직접적으로 붙어서 통신을 하는 것에 해당한다.**
  - **우리는 이제 서비스 이용자가 EC2 인스턴스에 직접 붙는 게 아니라, load balancer와 통신을 하고 load balancer가 EC2 인스턴스와 통신을 할 수 있게끔 만들어줘야 한다.** 
  - 그래서 지금까지 load balancer에 대한 내용은 다 작성하고 실제로 생성까지 완료가 되었으니 **마지막으로 남은 건 www.xxx.com이라고 접속했을 때 -> IP 주소와 연동되는 것이 아니라 load balancer와 연동이 되게끔 설정을 변경해주면 된다.**
  - 그래서 A타입 레코드를 선택한 다음에 레코드 편집을 눌러주면 A 타입인데 값 부분에 "별칭"이라는 게 있다. 이 부분 스위치를 켜주면 "트래픽 라우팅 대상"이라고 해서 엔드포인트를 선택할 수 있는데 목록에서 "Application/Classic Load Balancer에 대한 별칭" 이라는 것을 선택해주자. region은 "아시아 태평양(서울) [ap-northeast-2]" 를 선택한다. 그리고 로드 밸런서 선택은 검색창을 클릭해보면, 자동완성 옵션으로 우리가 생성한 load balancer가 보인다. 이걸 클릭하고 저장을 누르면 된다.
  
- 그러면 이제 www.xxx.com 이러한 도메인을 클릭했을 때 load balancer와 연동이 되게끔 설정이 된 걸 확인할 수 있다.
  - 이제 다시 브라우저로 가서 새로고침을 해보면, 로딩이 계속 되는데, http가 아니라 https://www.xxx.com 이렇게 HTTPS 주소로 입력하게 되면 -> 이제 도메인 왼쪽에 자물쇠가 생긴 것을 확인할 수 있고 클릭해보면 "이 사이트는 보안 연결(HTTPS)이 사용되었습니다." 라고 메세지가 뜨는 것을 확인할 수 있다. 
  - 하단에 "인증서" 라는 걸 클릭해보면 Amazon이 발급했고 언제까지 유효하다고 나온다.

* * *
- 만약 AWS를 더이상 쓰지 않아서 비용이 발생하는 걸 막기 위해서는 연동되어있는 레코드, 우리가 추가해줬던 레코드들도 전부 삭제해줘야 한다. 체크하고 "레코드 삭제"를 누른다. 그리고 그 화면에서 호스팅 영역도 삭제해줘야 하니까 상단에 "영역 삭제"를 클릭한다.
- 그리고 AWS Management Console에서 EC2로 간 다음에 load balancer도 더이상 사용하지 않는다면 -> 작업 버튼 누르고 삭제를 클릭하면 된다.
- 그리고 로드밸런싱 - 대상 그룹 버튼을 클릭해서 추가했던 대상 그룹도 체크해서 Actions - Delete를 누르자.
- 마지막으로 EC2 대시보드에서 실행중인 인스턴스를 클릭하고 체크해서 인스턴스 상태 - 인스턴스 종료를 클릭.
- 그리고 EC2 - 네트워크 및 보안 - 보안 그룹으로 가서 더 이상 사용하지 않는 보안 그룹들도 체크해서 작업 - 삭제를 클릭.


