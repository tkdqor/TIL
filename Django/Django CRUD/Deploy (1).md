## Deploy (1)
- 지금까지는 컴퓨터 개인 환경, 로컬 환경에서 django를 사용해 웹 서비스를 개발하는 방법에 대해서 배웠다.
- 서비스를 배포하기 위해서는 365일 항상 전기를 공급받을 수 있고 항상 안정적인 네트워크에 접속할 수 있는 환경이 필요.
  - 이를 위해서 과거에는 IDC라고 하는 Internet Data Center에 우리의 server 컴퓨터를 입주시켜야 했다. 우리가 개발했던 django와 같이 server용 프로그램이 돌아가는 컴퓨터는 모니터도 필요없고 연산만 빠르게
    처리하면 된다. 
  - 문제는 개인이나 소규모 스타트업의 경우 서비스 규모도 자주 바뀌게 되고 그 때마다 컴퓨터 하드웨어를 매번 구입할 수도 없다. 컴퓨터 하드웨어 전문가가 아닌 이상 이런 server를 직접 구축하고 IDC에 입주하는 것 자체가 
    굉장히 어렵고 오래걸리는 작업이다.
    
- 하지만, 이러한 문제는 아마존의 AWS를 비롯해서 Microsoft의 Azure 등 다양한 클라우드 서비스가 나타나면서 자연스럽게 해결되었다. 그래서 우리는 이제 가상의 컴퓨터를 발급받아서 실제 IDC에 입주한 것처럼 사용할 수 있게 되었다.
  - **아마존의 EC2**는 Amazon Elastic Compute Cloud의 약자로 AWS에서 제공하는 가장 기본적인 컴퓨팅 유닛이다. 아마존으로부터 실제 컴퓨터처럼 사용가능한 가상 컴퓨터를 발급받을 수 있다. 
  - 우리는 EC2를 사용해 365일 항상 django가 동작할 수 있는 server로 사용할 수 있다.

- 이러한 EC2 server내에 django를 우리에게 익숙한 development 모드 server의 형태로 구성하면 -> server 내에 django가 설치되어 있고 DBMS도 디폴트인 SQLite를 그대로 사용하게 된다. 이 형태로 
  사용자에게 웹서비스를 제공할 수도 있지만 server가 교체되거나 우리의 프로젝트 소스 코드를 재배포하는 과정에서 파일 DB인 SQLite 파일이 삭제될 경우, 서비스 데이터가 보존되지 않는다는 단점이 있다.
  - 그래서, django가 돌아가는 server 외부에 PostgreSQL과 같은 production에 적합한 고성능 RDBMS를 분리해서 사용하는 게 바람직한 구조이다.
  - 하지만, 여전히 django development 모드의 server는 다수의 트래픽을 처리하는 데 있어 안정성이나 퍼포먼스 측면에서 적합하지 않다.


### Production 환경
- 그래서 Production 환경에서는, 일반적으로 **gunicorn이라는 별도의 프로그램을 사용**한다.
  - 해당 프로그램은 server 리소스를 활용하여 퍼포먼스를 증대시킴과 동시에 django 프로세스를 모니터링하고 고가용성을 도모할 수 있게 한다.

- 그리고 **web server인 nginx를 추가로 사용**해서 static 파일과 관련된 처리는 nginx가, 그 외의 나머지 트래픽은 gunicorn를 통해 django가 대신 처리할 수 있게끔 전달해줘서 조금 더 안정적으로 트래픽을 처리할 수 있게끔 만들어줄 수 있다.
  - ex) **<nginx(웹서버) -> gunicorn(WSGI) -> django(EC2 server, 즉 앱서버)> -> RDBMS (Production 환경에 적합한 구조)**
    - <...> 이렇게 표시한 3개는 실습에서 하나의 EC2에 모두 설치했음

- 이 상태에서 우리의 웹서비스가 더욱 성장해서 훨씬 더 많은 트래픽이 발생한다면 어떻게 될까? 우리의 서비스가 커질수록 EC2 server 한 대로는 감당하기 어려워진다.


### ELB(Elastic Load Balancer)
- 그래서 필요한 것이 바로, ELB(Elastic Load Balancer)이다. 
- 우리가 웹 서비스를 이용하는 과정에서 발생하는 데이터 통신들, 그러한 통신의 교통량을 우리는 트래픽이라고 부르는데 server는 그러한 트래픽을 열심히 처리해야하고 server 입장에서 이 트래픽은 처리해야 할 짐 덩어리이다.
  - 트래픽이 많으면 많을수록 server 입장에서는 부하, 즉 load가 걸리게 된다. 아무리 비싸고 좋은 server 한 대를 사용한다 할지라도 언젠가는 모든 트래픽을 혼자서 처리하기 어려운 시점이 온다.
  - 이러한 시점이 우리 웹서비스가 한단계 더 성장하는 계기가 되는데, server는 터지고 서비스는 장애가 발생하고 혼란스럽겠지만 그만큼 우리 서비스를 이용하는 사용자가 늘었다는 증거이기도 하다.

- 그래서 이럴 때는 트래픽을 server 한 대가 전부 다 받아서 처리하는 것이 아니라 -> 여러 대의 server를 두고 트래픽을 여러 대의 server로 골고루 분산시켜서 트래픽을 좀 더 효율적이고 안정적으로 처리할 필요가 있다.
  - 이러한 용도로 사용되는 장치, 문자 그대로 load를 분산시켜서 균형, balance를 맞춰주는 장치를 우리는 load balancer라고 부른다.

- 이 load balancer는 트래픽을 한 곳에서 받아서 여러 server에 분산시킬 목적으로 사용하는 장치이고 AWS에서는 load balancer로 ELB, Elastic Load Balancer라는 것을 제공한다.
  - **ex) client -> ELB -> EC2 여러 대**
  - 이렇게 EC2 여러 대를 사용해서 server 클러스터를 구축한 다음, 모든 서비스 트래픽을 ELB가 앞단에서 먼저 받고 클러스터 내의 server들에게 트래픽을 골고루 분산시켜준다. 즉, 클러스터 내에 server가 n대 있다면 각 EC2 인스턴스는 트래픽을 약 n분의 1만 받게 된다. 
  - 이러한 구조에서는 우리의 서비스가 성장하면서 트래픽이 늘어남에 따라 단순히 server를 추가해주는 것만으로도 계속해서 더 많은 트래픽을 감당할 수 있게 된다. 우리가 사용하고 있는 대부분의 웹 서비스들이 다음과 같은 형태로 10만 유저, 100만 유저 이상을 안정적으로 처리하고 있다.


### HTTPS
- 지금까지 우리가 배운 방식은 전부 HTTP 기반이었다. 하지만, 요즘은 모든 웹서비스가 보안을 위해서 HTTPS를 사용한다. **HTTPS는 HTTP over Secure Socket Layer의 약자로 그냥 일반 HTTP보다 보안이 강화된 것이라고 생각하면 된다.**
- 우리가 지금까지 사용했던 일반 HTTP는 보안에 굉장히 취약하다. 그 이유는, HTTP에서는 모든 통신이 암호화되어 있지 않은 상태로 전송이 되기 때문에 아주 쉽게 원문을 들여다 볼 수 있기 떄문이다.
  - HTTPS는 HTTP 통신이 암호화된 상태로 전송이 되기 때문에 내용을 들여다봐도 무슨말인지 모르게 되어서 더욱 더 안전하다. HTTPS를 적용하지 않은 웹 페이지에 사용자가 접근할 경우, 브라우저 레벨에서 "연결이 비공개로 설정되어 있지 않습니다."라는 경고를 띄우게 된다. 우리가 힘들게 만든 웹 서비스를 배포해서 자랑하기 위해 링크를 보냈는데, 링크를 누르자마자 다음과 같은 경고를 띄운다면 안 된다.

- **그래서 HTTPS는 선택이 아니라, 반드시 적용해야 한다. 그런데 단일 컴퓨터 구조에서는, nginx라는 web server에 SSL 인증서라는 걸 설치하는 것만으로도 HTTPS를 적용할 수 있다.**
  - 하지만, django server가 여러 대가 있는 클러스터 환경에서는 server가 100대라면 100대에 모두 인증서를 설치하고 HTTPS를 적용해야 할텐데, 엄청 번거롭고 귀찮다. 또한, 인증서가 만료기간이 있기 때문에 주기적으로 갱신을 해야된다. 
  - **다행히 TLS termination이라는 기법이 있는데, 이와 같이 load balancer가 모든 서비스 트래픽을 앞단에서 먼저 받는 구조에서는 -> load balancer에서 HTTPS 통신을 담당하고 이후 load balancer가 EC2에게 트래픽을 분산시킬 때에는 HTTP로 전달할 수 있다. 어차피 실제 client들은 load balancer를 통해서만 웹 서비스를 이용할 수 있고 load balancer 뒷단의 부분은 서비스 개발자만 접근할 수 있기 때문에 굳이 암호화를 할 필요가 없기 때문이다.**
  - **그래서 우리는, ELB에만 인증서와 함께 HTTPS를 설정하면 되고 나머지는 마치 우리가 로컬에서 개발했던 것처럼 HTTP 기반으로 트래픽을 처리할 수 있게 되는 것이다.** 우리는 실습할 때 이러한 구조를 사용해보자. 실습 때는 EC2를 여러 대 사용하는 것이 아니라 1대만 사용해보자. (만약 서비스가 커지면 load balancer에 server만 추가로 등록해주면 된다)


### 도메인 구매
- 먼저 서비스를 배포하기 전에 우리의 서비스 사용자가 www.heeham.com 이런식으로 도메인을 통해서 서비스에 접속할 수 있게끔 우리만의 도메인이 필요하다. 그래서 배포전에 도메인을 먼저 구매하자.
  - https://www.gabia.com/ 여기서 도메인 구매 가능.


### 실습 진행
- 구매하고나서 이제 AWS에서 EC2 인스턴스를 발급받고 세부 구성요소를 설치하기.
  - AWS에서 로그인하고 management Console로 와서 우측 상단에 지역을 클릭하고 아시아 태평양(서울)로 선택해주기.
  - 그리고 이제 AWS에서 server로 사용할 컴퓨터를 발급받아야 한다. 가장 기본 컴퓨팅 단위인 EC2 인스턴스를 발급받아보자.

- 검색창에 EC2라고 입력한 다음, 링크를 누르자. 그러면 EC2 대시보드라고 해서 EC2와 관련된 모든 것들을 할 수 있는 화면이 뜬다. 현재 실행 중인 인스턴스를 0개로 뜨고, 우리가 인스턴스를 발급받을 때마다 이 숫자가 올라가게 된다. 하단에 인스턴스 시작이라는 주황색 버튼을 눌러서 시작해보자.
  - 이제 EC2라는 가상의 컴퓨터에 어떠한 운영체제를 설치해서 사용할지를 결정하는 화면이 뜬다. **주로 server 컴퓨터는 Linux 운영체제**를 사용한다. 이 Linux의 종류로도 여러 가지가 있는데 우리는 여기서 **Ubuntu**를 사용할 것이다. 그 중에서 Ubuntu Server 20.04 LTS 버전을 사용하자. 우측에 선택 버튼을 클릭하자.

- 운영체제를 선택한 다음에는 <인스턴스 유형 선택>이라고 해서 해당 server의 스펙을 선택하게 되는데, 몇개의 CPU를 사용할지, 메모리 용량은 어떻게 결정할지 스토리지나 네트워크 성능은 어떤 걸 쓰고 싶은지 결정할 수 있다. AWS EC2에서는 t2.micro 인스턴스를 프리 티어 형태로 제공하는데 즉, 인스턴스를 한 달 내내 사용했을 때 과금이 되지 않는 것을 의미한다. 무료 체험판 같은 것이다. 하지만 이건 오직 프리티어 인스턴스를 1개만 사용할 때이다. 우리가 server를 여러 개 사용하거나 EC2이외에 다른 서비스를 같이 사용할 경우에는 과금이 될 수 있으니까 주의해야 한다. 기본적으로는 t2.micro가 선택되어 있고 이 상태에서 하단에 "검토 및 시작"을 눌러주자. 

- 그러면 최종적으로 EC2 인스턴스를 생성하기 전에 설정에 대한 요약본이 나온다. 여기서 추가로 오른쪽에 나와있는 "보안 그룹 편집" 버튼을 클릭하자. 처음에는 보안 규칙에 SSH로 22포트로 추가되어 있는데, 이 SSH가 있어야 우리가 터미널을 통해서 우리가 만든 이 가상 server에 접근할 수 있으니까 해당 규칙은 건드리면 안된다. 이 보안 그룹 페이지에서는, 우리의 EC2 인스턴스에 어떠한 IP 대역에서 어떠한 프로토콜로 어떠한 포트를 사용해 들어올지 컨트롤 할 수 있다.
  - 좌측 하단에 "규칙 추가" 버튼을 누르고 HTTP를 선택해 포트 범위를 80으로 설정 / 규칙 추가를 한번 더 누르고 사용자 지정 TCP를 그대로 두고 포트 범위를 8000번이라고 작성해서 8000번 포트도 열어주자.
  - 상단에 "보안 그룹 이름"과 "설명"도 적당히 지어준다.
  - 그리고 소스 라는 부분에서 요청 주체인 IP 대역까지 컨트롤할 수 있는데 우리는 일단 0.0.0.0/0을 통해서 모두에게 오픈한다. 여기까지 보안 그룹 구성이 완료되었다. 우측 하단에 "검토 및 시작" 버튼을 눌러서 최종 요약 페이지로 다시 이동한 다음, 마지막으로 우측 하단에 "시작하기" 버튼을 누르자.
  - 새로운 EC2 인스턴스를 발급받는 최종단계로 EC2 인스턴스에 접속할 때 반드시 필요한 비밀키인 pem키를 생성하게 되는데, 이 키는 이후에 우리가 EC2 인스턴스에 SSH라는 프로그램을 통해 접속을 할 것인데 그 때 반드시 필요하다. 이 pem키가 있는 사람만 SSH를 통해서 EC2에 접속할 수 있다. 따라서 이 키는 내부적으로 우리만 알고 있어야 하고 -> Github의 public repository와 같은 오픈된 공간에는 절대 공유되어서는 안된다. 이 pem키만 노리고 있는 crawler가 엄청 많다고 한다. 그래서 github은 private repository만 사용하고 pem키는 웬만해서는 올리지 말자.
  - 예전에 AWS를 사용해서 이미 과거에 만들어 둔 키가 있는 경우, 기존 키를 재활용해서 사용할 수도 있고 키를 처음 만드는 경우, "새 키 페어 생성" 을 선택하고 이름을 지정해야 한다. 키 이름을 정하고 다운로드 버튼을 눌러주자. 그리고 하단에 "인스턴스 시작" 버튼을 눌러서 인스턴스를 초기화해준다. 그 다음 페이지에서는 우측 하단에 "인스턴스 보기"를 클릭한다.

- 위의 과정을 거치면, 새로운 인스턴스가 생성되게 된다. 우리가 AWS를 이용할수록 다양한 server가 추가될 것인데, 각각의 EC2 인스턴스가 어떤 서비스와 관련된 인스턴스인지를 파악할 수 있어야 되니까 Name 부분을 클릭해서 인스턴스의 이름을 정해준다. 만약 해당 서버를 더이상 사용하고 싶지 않다면, 비용 때문에 삭제하고 싶다면 해당 인스턴스를 체크한 다음 상단에 "인스턴스 상태"를 클릭하고 "인스턴스 종료"를 누르면 된다. 여기서 "인스턴스 중지"는 동작이 잠시 멈출 뿐, 계속 server가 살아있는 상태라서 비용이 계속해서 나가게 된다.
  - 인스턴스를 클릭한 상태에서, 하단에 세부 정보를 보면 -> 인스턴스 요약이라는 부분에 인스턴스와 관련된 정보들이 다양하게 나와있다. 여기서 중요한 부분은 **"퍼블릭 IPv4 주소" , "퍼블릭 IPv4 DNS"이다.** 이 DNS가 해석이 되면 내부적으로는 퍼블릭 IPv4 주소에 나와있는 IP가 된다는 것이다. 퍼블릭 IPv4 주소를 복사해서 브라우저에 입력해보면 -> 사이트에 연결할 수 없다고 나온다.
  - **이제 이렇게 만든 EC2 인스턴스 -> 즉, 가상에 컴퓨터에 우리가 접속해서 python도 설치하고 / django도 설치하고 필요한 것들을 하나하나 설치한 다음에 server까지 구동시켜 주어야지 웹 서비스를 이용할 수 있게 되는 것이다.**

* * *
### 인스턴스 접속 및 연결
- 해당 인스턴스를 클릭한 상태에서 상단에 "연결" 버튼을 누르게 되면 -> 해당 인스턴스에 접속할 수 있는 다양한 방법을 가이드해준다. 여기서 우리는 **"EC2 인스턴스 연결" 과 "SSH 클라이언트" 방법**을 살펴볼 것이다.
- 먼저 **EC2 인스턴스 연결**은, 별도의 프로그램 설치 없이 그냥 연결 버튼을 누르면 -> 브라우저에서 가상으로 터미널을 연동해서 해당 EC2 인스턴스로 접속해준다. 최근에 추가된 기능으로 편리하지만, 가끔 먹통이 되는 경우가 있어 추천되지 않는다.
- **SSH 클라이언트 탭**을 누르고 SSH 클라이언트 라는 것을 통해서 원격에 있는 server에 접속하는 방식이 더 일반적인 정석 방식이라고 할 수 있다. 이 방식으로 접근하기 위해서는 먼저 SSH 클라이언트라는 것이 필요한데, Mac의 경우에는 이미 터미널에 설치가 되어있다. windows의 경우에는 기본적으로 설치가 되어있지 않기 때문에 별도의 SSH 클라이언트를 설치해줘야 한다. 만약 Gitbash를 사용하고 있다면 이 안에 SSH 클라이언트가 내장되어 있기 때문에 그대로 사용하면 된다.

- 그래서 일단, 터미널을 열어주고 인스턴스를 시작하는데 필요한 키는 **설정한이름.pem** 이라는 키이다. 그래서 cd 명령어를 통해 터미널에서 해당 pem 키가 있는 곳까지 이동해주자.
  - ex) cd Downloads/

- 그리고 **chmod 400 키이름.pem** 이라는 명령어를 통해서 해당 pem 키를 readonly로 만들어준다. 이 명렁어는 처음 한 번만 하면 되고 이후에는 굳이 할 필요가 없다. 나와있는 명령어를 그대로 복사하고 터미널에서 실행해주자.

- 마지막으로 퍼블릭 DNS를 사용해서 인스턴스에 연결한다. 퍼블릭 DNS는 아까 우리가 EC2 상세정보에서 확인했었던 그 DNS이다. 이 DNS 주소를 활용해서 -> 아래에 나와있는 ssh -i "키이름.pem" 즉, SSH라는 client 프로그램을 사용해서 원격에 있는 server에 접속을 할 것인데 접속할 때 그 문을 여는 키로써 해당 pem 키를 사용할 것이다.
  - 그리고, **ubuntu@퍼블릭DNS주소** 가 되어있는데, 나는 퍼블릭 DNS 주소를 가진 EC2 인스턴스, 그 server에 ubuntu라는 유저로 접속할거야 라는 의미가 된다. 그대로 복사해서 -> 터미널에 붙여넣고 엔터를 해서 실행해주면 -> 처음 접속할 때만 경고가 뜨게 된다. 해당 경고는 "지금 이 host를 처음 보는 건데 진짜 접속할꺼야?" 라고 물어보는 것이다. 그래서 yes라고 입력해주면 들어가면 된다.
  - 그러면 welcome to Ubuntu라는 메시지와 함께 현재 시스템의 상황이 간단하게 보여지고, 터미널 입력 부분에도 ubuntu@IP주소 이렇게 바뀌면서 -> 우리가 현재 ubuntu라는 계정으로 로그인이 되어 있구나라는 것을 확인할 수 있다. 

- **우리가 Windows나 Mac에서 컴퓨터 처음 켜면 계정이 뜨고 비밀번호를 입력해서 로그인을 하듯이 -> Linux에도 계정이 있고 / EC2는 기본적으로 Ubuntu 운영체제를 사용하면 ubuntu라는 계정을 만들어주게 된다.** 그래서 ubuntu라는 계정으로 로그인을 하는 것이다. 여기까지 EC2를 발급받는 게 모두 완료되었다. SSH를 통해서 원격으로 접속한 이 EC2에서 빠져나올 때는 -> exit 이라고 입력하면 logout이 되면서 빠져나오게 된다. 그리고 원래처럼 우리 개인 컴퓨터의 터미널 화면으로 돌아온다.

- 만약에, 다시 EC2 server로 접속하고 싶다면 -> 아까 접속할 때 마지막에 입력했던 ssh -i "pem키" ubuntu@퍼블릭 DNS 주소 -> 이 명령어만 터미널에 다시 입력해주면 된다. 그러면 ubuntu Server에 다시 접속할 수 있다. 
  - 그런데, 이 명령어를 항상 외우고 다닐수는 없을텐데, 그럴떄는 AWS에 접속해서 AWS Management Console에서 EC2를 검색한 다음 EC2 대시보드에서 "실행중인 인스턴스" 링크를 눌러서 현재 실행 중인 인스턴스를 확인할 수 있고, 여기서 우리가 접속하고자 하는 인스턴스를 체크한 다음 "연결" 버튼을 누르면 -> 접속하는데 필요한 명령어를 다시 확인할 수 있다.

* * *
- 지금까지 가상 컴퓨터를 발급받는 건 모두 끝났고, 이 server에 python, django, nginx, gunicorn이라는 각종 프로그램을 설치하기만 하면 된다.
  - 문제는 Linux를 처음 사용해보는 것이고, 설치해야 하는 프로그램도 많은데 수많은 명령어들을 복사해서 터미널에 한줄씩 다 입력해줘야 한다.
  - 그래서 이러한 코드들이 자동으로 순서대로 실행되게끔 스크립트 파일로 만들어두었다. log ... 이러한 코드를 제외하고 나머지 코드들은 다 실제 프로그램을 설치하는데 필요한 코드들이다. 
    - sudo timedatectl set-timezone 'Asia/Seoul' -> 해당 코드는 서버의 시간대를 한국 시간대로 설정해주는 것이고, server에 이미 설치되어있는 기본적인 프로그램들을 최신 버전으로 업데이트 시켜준 다음 이후에 우리가 직접 설치할 프로그램들이 정상적으로 동작하기 위해 필요한 환경 변수나 설정값들을 저장할 수 있는 bash_profile이라는 파일을 생성해주는 코드를 입력하게 된다.
    - 그 다음에는 Ubuntu에 python를 설치할 것인데 pyenv라는 프로그램을 통해서 python를 설치할 것이다. pyenv로 python를 실제로 설치하는데 필요한 각종 프로그램들도 설치한 다음 최종적으로 pyenv를 통해서 pytohn 3.9.2버전을 설치한다.
    - 그 다음 밑에는, nginx라는 web server를 설치하는 코드가 있다. 그래서 python를 다 설치하면 python의 venv 모듈을 통해서 홈 디렉터리에 env라는 가상환경을 위한 디렉터리를 만들어준다. 그리고 그렇게 만든 env 디렉터리 내부로 이동한 다음, python package installer인 pip를 업그레이드 해주고 django를 설치한다. 추가로 이미지 업로드를 위해서 Pillow를 설치하고 API 통신을 위해서 requests를 설치해준다. 그리고 마지막으로는 gunicorn이라는 라이브러리도 pip를 통해서 설치해준다.
    - 그래서 설치가 모두 완료되면 installation Successful이라는 메세지가 터미널에 출력된다. 이러한 많은 명령어들을 한 줄 한 줄 복사해서 터미널에 입력할 필요는 없고, https://github.com/heeham/ubuntu-django-deploy -> 해당 github에 있는 ubuntu-django-deploy라는 github repository에 가서 README에 있는 source로 시작하는 명령어 한 줄을 복사한 다음, EC2에 접속한 터미널 상태에서 -> 터미널에 붙여넣고 enter를 하면 -> EC2서버에 nginx, python, django, gunicorn 등 서비스를 배포하는데 필요한 모든 프로그램들을 자동으로 한 번에 설치시켜준다.

- 그래서 터미널 마지막에 [Nginx - Gunicorn - Python Django] Installation Successful -> 이러한 메세지를 봐야 정상적으로 설치가 된 것이라고 볼 수 있다.


