## 장바구니 페이지
- 먼저 DB에 데이터를 추가해주기. 
- Customer DB에서 데이터를 추가할 때 보면, User 모델과 1:1관계에 있기 때문에 생성 시 user 필드에는 User 모델 던더str메소드(__str__)에서 정의한 명칭으로 선택하게 된다. 그리고 name과 e-mail를 설정하자.
- Order DB에서 데이터를 추가할 때도, Customer 모델과 1:N관계에 있기 때문에 customer 필드에는 Customer 모델 던더str메소드(__str__)에서 정의한 명칭으로 선택할 수 있다. 
- 또한, OrderItem DB에서 데이터를 추가하자. product와 order 필드 역시 각각 던더str메소드(__str__)에서 정의한 명칭으로 선택하게 된다.


## views.py 수정



- cart 함수에서 먼저 로그인 여부 확인 진행 및 코드 작성
```python
def cart(request):
    if request.user.is_authenticated:
        customer = request.user.customer
        order, created = Order.objects.get_or_create(customer=customer, complete=False)  # 완료된 주문인지 잡아준다는게 뭘까..
        items = order.orderitem_set.all()   # 이것도 이해 안됨...
    else:
        items = []    

    context = {'items': items}

    return render(request, 'posts/cart.html', context)
```

- 이해가 안됨..



## cart.html 수정
```html
{% for item in items %}
        <tr>
            <th><img src="{{ item.product.imageURL }}" width="100px" height="100px">{{ item.product.product_name }}</th>
            <th>{{ item.product.price }}원</th>
            <th>옵션</th>
            <th>{{ item.quantity }}</th>
            <th><button><a href="{% url 'posts:checkout' %}">구매하기</a></button></th>
            <th><button><a href="">삭제하기</a></button></th>
        </tr>
        {% endfor %}
```

- cart.html에서 보이는 **item**이 바로 OrderItem 모델의 데이터 1개를 의미하고 **{{ item.product.product_name }}** 의 경우,   
  OrderItem의 product 필드가 Product 모델과 1:N관계로 설정되어있어 해당 코드로 OrderItem 모델의 product 필드에 있는 상품의 Product 모델 정보인 product_name를 가져올 수 있게 된다.  



* * *

**2022년 1월 22일** 
지금 프로젝트 상황은, 내가 장바구니에 2개의 상품을 담아놓아서 order item 모델에 2개가 생겼고
(동구밭 올바른 샴푸바 중건성용 (small): 동구밭, 라네즈 크림 스킨 150ml: 아모레퍼시픽)
 그 2개를 한꺼번에 결제하기 때문에 order 모델에 1개의 주문이 생긴 것이다!

**즉, Order 모델은 -> 장바구니에 담겨있는 상품들을 한번에 결제할 때 1개의 데이터가 추가된다!**

**그리고 OrderItem 모델은 -> 장바구니에 상품들을 1개씩 담을때마다 1개의 데이터가 추가된다!**





강의 10:16부터..
