## 장식자 (Decorators)
- 어떤 함수를 감싸는 (Wrapping) 함수

```python
from django.contrib.auth.decorators import login_required
from django.shortcuts import render

@login_required
def protected_view1(request):
    return render(request, 'myapp/secret.html')
    
    
def protected_view2(request):                       # 장식자를 사용한 위의 코드와 밑에 3줄 코드는 동일한 의미이다. 
    return render(request, 'myapp/secret.html')    
        
protected_view2	= login_required(protected_view2)
```

- **장식자는 어떠한 함수위에 @를 쓰고 장식자를 명시한다.**
  - 위의 코드에서는 protected_view1라는 함수를 래핑, 즉 감싸주는 것이다. protected_view1라는 원이 있으면 그 위에 login_required라는 원이 감싼다고 생각하자. **그래서 외부에서 보일때는 
    login_required라는 감싼 함수가 보여지는 것이다.**
  - **그래서, 실제로 protected_view1 라는 함수가 호출될 때에는 -> login_required에 구현된 함수 로직이 먼저 호출이 되고, login_required에서 바로 반환을 할 수도 있고 혹은 어떤 요건이 맞으면
    내부 로직에 따라 실제 protected_view1라는 함수를 호출해서 처리한 다음에 여기에서 return를 주면, 이 결과도 login_required에서 받을 수 있고 그 return값으로 응답을 줄 수도 있는 구조이다.**

- python에서 장식자는 엄청 중요한 문법중에 하나이며 django에서도 다양한 곳에서 활용이 된다.

- 위의 코드에서 protected_view2	=	login_required(protected_view2) -> login_required 함수의 인자로 protected_view2가 들어가서 실행된 로직으로 나온 return 값을, 왼쪽에 protected_view2에 저장하는 것..?
  - 고민해보고 물어보기.

- **위 코드에서 나온 login_required라는 장식자는 -> 실제로 django 기본의 auth 앱 내에서 지원을 해주고 있다.**
  - **어떠한 함수를 login_requried로 감싸게 되면, 외부에서 client 요청이 올 때 해당 유저가 인증이 되었는지 안되어있는지, 즉 로그인이 되어있는지 아닌지를 먼저 체크해서 로그인이 안 되어있다면 로그인 페이지로 
    redirect 해주는 기능을 가지고 있다. 만약 로그인 된 유저라면, 감싸고 있던 함수를 호출해주는 것이다.**
